// Go Substrate RPC Client (GSRPC) provides APIs and types around Polkadot and any Substrate-based chain RPC calls
//
// Copyright 2019 Centrifuge GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package types

var ExamplaryMetadataV13 = &Metadata{MagicNumber: 0x6174656d, Version: 0xd, AsMetadataV4: MetadataV4{Modules: []ModuleMetadataV4(nil)}, AsMetadataV7: MetadataV7{Modules: []ModuleMetadataV7(nil)}, AsMetadataV8: MetadataV8{Modules: []ModuleMetadataV8(nil)}, AsMetadataV9: MetadataV9{Modules: []ModuleMetadataV8(nil)}, AsMetadataV10: MetadataV10{Modules: []ModuleMetadataV10(nil)}, AsMetadataV11: MetadataV11{MetadataV10: MetadataV10{Modules: []ModuleMetadataV10(nil)}, Extrinsic: ExtrinsicV11{Version: 0x0, SignedExtensions: []string(nil)}}, AsMetadataV12: MetadataV12{Modules: []ModuleMetadataV12(nil), Extrinsic: ExtrinsicV11{Version: 0x0, SignedExtensions: []string(nil)}}, AsMetadataV13: MetadataV13{Modules: []ModuleMetadataV13{ModuleMetadataV13{Name: "System", HasStorage: true, Storage: StorageMetadataV13{Prefix: "System", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Account", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::AccountId", Value: "AccountInfo<T::Index, T::AccountData>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The full account information for a particular account ID."}}, StorageFunctionMetadataV13{Name: "ExtrinsicCount", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Total extrinsics count for the current block."}}, StorageFunctionMetadataV13{Name: "BlockWeight", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "ConsumedWeight", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The current weight for the block."}}, StorageFunctionMetadataV13{Name: "AllExtrinsicsLen", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Total length (in bytes) for all extrinsics put together, for the current block."}}, StorageFunctionMetadataV13{Name: "BlockHash", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::BlockNumber", Value: "T::Hash", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Map of block numbers to block hashes."}}, StorageFunctionMetadataV13{Name: "ExtrinsicData", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "u32", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Extrinsics data for the current block (maps an extrinsic's index to its data)."}}, StorageFunctionMetadataV13{Name: "Number", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The current block number being processed. Set by `execute_block`."}}, StorageFunctionMetadataV13{Name: "ParentHash", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "T::Hash", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Hash of the previous block."}}, StorageFunctionMetadataV13{Name: "Digest", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "DigestOf<T>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Digest of the current block, also part of the block header."}}, StorageFunctionMetadataV13{Name: "Events", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<EventRecord<T::Event, T::Hash>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Events deposited for the current block."}}, StorageFunctionMetadataV13{Name: "EventCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "EventIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of events in the `Events<T>` list."}}, StorageFunctionMetadataV13{Name: "EventTopics", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::Hash", Value: "Vec<(T::BlockNumber, EventIndex)>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Mapping between a topic (represented by T::Hash) and a vector of indexes", " of events in the `<Events<T>>` list.", "", " All topic vectors have deterministic storage locations depending on the topic. This", " allows light-clients to leverage the changes trie storage tracking mechanism and", " in case of changes fetch the list of events of interest.", "", " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just", " the `EventIndex` then in case if the topic has the same contents on the next block", " no notification will be triggered thus the event might be lost."}}, StorageFunctionMetadataV13{Name: "LastRuntimeUpgrade", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "LastRuntimeUpgradeInfo", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."}}, StorageFunctionMetadataV13{Name: "UpgradedToU32RefCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."}}, StorageFunctionMetadataV13{Name: "UpgradedToTripleRefCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" True if we have upgraded so that AccountInfo contains three types of `RefCount`. False", " (default) if not."}}, StorageFunctionMetadataV13{Name: "ExecutionPhase", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Phase", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The execution phase of the block."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "fill_block", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "_ratio", Type: "Perbill"}}, Documentation: []Text{" A dispatch that will fill the block weight up to the given ratio."}}, FunctionMetadataV4{Name: "remark", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "_remark", Type: "Vec<u8>"}}, Documentation: []Text{" Make some on-chain remark.", "", " # <weight>", " - `O(1)`", " # </weight>"}}, FunctionMetadataV4{Name: "set_heap_pages", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "pages", Type: "u64"}}, Documentation: []Text{" Set the number of pages in the WebAssembly environment's heap.", "", " # <weight>", " - `O(1)`", " - 1 storage write.", " - Base Weight: 1.405 µs", " - 1 write to HEAP_PAGES", " # </weight>"}}, FunctionMetadataV4{Name: "set_code", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "code", Type: "Vec<u8>"}}, Documentation: []Text{" Set the new runtime code.", "", " # <weight>", " - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`", " - 1 storage write (codec `O(C)`).", " - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is expensive).", " - 1 event.", " The weight of this function is dependent on the runtime, but generally this is very expensive.", " We will treat this as a full block.", " # </weight>"}}, FunctionMetadataV4{Name: "set_code_without_checks", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "code", Type: "Vec<u8>"}}, Documentation: []Text{" Set the new runtime code without doing any checks of the given `code`.", "", " # <weight>", " - `O(C)` where `C` length of `code`", " - 1 storage write (codec `O(C)`).", " - 1 event.", " The weight of this function is dependent on the runtime. We will treat this as a full block.", " # </weight>"}}, FunctionMetadataV4{Name: "set_changes_trie_config", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "changes_trie_config", Type: "Option<ChangesTrieConfiguration>"}}, Documentation: []Text{" Set the new changes trie configuration.", "", " # <weight>", " - `O(1)`", " - 1 storage write or delete (codec `O(1)`).", " - 1 call to `deposit_log`: Uses `append` API, so O(1)", " - Base Weight: 7.218 µs", " - DB Weight:", "     - Writes: Changes Trie, System Digest", " # </weight>"}}, FunctionMetadataV4{Name: "set_storage", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "items", Type: "Vec<KeyValue>"}}, Documentation: []Text{" Set some items of storage.", "", " # <weight>", " - `O(I)` where `I` length of `items`", " - `I` storage writes (`O(1)`).", " - Base Weight: 0.568 * i µs", " - Writes: Number of items", " # </weight>"}}, FunctionMetadataV4{Name: "kill_storage", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "keys", Type: "Vec<Key>"}}, Documentation: []Text{" Kill some items from storage.", "", " # <weight>", " - `O(IK)` where `I` length of `keys` and `K` length of one key", " - `I` storage deletions.", " - Base Weight: .378 * i µs", " - Writes: Number of items", " # </weight>"}}, FunctionMetadataV4{Name: "kill_prefix", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "prefix", Type: "Key"}, FunctionArgumentMetadata{Name: "_subkeys", Type: "u32"}}, Documentation: []Text{" Kill all storage items with a key that starts with the given prefix.", "", " **NOTE:** We rely on the Root origin to provide us the number of subkeys under", " the prefix we are removing to accurately calculate the weight of this function.", "", " # <weight>", " - `O(P)` where `P` amount of keys with prefix `prefix`", " - `P` storage deletions.", " - Base Weight: 0.834 * P µs", " - Writes: Number of subkeys + 1", " # </weight>"}}, FunctionMetadataV4{Name: "remark_with_event", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "remark", Type: "Vec<u8>"}}, Documentation: []Text{" Make some on-chain remark and emit event.", "", " # <weight>", " - `O(b)` where b is the length of the remark.", " - 1 event.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "ExtrinsicSuccess", Args: []Type{"DispatchInfo"}, Documentation: []Text{" An extrinsic completed successfully. \\[info\\]"}}, EventMetadataV4{Name: "ExtrinsicFailed", Args: []Type{"DispatchError", "DispatchInfo"}, Documentation: []Text{" An extrinsic failed. \\[error, info\\]"}}, EventMetadataV4{Name: "CodeUpdated", Args: []Type(nil), Documentation: []Text{" `:code` was updated."}}, EventMetadataV4{Name: "NewAccount", Args: []Type{"AccountId"}, Documentation: []Text{" A new \\[account\\] was created."}}, EventMetadataV4{Name: "KilledAccount", Args: []Type{"AccountId"}, Documentation: []Text{" An \\[account\\] was reaped."}}, EventMetadataV4{Name: "Remarked", Args: []Type{"AccountId", "Hash"}, Documentation: []Text{" On on-chain remark happened. \\[origin, remark_hash\\]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "BlockWeights", Type: "limits::BlockWeights", Value: Bytes{0x0, 0xf2, 0x5, 0x2a, 0x1, 0x0, 0x0, 0x0, 0x0, 0x20, 0x4a, 0xa9, 0xd1, 0x1, 0x0, 0x0, 0x40, 0x59, 0x73, 0x7, 0x0, 0x0, 0x0, 0x0, 0x1, 0xc0, 0x6e, 0x96, 0xa6, 0x2e, 0x1, 0x0, 0x0, 0x1, 0x0, 0x98, 0xf7, 0x3e, 0x5d, 0x1, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0x59, 0x73, 0x7, 0x0, 0x0, 0x0, 0x0, 0x1, 0xc0, 0xf6, 0xe8, 0x10, 0xa3, 0x1, 0x0, 0x0, 0x1, 0x0, 0x20, 0x4a, 0xa9, 0xd1, 0x1, 0x0, 0x0, 0x1, 0x0, 0x88, 0x52, 0x6a, 0x74, 0x0, 0x0, 0x0, 0x40, 0x59, 0x73, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Block & extrinsics weights: base values and limits."}}, ModuleConstantMetadataV6{Name: "BlockLength", Type: "limits::BlockLength", Value: Bytes{0x0, 0x0, 0x3c, 0x0, 0x0, 0x0, 0x50, 0x0, 0x0, 0x0, 0x50, 0x0}, Documentation: []Text{" The maximum length of a block (in bytes)."}}, ModuleConstantMetadataV6{Name: "BlockHashCount", Type: "T::BlockNumber", Value: Bytes{0x60, 0x9, 0x0, 0x0}, Documentation: []Text{" Maximum number of block number to block hash mappings to keep (oldest pruned first)."}}, ModuleConstantMetadataV6{Name: "DbWeight", Type: "RuntimeDbWeight", Value: Bytes{0x40, 0x78, 0x7d, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe1, 0xf5, 0x5, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The weight of runtime database operations the runtime can invoke."}}, ModuleConstantMetadataV6{Name: "Version", Type: "RuntimeVersion", Value: Bytes{0x10, 0x6e, 0x6f, 0x64, 0x65, 0x38, 0x73, 0x75, 0x62, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x2d, 0x6e, 0x6f, 0x64, 0x65, 0xa, 0x0, 0x0, 0x0, 0xb, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x34, 0xdf, 0x6a, 0xcb, 0x68, 0x99, 0x7, 0x60, 0x9b, 0x3, 0x0, 0x0, 0x0, 0x37, 0xe3, 0x97, 0xfc, 0x7c, 0x91, 0xf5, 0xe4, 0x1, 0x0, 0x0, 0x0, 0x40, 0xfe, 0x3a, 0xd4, 0x1, 0xf8, 0x95, 0x9a, 0x5, 0x0, 0x0, 0x0, 0xd2, 0xbc, 0x98, 0x97, 0xee, 0xd0, 0x8f, 0x15, 0x2, 0x0, 0x0, 0x0, 0xf7, 0x8b, 0x27, 0x8b, 0xe5, 0x3f, 0x45, 0x4c, 0x2, 0x0, 0x0, 0x0, 0xed, 0x99, 0xc5, 0xac, 0xb2, 0x5e, 0xed, 0xf5, 0x2, 0x0, 0x0, 0x0, 0xcb, 0xca, 0x25, 0xe3, 0x9f, 0x14, 0x23, 0x87, 0x2, 0x0, 0x0, 0x0, 0x68, 0x7a, 0xd4, 0x4a, 0xd3, 0x7f, 0x3, 0xc2, 0x1, 0x0, 0x0, 0x0, 0xbc, 0x9d, 0x89, 0x90, 0x4f, 0x5b, 0x92, 0x3f, 0x1, 0x0, 0x0, 0x0, 0x68, 0xb6, 0x6b, 0xa1, 0x22, 0xc9, 0x3f, 0xa7, 0x1, 0x0, 0x0, 0x0, 0x37, 0xc8, 0xbb, 0x13, 0x50, 0xa9, 0xa2, 0xa8, 0x1, 0x0, 0x0, 0x0, 0x91, 0xd5, 0xdf, 0x18, 0xb0, 0xd2, 0xcf, 0x58, 0x1, 0x0, 0x0, 0x0, 0xab, 0x3c, 0x5, 0x72, 0x29, 0x1f, 0xeb, 0x8b, 0x1, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0}, Documentation: []Text{" Get the chain's current version."}}, ModuleConstantMetadataV6{Name: "SS58Prefix", Type: "u8", Value: Bytes{0x2a}, Documentation: []Text{" The designated SS85 prefix of this chain.", "", " This replaces the \"ss58Format\" property declared in the chain spec. Reason is", " that the runtime should know about the prefix in order to make use of it as", " an identifier of the chain."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InvalidSpecName", Documentation: []Text{" The name of specification does not match between the current runtime", " and the new runtime."}}, ErrorMetadataV8{Name: "SpecVersionNeedsToIncrease", Documentation: []Text{" The specification version is not allowed to decrease between the current runtime", " and the new runtime."}}, ErrorMetadataV8{Name: "FailedToExtractRuntimeVersion", Documentation: []Text{" Failed to extract the runtime version from the new runtime.", "", " Either calling `Core_version` or decoding `RuntimeVersion` failed."}}, ErrorMetadataV8{Name: "NonDefaultComposite", Documentation: []Text{" Suicide called when the account has non-default composite data."}}, ErrorMetadataV8{Name: "NonZeroRefCount", Documentation: []Text{" There is a non-zero reference count preventing the account from being purged."}}}, Index: 0x0}, ModuleMetadataV13{Name: "Utility", HasStorage: false, Storage: StorageMetadataV13{Prefix: "", Items: []StorageFunctionMetadataV13(nil)}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "batch", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "calls", Type: "Vec<<T as Config>::Call>"}}, Documentation: []Text{" Send a batch of dispatch calls.", "", " May be called from any origin.", "", " - `calls`: The calls to be dispatched from the same origin.", "", " If origin is root then call are dispatch without checking origin filter. (This includes", " bypassing `frame_system::Config::BaseCallFilter`).", "", " # <weight>", " - Complexity: O(C) where C is the number of calls to be batched.", " # </weight>", "", " This will return `Ok` in all circumstances. To determine the success of the batch, an", " event is deposited. If a call failed and the batch was interrupted, then the", " `BatchInterrupted` event is deposited, along with the number of successful calls made", " and the error of the failed call. If all were successful, then the `BatchCompleted`", " event is deposited."}}, FunctionMetadataV4{Name: "as_derivative", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "u16"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Config>::Call>"}}, Documentation: []Text{" Send a call through an indexed pseudonym of the sender.", "", " Filter from origin are passed along. The call will be dispatched with an origin which", " use the same filter as the origin of this call.", "", " NOTE: If you need to ensure that any account-based filtering is not honored (i.e.", " because you expect `proxy` to have been used prior in the call stack and you do not want", " the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`", " in the Multisig pallet instead.", "", " NOTE: Prior to version *12, this was called `as_limited_sub`.", "", " The dispatch origin for this call must be _Signed_."}}, FunctionMetadataV4{Name: "batch_all", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "calls", Type: "Vec<<T as Config>::Call>"}}, Documentation: []Text{" Send a batch of dispatch calls and atomically execute them.", " The whole transaction will rollback and fail if any of the calls failed.", "", " May be called from any origin.", "", " - `calls`: The calls to be dispatched from the same origin.", "", " If origin is root then call are dispatch without checking origin filter. (This includes", " bypassing `frame_system::Config::BaseCallFilter`).", "", " # <weight>", " - Complexity: O(C) where C is the number of calls to be batched.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "BatchInterrupted", Args: []Type{"u32", "DispatchError"}, Documentation: []Text{" Batch of dispatches did not complete fully. Index of first failing dispatch given, as", " well as the error. \\[index, error\\]"}}, EventMetadataV4{Name: "BatchCompleted", Args: []Type(nil), Documentation: []Text{" Batch of dispatches completed fully with no error."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil), Index: 0x1}, ModuleMetadataV13{Name: "Babe", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Babe", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "EpochIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "u64", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current epoch index."}}, StorageFunctionMetadataV13{Name: "Authorities", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<(AuthorityId, BabeAuthorityWeight)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Current epoch authorities."}}, StorageFunctionMetadataV13{Name: "GenesisSlot", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Slot", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The slot at which the first epoch actually started. This is 0", " until the first block of the chain."}}, StorageFunctionMetadataV13{Name: "CurrentSlot", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Slot", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current slot number."}}, StorageFunctionMetadataV13{Name: "Randomness", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "schnorrkel::Randomness", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The epoch randomness for the *current* epoch.", "", " # Security", "", " This MUST NOT be used for gambling, as it can be influenced by a", " malicious validator in the short term. It MAY be used in many", " cryptographic protocols, however, so long as one remembers that this", " (like everything else on-chain) it is public. For example, it can be", " used where a number is needed that cannot have been chosen by an", " adversary, for purposes such as public-coin zero-knowledge proofs."}}, StorageFunctionMetadataV13{Name: "PendingEpochConfigChange", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "NextConfigDescriptor", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Pending epoch configuration change that will be applied when the next epoch is enacted."}}, StorageFunctionMetadataV13{Name: "NextRandomness", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "schnorrkel::Randomness", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Next epoch randomness."}}, StorageFunctionMetadataV13{Name: "NextAuthorities", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<(AuthorityId, BabeAuthorityWeight)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Next epoch authorities."}}, StorageFunctionMetadataV13{Name: "SegmentIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Randomness under construction.", "", " We make a tradeoff between storage accesses and list length.", " We store the under-construction randomness in segments of up to", " `UNDER_CONSTRUCTION_SEGMENT_LENGTH`.", "", " Once a segment reaches this length, we begin the next one.", " We reset all segments and return to `0` at the beginning of every", " epoch."}}, StorageFunctionMetadataV13{Name: "UnderConstruction", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "u32", Value: "Vec<schnorrkel::Randomness>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay."}}, StorageFunctionMetadataV13{Name: "Initialized", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "MaybeRandomness", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Temporary value (cleared at block finalization) which is `Some`", " if per-block initialization has already been called for current block."}}, StorageFunctionMetadataV13{Name: "AuthorVrfRandomness", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "MaybeRandomness", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Temporary value (cleared at block finalization) that includes the VRF output generated", " at this block. This field should always be populated during block processing unless", " secondary plain slots are enabled (which don't contain a VRF output)."}}, StorageFunctionMetadataV13{Name: "EpochStart", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "(T::BlockNumber, T::BlockNumber)", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The block numbers when the last and current epoch have started, respectively `N-1` and", " `N`.", " NOTE: We track this is in order to annotate the block number when a given pool of", " entropy was fixed (i.e. it was known to chain observers). Since epochs are defined in", " slots, which may be skipped, the block numbers may not line up with the slot numbers."}}, StorageFunctionMetadataV13{Name: "Lateness", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" How late the current block is compared to its parent.", "", " This entry is populated as part of block execution and is cleaned up", " on block finalization. Querying this storage entry outside of block", " execution context should always yield zero."}}, StorageFunctionMetadataV13{Name: "EpochConfig", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "BabeEpochConfiguration", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The configuration for the current epoch. Should never be `None` as it is initialized in genesis."}}, StorageFunctionMetadataV13{Name: "NextEpochConfig", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "BabeEpochConfiguration", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The configuration for the next epoch, `None` if the config will not change", " (you can fallback to `EpochConfig` instead in that case)."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "report_equivocation", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "equivocation_proof", Type: "EquivocationProof<T::Header>"}, FunctionArgumentMetadata{Name: "key_owner_proof", Type: "T::KeyOwnerProof"}}, Documentation: []Text{" Report authority equivocation/misbehavior. This method will verify", " the equivocation proof and validate the given key ownership proof", " against the extracted offender. If both are valid, the offence will", " be reported."}}, FunctionMetadataV4{Name: "report_equivocation_unsigned", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "equivocation_proof", Type: "EquivocationProof<T::Header>"}, FunctionArgumentMetadata{Name: "key_owner_proof", Type: "T::KeyOwnerProof"}}, Documentation: []Text{" Report authority equivocation/misbehavior. This method will verify", " the equivocation proof and validate the given key ownership proof", " against the extracted offender. If both are valid, the offence will", " be reported.", " This extrinsic must be called unsigned and it is expected that only", " block authors will call it (validated in `ValidateUnsigned`), as such", " if the block author is defined it will be defined as the equivocation", " reporter."}}, FunctionMetadataV4{Name: "plan_config_change", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "config", Type: "NextConfigDescriptor"}}, Documentation: []Text{" Plan an epoch config change. The epoch config change is recorded and will be enacted on", " the next call to `enact_epoch_change`. The config will be activated one epoch after.", " Multiple calls to this method will replace any existing planned config change that had", " not been enacted yet."}}}, HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "EpochDuration", Type: "u64", Value: Bytes{0xc8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of time, in slots, that each epoch should last.", " NOTE: Currently it is not possible to change the epoch duration after", " the chain has started. Attempting to do so will brick block production."}}, ModuleConstantMetadataV6{Name: "ExpectedBlockTime", Type: "T::Moment", Value: Bytes{0xb8, 0xb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The expected average block time at which BABE should be creating", " blocks. Since BABE is probabilistic it is not trivial to figure out", " what the expected average block time should be based on the slot", " duration and the security parameter `c` (where `1 - c` represents", " the probability of a slot being empty)."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InvalidEquivocationProof", Documentation: []Text{" An equivocation proof provided as part of an equivocation report is invalid."}}, ErrorMetadataV8{Name: "InvalidKeyOwnershipProof", Documentation: []Text{" A key ownership proof provided as part of an equivocation report is invalid."}}, ErrorMetadataV8{Name: "DuplicateOffenceReport", Documentation: []Text{" A given equivocation report is valid but already previously reported."}}}, Index: 0x2}, ModuleMetadataV13{Name: "Timestamp", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Timestamp", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Now", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "T::Moment", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current time for the current block."}}, StorageFunctionMetadataV13{Name: "DidUpdate", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Did the timestamp get updated in this block?"}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "set", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "now", Type: "Compact<T::Moment>"}}, Documentation: []Text{" Set the current time.", "", " This call should be invoked exactly once per block. It will panic at the finalization", " phase, if this call hasn't been invoked by that time.", "", " The timestamp should be greater than the previous one by the amount specified by", " `MinimumPeriod`.", "", " The dispatch origin for this call must be `Inherent`.", "", " # <weight>", " - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)", " - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in `on_finalize`)", " - 1 event handler `on_timestamp_set`. Must be `O(1)`.", " # </weight>"}}}, HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "MinimumPeriod", Type: "T::Moment", Value: Bytes{0xdc, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum period between blocks. Beware that this is different to the *expected* period", " that the block production apparatus provides. Your chosen consensus system will generally", " work with this to determine a sensible block time. e.g. For Aura, it will be double this", " period on default settings."}}}, Errors: []ErrorMetadataV8(nil), Index: 0x3}, ModuleMetadataV13{Name: "Authorship", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Authorship", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Uncles", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<UncleEntryItem<T::BlockNumber, T::Hash, T::AccountId>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Uncles"}}, StorageFunctionMetadataV13{Name: "Author", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Author of current block."}}, StorageFunctionMetadataV13{Name: "DidSetUncles", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Whether uncles were already set in this block."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "set_uncles", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new_uncles", Type: "Vec<T::Header>"}}, Documentation: []Text{" Provide a set of uncles."}}}, HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InvalidUncleParent", Documentation: []Text{" The uncle parent not in the chain."}}, ErrorMetadataV8{Name: "UnclesAlreadySet", Documentation: []Text{" Uncles already set in the block."}}, ErrorMetadataV8{Name: "TooManyUncles", Documentation: []Text{" Too many uncles."}}, ErrorMetadataV8{Name: "GenesisUncle", Documentation: []Text{" The uncle is genesis."}}, ErrorMetadataV8{Name: "TooHighUncle", Documentation: []Text{" The uncle is too high in chain."}}, ErrorMetadataV8{Name: "UncleAlreadyIncluded", Documentation: []Text{" The uncle is already included."}}, ErrorMetadataV8{Name: "OldUncle", Documentation: []Text{" The uncle isn't recent enough to be included."}}}, Index: 0x4}, ModuleMetadataV13{Name: "Indices", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Indices", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Accounts", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::AccountIndex", Value: "(T::AccountId, BalanceOf<T>, bool)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The lookup from index to account."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "claim", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "T::AccountIndex"}}, Documentation: []Text{" Assign an previously unassigned index.", "", " Payment: `Deposit` is reserved from the sender account.", "", " The dispatch origin for this call must be _Signed_.", "", " - `index`: the index to be claimed. This must not be in use.", "", " Emits `IndexAssigned` if successful.", "", " # <weight>", " - `O(1)`.", " - One storage mutation (codec `O(1)`).", " - One reserve operation.", " - One event.", " -------------------", " - DB Weight: 1 Read/Write (Accounts)", " # </weight>"}}, FunctionMetadataV4{Name: "transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "index", Type: "T::AccountIndex"}}, Documentation: []Text{" Assign an index already owned by the sender to another account. The balance reservation", " is effectively transferred to the new account.", "", " The dispatch origin for this call must be _Signed_.", "", " - `index`: the index to be re-assigned. This must be owned by the sender.", " - `new`: the new owner of the index. This function is a no-op if it is equal to sender.", "", " Emits `IndexAssigned` if successful.", "", " # <weight>", " - `O(1)`.", " - One storage mutation (codec `O(1)`).", " - One transfer operation.", " - One event.", " -------------------", " - DB Weight:", "    - Reads: Indices Accounts, System Account (recipient)", "    - Writes: Indices Accounts, System Account (recipient)", " # </weight>"}}, FunctionMetadataV4{Name: "free", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "T::AccountIndex"}}, Documentation: []Text{" Free up an index owned by the sender.", "", " Payment: Any previous deposit placed for the index is unreserved in the sender account.", "", " The dispatch origin for this call must be _Signed_ and the sender must own the index.", "", " - `index`: the index to be freed. This must be owned by the sender.", "", " Emits `IndexFreed` if successful.", "", " # <weight>", " - `O(1)`.", " - One storage mutation (codec `O(1)`).", " - One reserve operation.", " - One event.", " -------------------", " - DB Weight: 1 Read/Write (Accounts)", " # </weight>"}}, FunctionMetadataV4{Name: "force_transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "index", Type: "T::AccountIndex"}, FunctionArgumentMetadata{Name: "freeze", Type: "bool"}}, Documentation: []Text{" Force an index to an account. This doesn't require a deposit. If the index is already", " held, then any deposit is reimbursed to its current owner.", "", " The dispatch origin for this call must be _Root_.", "", " - `index`: the index to be (re-)assigned.", " - `new`: the new owner of the index. This function is a no-op if it is equal to sender.", " - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.", "", " Emits `IndexAssigned` if successful.", "", " # <weight>", " - `O(1)`.", " - One storage mutation (codec `O(1)`).", " - Up to one reserve operation.", " - One event.", " -------------------", " - DB Weight:", "    - Reads: Indices Accounts, System Account (original owner)", "    - Writes: Indices Accounts, System Account (original owner)", " # </weight>"}}, FunctionMetadataV4{Name: "freeze", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "T::AccountIndex"}}, Documentation: []Text{" Freeze an index so it will always point to the sender account. This consumes the deposit.", "", " The dispatch origin for this call must be _Signed_ and the signing account must have a", " non-frozen account `index`.", "", " - `index`: the index to be frozen in place.", "", " Emits `IndexFrozen` if successful.", "", " # <weight>", " - `O(1)`.", " - One storage mutation (codec `O(1)`).", " - Up to one slash operation.", " - One event.", " -------------------", " - DB Weight: 1 Read/Write (Accounts)", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "IndexAssigned", Args: []Type{"AccountId", "AccountIndex"}, Documentation: []Text{" A account index was assigned. \\[index, who\\]"}}, EventMetadataV4{Name: "IndexFreed", Args: []Type{"AccountIndex"}, Documentation: []Text{" A account index has been freed up (unassigned). \\[index\\]"}}, EventMetadataV4{Name: "IndexFrozen", Args: []Type{"AccountIndex", "AccountId"}, Documentation: []Text{" A account index has been frozen to its current account ID. \\[index, who\\]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "Deposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The deposit needed for reserving an index."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "NotAssigned", Documentation: []Text{" The index was not already assigned."}}, ErrorMetadataV8{Name: "NotOwner", Documentation: []Text{" The index is assigned to another account."}}, ErrorMetadataV8{Name: "InUse", Documentation: []Text{" The index was not available."}}, ErrorMetadataV8{Name: "NotTransfer", Documentation: []Text{" The source and destination accounts are identical."}}, ErrorMetadataV8{Name: "Permanent", Documentation: []Text{" The index is permanent and may not be freed/changed."}}}, Index: 0x5}, ModuleMetadataV13{Name: "Balances", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Balances", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "TotalIssuance", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "T::Balance", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The total units issued in the system."}}, StorageFunctionMetadataV13{Name: "Account", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::AccountId", Value: "AccountData<T::Balance>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The balance of an account.", "", " NOTE: This is only used in the case that this pallet is used to store balances."}}, StorageFunctionMetadataV13{Name: "Locks", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::AccountId", Value: "WeakBoundedVec<BalanceLock<T::Balance>, T::MaxLocks>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Any liquidity locks on some account balances.", " NOTE: Should only be accessed when setting, changing and freeing a lock."}}, StorageFunctionMetadataV13{Name: "Reserves", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::AccountId", Value: "BoundedVec<ReserveData<T::ReserveIdentifier, T::Balance>, T::\nMaxReserves>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Named reserves on some account balances."}}, StorageFunctionMetadataV13{Name: "StorageVersion", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Releases", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Storage version of the pallet.", "", " This is set to v2.0.0 for new networks."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Transfer some liquid free balance to another account.", "", " `transfer` will set the `FreeBalance` of the sender and receiver.", " It will decrease the total issuance of the system by the `TransferFee`.", " If the sender's account is below the existential deposit as a result", " of the transfer, the account will be reaped.", "", " The dispatch origin for this call must be `Signed` by the transactor.", "", " # <weight>", " - Dependent on arguments but not critical, given proper implementations for", "   input config  See related functions below.", " - It contains a limited number of reads and writes internally and no complex computation.", "", " Related functions:", "", "   - `ensure_can_withdraw` is always called internally but has a bounded complexity.", "   - Transferring balances to accounts that did not exist before will cause", "      `T::OnNewAccount::on_new_account` to be called.", "   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.", "   - `transfer_keep_alive` works the same way as `transfer`, but has an additional", "     check that the transfer will not kill the origin account.", " ---------------------------------", " - Base Weight: 73.64 µs, worst case scenario (account created, account removed)", " - DB Weight: 1 Read and 1 Write to destination account", " - Origin account is already in memory, so no DB operations for them.", " # </weight>"}}, FunctionMetadataV4{Name: "set_balance", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "new_free", Type: "Compact<T::Balance>"}, FunctionArgumentMetadata{Name: "new_reserved", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Set the balances of a given account.", "", " This will alter `FreeBalance` and `ReservedBalance` in storage. it will", " also decrease the total issuance of the system (`TotalIssuance`).", " If the new free or reserved balance is below the existential deposit,", " it will reset the account nonce (`frame_system::AccountNonce`).", "", " The dispatch origin for this call is `root`.", "", " # <weight>", " - Independent of the arguments.", " - Contains a limited number of reads and writes.", " ---------------------", " - Base Weight:", "     - Creating: 27.56 µs", "     - Killing: 35.11 µs", " - DB Weight: 1 Read, 1 Write to `who`", " # </weight>"}}, FunctionMetadataV4{Name: "force_transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "source", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Exactly as `transfer`, except the origin must be root and the source account may be", " specified.", " # <weight>", " - Same as transfer, but additional read and write because the source account is", "   not assumed to be in the overlay.", " # </weight>"}}, FunctionMetadataV4{Name: "transfer_keep_alive", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Same as the [`transfer`] call, but with a check that the transfer will not kill the", " origin account.", "", " 99% of the time you want [`transfer`] instead.", "", " [`transfer`]: struct.Pallet.html#method.transfer", " # <weight>", " - Cheaper than transfer because account cannot be killed.", " - Base Weight: 51.4 µs", " - DB Weight: 1 Read and 1 Write to dest (sender is in overlay already)", " #</weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Endowed", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" An account was created with some free balance. \\[account, free_balance\\]"}}, EventMetadataV4{Name: "DustLost", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" An account was removed whose balance was non-zero but below ExistentialDeposit,", " resulting in an outright loss. \\[account, balance\\]"}}, EventMetadataV4{Name: "Transfer", Args: []Type{"AccountId", "AccountId", "Balance"}, Documentation: []Text{" Transfer succeeded. \\[from, to, value\\]"}}, EventMetadataV4{Name: "BalanceSet", Args: []Type{"AccountId", "Balance", "Balance"}, Documentation: []Text{" A balance was set by root. \\[who, free, reserved\\]"}}, EventMetadataV4{Name: "Deposit", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" Some amount was deposited (e.g. for transaction fees). \\[who, deposit\\]"}}, EventMetadataV4{Name: "Reserved", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" Some balance was reserved (moved from free to reserved). \\[who, value\\]"}}, EventMetadataV4{Name: "Unreserved", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" Some balance was unreserved (moved from reserved to free). \\[who, value\\]"}}, EventMetadataV4{Name: "ReserveRepatriated", Args: []Type{"AccountId", "AccountId", "Balance", "Status"}, Documentation: []Text{" Some balance was moved from the reserve of the first account to the second account.", " Final argument indicates the destination balance type.", " \\[from, to, balance, destination_status\\]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "ExistentialDeposit", Type: "T::Balance", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount required to keep an account open."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "VestingBalance", Documentation: []Text{" Vesting balance too high to send value"}}, ErrorMetadataV8{Name: "LiquidityRestrictions", Documentation: []Text{" Account liquidity restrictions prevent withdrawal"}}, ErrorMetadataV8{Name: "InsufficientBalance", Documentation: []Text{" Balance too low to send value"}}, ErrorMetadataV8{Name: "ExistentialDeposit", Documentation: []Text{" Value too low to create account due to existential deposit"}}, ErrorMetadataV8{Name: "KeepAlive", Documentation: []Text{" Transfer/payment would kill account"}}, ErrorMetadataV8{Name: "ExistingVestingSchedule", Documentation: []Text{" A vesting schedule already exists for this account"}}, ErrorMetadataV8{Name: "DeadAccount", Documentation: []Text{" Beneficiary account must pre-exist"}}, ErrorMetadataV8{Name: "TooManyReserves", Documentation: []Text{" Number of named reserves exceed MaxReserves"}}}, Index: 0x6}, ModuleMetadataV13{Name: "TransactionPayment", HasStorage: true, Storage: StorageMetadataV13{Prefix: "TransactionPayment", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "NextFeeMultiplier", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Multiplier", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x64, 0xa7, 0xb3, 0xb6, 0xe0, 0xd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text(nil)}, StorageFunctionMetadataV13{Name: "StorageVersion", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Releases", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text(nil)}}}, HasCalls: false, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "TransactionByteFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0xe4, 0xb, 0x54, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee to be paid for making a transaction; the per-byte portion."}}, ModuleConstantMetadataV6{Name: "WeightToFee", Type: "Vec<WeightToFeeCoefficient<BalanceOf<T>>>", Value: Bytes{0x4, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1}, Documentation: []Text{" The polynomial that is applied in order to derive fee from weight."}}}, Errors: []ErrorMetadataV8(nil), Index: 0x7}, ModuleMetadataV13{Name: "ElectionProviderMultiPhase", HasStorage: true, Storage: StorageMetadataV13{Prefix: "ElectionProviderMultiPhase", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Round", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x1, 0x0, 0x0, 0x0}, Documentation: []Text{" Internal counter for the number of rounds.", "", " This is useful for de-duplication of transactions submitted to the pool, and general", " diagnostics of the pallet.", "", " This is merely incremented once per every time that an upstream `elect` is called."}}, StorageFunctionMetadataV13{Name: "CurrentPhase", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Phase<T::BlockNumber>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Current phase."}}, StorageFunctionMetadataV13{Name: "QueuedSolution", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "ReadySolution<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Current best solution, signed or unsigned, queued to be returned upon `elect`."}}, StorageFunctionMetadataV13{Name: "Snapshot", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "RoundSnapshot<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Snapshot data of the round.", "", " This is created at the beginning of the signed phase and cleared upon calling `elect`."}}, StorageFunctionMetadataV13{Name: "DesiredTargets", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Desired number of targets to elect for this round.", "", " Only exists when [`Snapshot`] is present."}}, StorageFunctionMetadataV13{Name: "SnapshotMetadata", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "SolutionOrSnapshotSize", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The metadata of the [`RoundSnapshot`]", "", " Only exists when [`Snapshot`] is present."}}, StorageFunctionMetadataV13{Name: "MinimumUntrustedScore", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "ElectionScore", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The minimum score that each 'untrusted' solution must attain in order to be considered", " feasible.", "", " Can be set via `set_minimum_untrusted_score`."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "submit_unsigned", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "solution", Type: "RawSolution<CompactOf<T>>"}, FunctionArgumentMetadata{Name: "witness", Type: "SolutionOrSnapshotSize"}}, Documentation: []Text{" Submit a solution for the unsigned phase.", "", " The dispatch origin fo this call must be __none__.", "", " This submission is checked on the fly. Moreover, this unsigned solution is only", " validated when submitted to the pool from the **local** node. Effectively, this means", " that only active validators can submit this transaction when authoring a block (similar", " to an inherent).", "", " To prevent any incorrect solution (and thus wasted time/weight), this transaction will", " panic if the solution submitted by the validator is invalid in any way, effectively", " putting their authoring reward at risk.", "", " No deposit or reward is associated with this submission."}}, FunctionMetadataV4{Name: "set_minimum_untrusted_score", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "maybe_next_score", Type: "Option<ElectionScore>"}}, Documentation: []Text{" Set a new value for `MinimumUntrustedScore`.", "", " Dispatch origin must be aligned with `T::ForceOrigin`.", "", " This check can be turned off by setting the value to `None`."}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "SolutionStored", Args: []Type{"ElectionCompute"}, Documentation: []Text{" A solution was stored with the given compute.", "", " If the solution is signed, this means that it hasn't yet been processed. If the", " solution is unsigned, this means that it has also been processed."}}, EventMetadataV4{Name: "ElectionFinalized", Args: []Type{"Option<ElectionCompute>"}, Documentation: []Text{" The election has been finalized, with `Some` of the given computation, or else if the", " election failed, `None`."}}, EventMetadataV4{Name: "Rewarded", Args: []Type{"AccountId"}, Documentation: []Text{" An account has been rewarded for their signed submission being finalized."}}, EventMetadataV4{Name: "Slashed", Args: []Type{"AccountId"}, Documentation: []Text{" An account has been slashed for submitting an invalid signed submission."}}, EventMetadataV4{Name: "SignedPhaseStarted", Args: []Type{"u32"}, Documentation: []Text{" The signed phase of the given round has started."}}, EventMetadataV4{Name: "UnsignedPhaseStarted", Args: []Type{"u32"}, Documentation: []Text{" The unsigned phase of the given round has started."}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "UnsignedPhase", Type: "T::BlockNumber", Value: Bytes{0x32, 0x0, 0x0, 0x0}, Documentation: []Text{" Duration of the unsigned phase."}}, ModuleConstantMetadataV6{Name: "SignedPhase", Type: "T::BlockNumber", Value: Bytes{0x32, 0x0, 0x0, 0x0}, Documentation: []Text{" Duration of the signed phase."}}, ModuleConstantMetadataV6{Name: "SolutionImprovementThreshold", Type: "Perbill", Value: Bytes{0xa0, 0x86, 0x1, 0x0}, Documentation: []Text{" The minimum amount of improvement to the solution score that defines a solution as", " \"better\" (in any phase)."}}, ModuleConstantMetadataV6{Name: "OffchainRepeat", Type: "T::BlockNumber", Value: Bytes{0x5, 0x0, 0x0, 0x0}, Documentation: []Text{" The repeat threshold of the offchain worker.", "", " For example, if it is 5, that means that at least 5 blocks will elapse between attempts", " to submit the worker's solution."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "PreDispatchEarlySubmission", Documentation: []Text{" Submission was too early."}}, ErrorMetadataV8{Name: "PreDispatchWrongWinnerCount", Documentation: []Text{" Wrong number of winners presented."}}, ErrorMetadataV8{Name: "PreDispatchWeakSubmission", Documentation: []Text{" Submission was too weak, score-wise."}}, ErrorMetadataV8{Name: "OcwCallWrongEra", Documentation: []Text{" OCW submitted solution for wrong round"}}}, Index: 0x8}, ModuleMetadataV13{Name: "Staking", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Staking", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "HistoryDepth", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x54, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of eras to keep in history.", "", " Information is kept for eras in `[current_era - history_depth; current_era]`.", "", " Must be more than the number of eras delayed by session otherwise. I.e. active era must", " always be in history. I.e. `active_era > current_era - history_depth` must be", " guaranteed."}}, StorageFunctionMetadataV13{Name: "ValidatorCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The ideal number of staking participants."}}, StorageFunctionMetadataV13{Name: "MinimumValidatorCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Minimum number of staking participants before emergency conditions are imposed."}}, StorageFunctionMetadataV13{Name: "Invulnerables", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Any validators that may never be slashed or forcibly kicked. It's a Vec since they're", " easy to initialize and the performance hit is minimal (we expect no more than four", " invulnerables) and restricted to testnets."}}, StorageFunctionMetadataV13{Name: "Bonded", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "T::AccountId", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Map from all locked \"stash\" accounts to the controller account."}}, StorageFunctionMetadataV13{Name: "Ledger", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::AccountId", Value: "StakingLedger<T::AccountId, BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Map from all (unlocked) \"controller\" accounts to the info regarding the staking."}}, StorageFunctionMetadataV13{Name: "Payee", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "RewardDestination<T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Where the reward payment should be made. Keyed by stash."}}, StorageFunctionMetadataV13{Name: "Validators", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "ValidatorPrefs", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0}, Documentation: []Text{" The map from (wannabe) validator stash key to the preferences of that validator."}}, StorageFunctionMetadataV13{Name: "Nominators", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "Nominations<T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The map from nominator stash key to the set of stash keys of all validators to nominate."}}, StorageFunctionMetadataV13{Name: "CurrentEra", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "EraIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current era index.", "", " This is the latest planned era, depending on how the Session pallet queues the validator", " set, it might be active or not."}}, StorageFunctionMetadataV13{Name: "ActiveEra", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "ActiveEraInfo", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The active era information, it holds index and start.", "", " The active era is the era being currently rewarded. Validator set of this era must be", " equal to [`SessionInterface::validators`]."}}, StorageFunctionMetadataV13{Name: "ErasStartSessionIndex", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "EraIndex", Value: "SessionIndex", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The session index at which the era start for the last `HISTORY_DEPTH` eras.", "", " Note: This tracks the starting session (i.e. session index when era start being active)", " for the eras in `[CurrentEra - HISTORY_DEPTH, CurrentEra]`."}}, StorageFunctionMetadataV13{Name: "ErasStakers", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "EraIndex", Key2: "T::AccountId", Value: "Exposure<T::AccountId, BalanceOf<T>>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0}, Documentation: []Text{" Exposure of validator at era.", "", " This is keyed first by the era index to allow bulk deletion and then the stash account.", "", " Is it removed after `HISTORY_DEPTH` eras.", " If stakers hasn't been set or has been removed then empty exposure is returned."}}, StorageFunctionMetadataV13{Name: "ErasStakersClipped", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "EraIndex", Key2: "T::AccountId", Value: "Exposure<T::AccountId, BalanceOf<T>>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0}, Documentation: []Text{" Clipped Exposure of validator at era.", "", " This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the", " `T::MaxNominatorRewardedPerValidator` biggest stakers.", " (Note: the field `total` and `own` of the exposure remains unchanged).", " This is used to limit the i/o cost for the nominator payout.", "", " This is keyed fist by the era index to allow bulk deletion and then the stash account.", "", " Is it removed after `HISTORY_DEPTH` eras.", " If stakers hasn't been set or has been removed then empty exposure is returned."}}, StorageFunctionMetadataV13{Name: "ErasValidatorPrefs", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "EraIndex", Key2: "T::AccountId", Value: "ValidatorPrefs", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0}, Documentation: []Text{" Similar to `ErasStakers`, this holds the preferences of validators.", "", " This is keyed first by the era index to allow bulk deletion and then the stash account.", "", " Is it removed after `HISTORY_DEPTH` eras."}}, StorageFunctionMetadataV13{Name: "ErasValidatorReward", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "EraIndex", Value: "BalanceOf<T>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The total validator era payout for the last `HISTORY_DEPTH` eras.", "", " Eras that haven't finished yet or has been removed doesn't have reward."}}, StorageFunctionMetadataV13{Name: "ErasRewardPoints", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "EraIndex", Value: "EraRewardPoints<T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Rewards for the last `HISTORY_DEPTH` eras.", " If reward hasn't been set or has been removed then 0 reward is returned."}}, StorageFunctionMetadataV13{Name: "ErasTotalStake", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "EraIndex", Value: "BalanceOf<T>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The total amount staked for the last `HISTORY_DEPTH` eras.", " If total hasn't been set or has been removed then 0 stake is returned."}}, StorageFunctionMetadataV13{Name: "ForceEra", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Forcing", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Mode of era forcing."}}, StorageFunctionMetadataV13{Name: "SlashRewardFraction", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Perbill", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The percentage of the slash that is distributed to reporters.", "", " The rest of the slashed value is handled by the `Slash`."}}, StorageFunctionMetadataV13{Name: "CanceledSlashPayout", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "BalanceOf<T>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of currency given to reporters of a slash event which was", " canceled by extraordinary circumstances (e.g. governance)."}}, StorageFunctionMetadataV13{Name: "UnappliedSlashes", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "EraIndex", Value: "Vec<UnappliedSlash<T::AccountId, BalanceOf<T>>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" All unapplied slashes that are queued for later."}}, StorageFunctionMetadataV13{Name: "BondedEras", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<(EraIndex, SessionIndex)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping from still-bonded eras to the first session index of that era.", "", " Must contains information for eras for the range:", " `[active_era - bounding_duration; active_era]`"}}, StorageFunctionMetadataV13{Name: "ValidatorSlashInEra", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "EraIndex", Key2: "T::AccountId", Value: "(Perbill, BalanceOf<T>)", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" All slashing events on validators, mapped by era to the highest slash proportion", " and slash value of the era."}}, StorageFunctionMetadataV13{Name: "NominatorSlashInEra", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "EraIndex", Key2: "T::AccountId", Value: "BalanceOf<T>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" All slashing events on nominators, mapped by era to the highest slash value of the era."}}, StorageFunctionMetadataV13{Name: "SlashingSpans", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "slashing::SlashingSpans", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Slashing spans for stash accounts."}}, StorageFunctionMetadataV13{Name: "SpanSlash", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "(T::AccountId, slashing::SpanIndex)", Value: "slashing::SpanRecord<BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Records information about the maximum slash of a stash within a slashing span,", " as well as how much reward has been paid out."}}, StorageFunctionMetadataV13{Name: "EarliestUnappliedSlash", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "EraIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The earliest era for which we have a pending, unapplied slash."}}, StorageFunctionMetadataV13{Name: "CurrentPlannedSession", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "SessionIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The last planned session scheduled by the session pallet.", "", " This is basically in sync with the call to [`SessionManager::new_session`]."}}, StorageFunctionMetadataV13{Name: "StorageVersion", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Releases", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x5}, Documentation: []Text{" True if network has been upgraded to this version.", " Storage version of the pallet.", "", " This is set to v6.0.0 for new networks."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "bond", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "controller", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}, FunctionArgumentMetadata{Name: "payee", Type: "RewardDestination<T::AccountId>"}}, Documentation: []Text{" Take the origin account as a stash and lock up `value` of its balance. `controller` will", " be the account that controls it.", "", " `value` must be more than the `minimum_balance` specified by `T::Currency`.", "", " The dispatch origin for this call must be _Signed_ by the stash account.", "", " Emits `Bonded`.", "", " # <weight>", " - Independent of the arguments. Moderate complexity.", " - O(1).", " - Three extra DB entries.", "", " NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned", " unless the `origin` falls below _existential deposit_ and gets removed as dust.", " ------------------", " Weight: O(1)", " DB Weight:", " - Read: Bonded, Ledger, [Origin Account], Current Era, History Depth, Locks", " - Write: Bonded, Payee, [Origin Account], Locks, Ledger", " # </weight>"}}, FunctionMetadataV4{Name: "bond_extra", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "max_additional", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Add some extra amount that have appeared in the stash `free_balance` into the balance up", " for staking.", "", " Use this if there are additional funds in your stash account that you wish to bond.", " Unlike [`bond`] or [`unbond`] this function does not impose any limitation on the amount", " that can be added.", "", " The dispatch origin for this call must be _Signed_ by the stash, not the controller and", " it can be only called when [`EraElectionStatus`] is `Closed`.", "", " Emits `Bonded`.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - O(1).", " - One DB entry.", " ------------", " DB Weight:", " - Read: Era Election Status, Bonded, Ledger, [Origin Account], Locks", " - Write: [Origin Account], Locks, Ledger", " # </weight>"}}, FunctionMetadataV4{Name: "unbond", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Schedule a portion of the stash to be unlocked ready for transfer out after the bond", " period ends. If this leaves an amount actively bonded less than", " T::Currency::minimum_balance(), then it is increased to the full amount.", "", " Once the unlock period is done, you can call `withdraw_unbonded` to actually move", " the funds out of management ready for transfer.", "", " No more than a limited number of unlocking chunks (see `MAX_UNLOCKING_CHUNKS`)", " can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need", " to be called first to remove some of the chunks (if possible).", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", " And, it can be only called when [`EraElectionStatus`] is `Closed`.", "", " Emits `Unbonded`.", "", " See also [`Call::withdraw_unbonded`].", "", " # <weight>", " - Independent of the arguments. Limited but potentially exploitable complexity.", " - Contains a limited number of reads.", " - Each call (requires the remainder of the bonded balance to be above `minimum_balance`)", "   will cause a new entry to be inserted into a vector (`Ledger.unlocking`) kept in storage.", "   The only way to clean the aforementioned storage item is also user-controlled via", "   `withdraw_unbonded`.", " - One DB entry.", " ----------", " Weight: O(1)", " DB Weight:", " - Read: EraElectionStatus, Ledger, CurrentEra, Locks, BalanceOf Stash,", " - Write: Locks, Ledger, BalanceOf Stash,", " </weight>"}}, FunctionMetadataV4{Name: "withdraw_unbonded", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "num_slashing_spans", Type: "u32"}}, Documentation: []Text{" Remove any unlocked chunks from the `unlocking` queue from our management.", "", " This essentially frees up that balance to be used by the stash account to do", " whatever it wants.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", " And, it can be only called when [`EraElectionStatus`] is `Closed`.", "", " Emits `Withdrawn`.", "", " See also [`Call::unbond`].", "", " # <weight>", " - Could be dependent on the `origin` argument and how much `unlocking` chunks exist.", "  It implies `consolidate_unlocked` which loops over `Ledger.unlocking`, which is", "  indirectly user-controlled. See [`unbond`] for more detail.", " - Contains a limited number of reads, yet the size of which could be large based on `ledger`.", " - Writes are limited to the `origin` account key.", " ---------------", " Complexity O(S) where S is the number of slashing spans to remove", " Update:", " - Reads: EraElectionStatus, Ledger, Current Era, Locks, [Origin Account]", " - Writes: [Origin Account], Locks, Ledger", " Kill:", " - Reads: EraElectionStatus, Ledger, Current Era, Bonded, Slashing Spans, [Origin", "   Account], Locks, BalanceOf stash", " - Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators,", "   [Origin Account], Locks, BalanceOf stash.", " - Writes Each: SpanSlash * S", " NOTE: Weight annotation is the kill scenario, we refund otherwise.", " # </weight>"}}, FunctionMetadataV4{Name: "validate", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "prefs", Type: "ValidatorPrefs"}}, Documentation: []Text{" Declare the desire to validate for the origin controller.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", " And, it can be only called when [`EraElectionStatus`] is `Closed`.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains a limited number of reads.", " - Writes are limited to the `origin` account key.", " -----------", " Weight: O(1)", " DB Weight:", " - Read: Era Election Status, Ledger", " - Write: Nominators, Validators", " # </weight>"}}, FunctionMetadataV4{Name: "nominate", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "targets", Type: "Vec<<T::Lookup as StaticLookup>::Source>"}}, Documentation: []Text{" Declare the desire to nominate `targets` for the origin controller.", "", " Effects will be felt at the beginning of the next era. This can only be called when", " [`EraElectionStatus`] is `Closed`.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", " And, it can be only called when [`EraElectionStatus`] is `Closed`.", "", " # <weight>", " - The transaction's complexity is proportional to the size of `targets` (N)", " which is capped at CompactAssignments::LIMIT (MAX_NOMINATIONS).", " - Both the reads and writes follow a similar pattern.", " ---------", " Weight: O(N)", " where N is the number of targets", " DB Weight:", " - Reads: Era Election Status, Ledger, Current Era", " - Writes: Validators, Nominators", " # </weight>"}}, FunctionMetadataV4{Name: "chill", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Declare no desire to either validate or nominate.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", " And, it can be only called when [`EraElectionStatus`] is `Closed`.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains one read.", " - Writes are limited to the `origin` account key.", " --------", " Weight: O(1)", " DB Weight:", " - Read: EraElectionStatus, Ledger", " - Write: Validators, Nominators", " # </weight>"}}, FunctionMetadataV4{Name: "set_payee", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "payee", Type: "RewardDestination<T::AccountId>"}}, Documentation: []Text{" (Re-)set the payment target for a controller.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains a limited number of reads.", " - Writes are limited to the `origin` account key.", " ---------", " - Weight: O(1)", " - DB Weight:", "     - Read: Ledger", "     - Write: Payee", " # </weight>"}}, FunctionMetadataV4{Name: "set_controller", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "controller", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" (Re-)set the controller of a stash.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the stash, not the controller.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains a limited number of reads.", " - Writes are limited to the `origin` account key.", " ----------", " Weight: O(1)", " DB Weight:", " - Read: Bonded, Ledger New Controller, Ledger Old Controller", " - Write: Bonded, Ledger New Controller, Ledger Old Controller", " # </weight>"}}, FunctionMetadataV4{Name: "set_validator_count", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new", Type: "Compact<u32>"}}, Documentation: []Text{" Sets the ideal number of validators.", "", " The dispatch origin must be Root.", "", " # <weight>", " Weight: O(1)", " Write: Validator Count", " # </weight>"}}, FunctionMetadataV4{Name: "increase_validator_count", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "additional", Type: "Compact<u32>"}}, Documentation: []Text{" Increments the ideal number of validators.", "", " The dispatch origin must be Root.", "", " # <weight>", " Same as [`set_validator_count`].", " # </weight>"}}, FunctionMetadataV4{Name: "scale_validator_count", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "factor", Type: "Percent"}}, Documentation: []Text{" Scale up the ideal number of validators by a factor.", "", " The dispatch origin must be Root.", "", " # <weight>", " Same as [`set_validator_count`].", " # </weight>"}}, FunctionMetadataV4{Name: "force_no_eras", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Force there to be no new eras indefinitely.", "", " The dispatch origin must be Root.", "", " # <weight>", " - No arguments.", " - Weight: O(1)", " - Write: ForceEra", " # </weight>"}}, FunctionMetadataV4{Name: "force_new_era", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Force there to be a new era at the end of the next session. After this, it will be", " reset to normal (non-forced) behaviour.", "", " The dispatch origin must be Root.", "", " # <weight>", " - No arguments.", " - Weight: O(1)", " - Write ForceEra", " # </weight>"}}, FunctionMetadataV4{Name: "set_invulnerables", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "invulnerables", Type: "Vec<T::AccountId>"}}, Documentation: []Text{" Set the validators who cannot be slashed (if any).", "", " The dispatch origin must be Root.", "", " # <weight>", " - O(V)", " - Write: Invulnerables", " # </weight>"}}, FunctionMetadataV4{Name: "force_unstake", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "stash", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "num_slashing_spans", Type: "u32"}}, Documentation: []Text{" Force a current staker to become completely unstaked, immediately.", "", " The dispatch origin must be Root.", "", " # <weight>", " O(S) where S is the number of slashing spans to be removed", " Reads: Bonded, Slashing Spans, Account, Locks", " Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Account, Locks", " Writes Each: SpanSlash * S", " # </weight>"}}, FunctionMetadataV4{Name: "force_new_era_always", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Force there to be a new era at the end of sessions indefinitely.", "", " The dispatch origin must be Root.", "", " # <weight>", " - Weight: O(1)", " - Write: ForceEra", " # </weight>"}}, FunctionMetadataV4{Name: "cancel_deferred_slash", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "era", Type: "EraIndex"}, FunctionArgumentMetadata{Name: "slash_indices", Type: "Vec<u32>"}}, Documentation: []Text{" Cancel enactment of a deferred slash.", "", " Can be called by the `T::SlashCancelOrigin`.", "", " Parameters: era and indices of the slashes for that era to kill.", "", " # <weight>", " Complexity: O(U + S)", " with U unapplied slashes weighted with U=1000", " and S is the number of slash indices to be canceled.", " - Read: Unapplied Slashes", " - Write: Unapplied Slashes", " # </weight>"}}, FunctionMetadataV4{Name: "payout_stakers", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "validator_stash", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "era", Type: "EraIndex"}}, Documentation: []Text{" Pay out all the stakers behind a single validator for a single era.", "", " - `validator_stash` is the stash account of the validator. Their nominators, up to", "   `T::MaxNominatorRewardedPerValidator`, will also receive their rewards.", " - `era` may be any era between `[current_era - history_depth; current_era]`.", "", " The origin of this call must be _Signed_. Any account can call this function, even if", " it is not one of the stakers.", "", " This can only be called when [`EraElectionStatus`] is `Closed`.", "", " # <weight>", " - Time complexity: at most O(MaxNominatorRewardedPerValidator).", " - Contains a limited number of reads and writes.", " -----------", " N is the Number of payouts for the validator (including the validator)", " Weight:", " - Reward Destination Staked: O(N)", " - Reward Destination Controller (Creating): O(N)", " DB Weight:", " - Read: EraElectionStatus, CurrentEra, HistoryDepth, ErasValidatorReward,", "         ErasStakersClipped, ErasRewardPoints, ErasValidatorPrefs (8 items)", " - Read Each: Bonded, Ledger, Payee, Locks, System Account (5 items)", " - Write Each: System Account, Locks, Ledger (3 items)", "", "   NOTE: weights are assuming that payouts are made to alive stash account (Staked).", "   Paying even a dead controller is cheaper weight-wise. We don't do any refunds here.", " # </weight>"}}, FunctionMetadataV4{Name: "rebond", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Rebond a portion of the stash scheduled to be unlocked.", "", " The dispatch origin must be signed by the controller, and it can be only called when", " [`EraElectionStatus`] is `Closed`.", "", " # <weight>", " - Time complexity: O(L), where L is unlocking chunks", " - Bounded by `MAX_UNLOCKING_CHUNKS`.", " - Storage changes: Can't increase storage, only decrease it.", " ---------------", " - DB Weight:", "     - Reads: EraElectionStatus, Ledger, Locks, [Origin Account]", "     - Writes: [Origin Account], Locks, Ledger", " # </weight>"}}, FunctionMetadataV4{Name: "set_history_depth", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new_history_depth", Type: "Compact<EraIndex>"}, FunctionArgumentMetadata{Name: "_era_items_deleted", Type: "Compact<u32>"}}, Documentation: []Text{" Set `HistoryDepth` value. This function will delete any history information", " when `HistoryDepth` is reduced.", "", " Parameters:", " - `new_history_depth`: The new history depth you would like to set.", " - `era_items_deleted`: The number of items that will be deleted by this dispatch.", "    This should report all the storage items that will be deleted by clearing old", "    era history. Needed to report an accurate weight for the dispatch. Trusted by", "    `Root` to report an accurate number.", "", " Origin must be root.", "", " # <weight>", " - E: Number of history depths removed, i.e. 10 -> 7 = 3", " - Weight: O(E)", " - DB Weight:", "     - Reads: Current Era, History Depth", "     - Writes: History Depth", "     - Clear Prefix Each: Era Stakers, EraStakersClipped, ErasValidatorPrefs", "     - Writes Each: ErasValidatorReward, ErasRewardPoints, ErasTotalStake, ErasStartSessionIndex", " # </weight>"}}, FunctionMetadataV4{Name: "reap_stash", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "stash", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "num_slashing_spans", Type: "u32"}}, Documentation: []Text{" Remove all data structure concerning a staker/stash once its balance is at the minimum.", " This is essentially equivalent to `withdraw_unbonded` except it can be called by anyone", " and the target `stash` must have no funds left beyond the ED.", "", " This can be called from any origin.", "", " - `stash`: The stash account to reap. Its balance must be zero.", "", " # <weight>", " Complexity: O(S) where S is the number of slashing spans on the account.", " DB Weight:", " - Reads: Stash Account, Bonded, Slashing Spans, Locks", " - Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Stash Account, Locks", " - Writes Each: SpanSlash * S", " # </weight>"}}, FunctionMetadataV4{Name: "kick", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "Vec<<T::Lookup as StaticLookup>::Source>"}}, Documentation: []Text{" Remove the given nominations from the calling validator.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", " And, it can be only called when [`EraElectionStatus`] is `Closed`. The controller", " account should represent a validator.", "", " - `who`: A list of nominator stash accounts who are nominating this validator which", "   should no longer be nominating this validator.", "", " Note: Making this call only makes sense if you first set the validator preferences to", " block any further nominations."}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "EraPayout", Args: []Type{"EraIndex", "Balance", "Balance"}, Documentation: []Text{" The era payout has been set; the first balance is the validator-payout; the second is", " the remainder from the maximum amount of reward.", " \\[era_index, validator_payout, remainder\\]"}}, EventMetadataV4{Name: "Reward", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" The staker has been rewarded by this amount. \\[stash, amount\\]"}}, EventMetadataV4{Name: "Slash", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" One validator (and its nominators) has been slashed by the given amount.", " \\[validator, amount\\]"}}, EventMetadataV4{Name: "OldSlashingReportDiscarded", Args: []Type{"SessionIndex"}, Documentation: []Text{" An old slashing report from a prior era was discarded because it could", " not be processed. \\[session_index\\]"}}, EventMetadataV4{Name: "StakingElection", Args: []Type(nil), Documentation: []Text{" A new set of stakers was elected."}}, EventMetadataV4{Name: "Bonded", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" An account has bonded this amount. \\[stash, amount\\]", "", " NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,", " it will not be emitted for staking rewards when they are added to stake."}}, EventMetadataV4{Name: "Unbonded", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" An account has unbonded this amount. \\[stash, amount\\]"}}, EventMetadataV4{Name: "Withdrawn", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`", " from the unlocking queue. \\[stash, amount\\]"}}, EventMetadataV4{Name: "Kicked", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" A nominator has been kicked from a validator. \\[nominator, stash\\]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "SessionsPerEra", Type: "SessionIndex", Value: Bytes{0x6, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of sessions per era."}}, ModuleConstantMetadataV6{Name: "BondingDuration", Type: "EraIndex", Value: Bytes{0xa0, 0x2, 0x0, 0x0}, Documentation: []Text{" Number of eras that staked funds must remain bonded for."}}, ModuleConstantMetadataV6{Name: "SlashDeferDuration", Type: "EraIndex", Value: Bytes{0xa8, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of eras that slashes are deferred by, after computation.", "", " This should be less than the bonding duration.", " Set to 0 if slashes should be applied immediately, without opportunity for", " intervention."}}, ModuleConstantMetadataV6{Name: "MaxNominatorRewardedPerValidator", Type: "u32", Value: Bytes{0x0, 0x1, 0x0, 0x0}, Documentation: []Text{" The maximum number of nominators rewarded for each validator.", "", " For each validator only the `$MaxNominatorRewardedPerValidator` biggest stakers can claim", " their reward. This used to limit the i/o cost for the nominator payout."}}, ModuleConstantMetadataV6{Name: "MaxNominations", Type: "u32", Value: Bytes{0x10, 0x0, 0x0, 0x0}, Documentation: []Text{" Maximum number of nominations per nominator."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "NotController", Documentation: []Text{" Not a controller account."}}, ErrorMetadataV8{Name: "NotStash", Documentation: []Text{" Not a stash account."}}, ErrorMetadataV8{Name: "AlreadyBonded", Documentation: []Text{" Stash is already bonded."}}, ErrorMetadataV8{Name: "AlreadyPaired", Documentation: []Text{" Controller is already paired."}}, ErrorMetadataV8{Name: "EmptyTargets", Documentation: []Text{" Targets cannot be empty."}}, ErrorMetadataV8{Name: "DuplicateIndex", Documentation: []Text{" Duplicate index."}}, ErrorMetadataV8{Name: "InvalidSlashIndex", Documentation: []Text{" Slash record index out of bounds."}}, ErrorMetadataV8{Name: "InsufficientValue", Documentation: []Text{" Can not bond with value less than minimum balance."}}, ErrorMetadataV8{Name: "NoMoreChunks", Documentation: []Text{" Can not schedule more unlock chunks."}}, ErrorMetadataV8{Name: "NoUnlockChunk", Documentation: []Text{" Can not rebond without unlocking chunks."}}, ErrorMetadataV8{Name: "FundedTarget", Documentation: []Text{" Attempting to target a stash that still has funds."}}, ErrorMetadataV8{Name: "InvalidEraToReward", Documentation: []Text{" Invalid era to reward."}}, ErrorMetadataV8{Name: "InvalidNumberOfNominations", Documentation: []Text{" Invalid number of nominations."}}, ErrorMetadataV8{Name: "NotSortedAndUnique", Documentation: []Text{" Items are not sorted and unique."}}, ErrorMetadataV8{Name: "AlreadyClaimed", Documentation: []Text{" Rewards for this era have already been claimed for this validator."}}, ErrorMetadataV8{Name: "IncorrectHistoryDepth", Documentation: []Text{" Incorrect previous history depth input provided."}}, ErrorMetadataV8{Name: "IncorrectSlashingSpans", Documentation: []Text{" Incorrect number of slashing spans provided."}}, ErrorMetadataV8{Name: "BadState", Documentation: []Text{" Internal state has become somehow corrupted and the operation cannot continue."}}, ErrorMetadataV8{Name: "TooManyTargets", Documentation: []Text{" Too many nomination targets supplied."}}, ErrorMetadataV8{Name: "BadTarget", Documentation: []Text{" A nomination target was supplied that was blocked or otherwise not a validator."}}}, Index: 0x9}, ModuleMetadataV13{Name: "Session", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Session", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Validators", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<T::ValidatorId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current set of validators."}}, StorageFunctionMetadataV13{Name: "CurrentIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "SessionIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current index of the session."}}, StorageFunctionMetadataV13{Name: "QueuedChanged", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" True if the underlying economic identities or weighting behind the validators", " has changed in the queued validator set."}}, StorageFunctionMetadataV13{Name: "QueuedKeys", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<(T::ValidatorId, T::Keys)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The queued keys for the next session. When the next session begins, these keys", " will be used to determine the validator's session keys."}}, StorageFunctionMetadataV13{Name: "DisabledValidators", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<u32>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Indices of disabled validators.", "", " The set is cleared when `on_session_ending` returns a new set of identities."}}, StorageFunctionMetadataV13{Name: "NextKeys", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::ValidatorId", Value: "T::Keys", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The next session keys for a validator."}}, StorageFunctionMetadataV13{Name: "KeyOwner", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "(KeyTypeId, Vec<u8>)", Value: "T::ValidatorId", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The owner of a key. The key is the `KeyTypeId` + the encoded key."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "set_keys", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "keys", Type: "T::Keys"}, FunctionArgumentMetadata{Name: "proof", Type: "Vec<u8>"}}, Documentation: []Text{" Sets the session key(s) of the function caller to `keys`.", " Allows an account to set its session key prior to becoming a validator.", " This doesn't take effect until the next session.", "", " The dispatch origin of this function must be signed.", "", " # <weight>", " - Complexity: `O(1)`", "   Actual cost depends on the number of length of `T::Keys::key_ids()` which is fixed.", " - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`", " - DbWrites: `origin account`, `NextKeys`", " - DbReads per key id: `KeyOwner`", " - DbWrites per key id: `KeyOwner`", " # </weight>"}}, FunctionMetadataV4{Name: "purge_keys", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Removes any session key(s) of the function caller.", " This doesn't take effect until the next session.", "", " The dispatch origin of this function must be signed.", "", " # <weight>", " - Complexity: `O(1)` in number of key ", "   Actual cost depends on the number of length of `T::Keys::key_ids()` which is fixed.", " - DbReads: `T::ValidatorIdOf`, `NextKeys`, `origin account`", " - DbWrites: `NextKeys`, `origin account`", " - DbWrites per key id: `KeyOwnder`", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "NewSession", Args: []Type{"SessionIndex"}, Documentation: []Text{" New session has happened. Note that the argument is the \\[session_index\\], not the block", " number as the type might suggest."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InvalidProof", Documentation: []Text{" Invalid ownership proof."}}, ErrorMetadataV8{Name: "NoAssociatedValidatorId", Documentation: []Text{" No associated validator ID for account."}}, ErrorMetadataV8{Name: "DuplicatedKey", Documentation: []Text{" Registered duplicate key."}}, ErrorMetadataV8{Name: "NoKeys", Documentation: []Text{" No keys are associated with this account."}}, ErrorMetadataV8{Name: "NoAccount", Documentation: []Text{" Key setting account is not live, so it's impossible to associate keys."}}}, Index: 0xa}, ModuleMetadataV13{Name: "Democracy", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Democracy", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "PublicPropCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "PropIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of (public) proposals that have been made so far."}}, StorageFunctionMetadataV13{Name: "PublicProps", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<(PropIndex, T::Hash, T::AccountId)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The public proposals. Unsorted. The second item is the proposal's hash."}}, StorageFunctionMetadataV13{Name: "DepositOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "PropIndex", Value: "(Vec<T::AccountId>, BalanceOf<T>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Those who have locked a deposit.", "", " TWOX-NOTE: Safe, as increasing integer keys are safe."}}, StorageFunctionMetadataV13{Name: "Preimages", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "T::Hash", Value: "PreimageStatus<T::AccountId, BalanceOf<T>, T::BlockNumber>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Map of hashes to the proposal preimage, along with who registered it and their deposit.", " The block number is the block at which it was deposited."}}, StorageFunctionMetadataV13{Name: "ReferendumCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "ReferendumIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The next free referendum index, aka the number of referenda started so far."}}, StorageFunctionMetadataV13{Name: "LowestUnbaked", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "ReferendumIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The lowest referendum index representing an unbaked referendum. Equal to", " `ReferendumCount` if there isn't a unbaked referendum."}}, StorageFunctionMetadataV13{Name: "ReferendumInfoOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "ReferendumIndex", Value: "ReferendumInfo<T::BlockNumber, T::Hash, BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Information concerning any given referendum.", "", " TWOX-NOTE: SAFE as indexes are not under an attacker’s control."}}, StorageFunctionMetadataV13{Name: "VotingOf", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "Voting<BalanceOf<T>, T::AccountId, T::BlockNumber>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" All votes for a particular voter. We store the balance for the number of votes that we", " have recorded. The second item is the total amount of delegations, that will be added.", "", " TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway."}}, StorageFunctionMetadataV13{Name: "Locks", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "T::BlockNumber", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Accounts for which there are locks in action which may be removed at some point in the", " future. The value is the block number at which the lock expires and may be removed.", "", " TWOX-NOTE: OK ― `AccountId` is a secure hash."}}, StorageFunctionMetadataV13{Name: "LastTabledWasExternal", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" True if the last referendum tabled was submitted externally. False if it was a public", " proposal."}}, StorageFunctionMetadataV13{Name: "NextExternal", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "(T::Hash, VoteThreshold)", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The referendum to be tabled whenever it would be valid to table an external proposal.", " This happens when a referendum needs to be tabled and one of two conditions are met:", " - `LastTabledWasExternal` is `false`; or", " - `PublicProps` is empty."}}, StorageFunctionMetadataV13{Name: "Blacklist", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "T::Hash", Value: "(T::BlockNumber, Vec<T::AccountId>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" A record of who vetoed what. Maps proposal hash to a possible existent block number", " (until when it may not be resubmitted) and who vetoed it."}}, StorageFunctionMetadataV13{Name: "Cancellations", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "T::Hash", Value: "bool", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Record of all proposals that have been subject to emergency cancellation."}}, StorageFunctionMetadataV13{Name: "StorageVersion", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Releases", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Storage version of the pallet.", "", " New networks start with last version."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "propose", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Propose a sensitive action to be taken.", "", " The dispatch origin of this call must be _Signed_ and the sender must", " have funds to cover the deposit.", "", " - `proposal_hash`: The hash of the proposal preimage.", " - `value`: The amount of deposit (must be at least `MinimumDeposit`).", "", " Emits `Proposed`.", "", " Weight: `O(p)`"}}, FunctionMetadataV4{Name: "second", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal", Type: "Compact<PropIndex>"}, FunctionArgumentMetadata{Name: "seconds_upper_bound", Type: "Compact<u32>"}}, Documentation: []Text{" Signals agreement with a particular proposal.", "", " The dispatch origin of this call must be _Signed_ and the sender", " must have funds to cover the deposit, equal to the original deposit.", "", " - `proposal`: The index of the proposal to second.", " - `seconds_upper_bound`: an upper bound on the current number of seconds on this", "   proposal. Extrinsic is weighted according to this value with no refund.", "", " Weight: `O(S)` where S is the number of seconds a proposal already has."}}, FunctionMetadataV4{Name: "vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "ref_index", Type: "Compact<ReferendumIndex>"}, FunctionArgumentMetadata{Name: "vote", Type: "AccountVote<BalanceOf<T>>"}}, Documentation: []Text{" Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;", " otherwise it is a vote to keep the status quo.", "", " The dispatch origin of this call must be _Signed_.", "", " - `ref_index`: The index of the referendum to vote for.", " - `vote`: The vote configuration.", "", " Weight: `O(R)` where R is the number of referendums the voter has voted on."}}, FunctionMetadataV4{Name: "emergency_cancel", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "ref_index", Type: "ReferendumIndex"}}, Documentation: []Text{" Schedule an emergency cancellation of a referendum. Cannot happen twice to the same", " referendum.", "", " The dispatch origin of this call must be `CancellationOrigin`.", "", " -`ref_index`: The index of the referendum to cancel.", "", " Weight: `O(1)`."}}, FunctionMetadataV4{Name: "external_propose", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Schedule a referendum to be tabled once it is legal to schedule an external", " referendum.", "", " The dispatch origin of this call must be `ExternalOrigin`.", "", " - `proposal_hash`: The preimage hash of the proposal.", "", " Weight: `O(V)` with V number of vetoers in the blacklist of proposal.", "   Decoding vec of length V. Charged as maximum"}}, FunctionMetadataV4{Name: "external_propose_majority", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Schedule a majority-carries referendum to be tabled next once it is legal to schedule", " an external referendum.", "", " The dispatch of this call must be `ExternalMajorityOrigin`.", "", " - `proposal_hash`: The preimage hash of the proposal.", "", " Unlike `external_propose`, blacklisting has no effect on this and it may replace a", " pre-scheduled `external_propose` call.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "external_propose_default", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Schedule a negative-turnout-bias referendum to be tabled next once it is legal to", " schedule an external referendum.", "", " The dispatch of this call must be `ExternalDefaultOrigin`.", "", " - `proposal_hash`: The preimage hash of the proposal.", "", " Unlike `external_propose`, blacklisting has no effect on this and it may replace a", " pre-scheduled `external_propose` call.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "fast_track", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "voting_period", Type: "T::BlockNumber"}, FunctionArgumentMetadata{Name: "delay", Type: "T::BlockNumber"}}, Documentation: []Text{" Schedule the currently externally-proposed majority-carries referendum to be tabled", " immediately. If there is no externally-proposed referendum currently, or if there is one", " but it is not a majority-carries referendum then it fails.", "", " The dispatch of this call must be `FastTrackOrigin`.", "", " - `proposal_hash`: The hash of the current external proposal.", " - `voting_period`: The period that is allowed for voting on this proposal. Increased to", "   `FastTrackVotingPeriod` if too low.", " - `delay`: The number of block after voting has ended in approval and this should be", "   enacted. This doesn't have a minimum amount.", "", " Emits `Started`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "veto_external", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Veto and blacklist the external proposal hash.", "", " The dispatch origin of this call must be `VetoOrigin`.", "", " - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.", "", " Emits `Vetoed`.", "", " Weight: `O(V + log(V))` where V is number of `existing vetoers`"}}, FunctionMetadataV4{Name: "cancel_referendum", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "ref_index", Type: "Compact<ReferendumIndex>"}}, Documentation: []Text{" Remove a referendum.", "", " The dispatch origin of this call must be _Root_.", "", " - `ref_index`: The index of the referendum to cancel.", "", " # Weight: `O(1)`."}}, FunctionMetadataV4{Name: "cancel_queued", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "which", Type: "ReferendumIndex"}}, Documentation: []Text{" Cancel a proposal queued for enactment.", "", " The dispatch origin of this call must be _Root_.", "", " - `which`: The index of the referendum to cancel.", "", " Weight: `O(D)` where `D` is the items in the dispatch queue. Weighted as `D = 10`."}}, FunctionMetadataV4{Name: "delegate", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "to", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "conviction", Type: "Conviction"}, FunctionArgumentMetadata{Name: "balance", Type: "BalanceOf<T>"}}, Documentation: []Text{" Delegate the voting power (with some given conviction) of the sending account.", "", " The balance delegated is locked for as long as it's delegated, and thereafter for the", " time appropriate for the conviction's lock period.", "", " The dispatch origin of this call must be _Signed_, and the signing account must either:", "   - be delegating already; or", "   - have no voting activity (if there is, then it will need to be removed/consolidated", "     through `reap_vote` or `unvote`).", "", " - `to`: The account whose voting the `target` account's voting power will follow.", " - `conviction`: The conviction that will be attached to the delegated votes. When the", "   account is undelegated, the funds will be locked for the corresponding period.", " - `balance`: The amount of the account's balance to be used in delegating. This must", "   not be more than the account's current balance.", "", " Emits `Delegated`.", "", " Weight: `O(R)` where R is the number of referendums the voter delegating to has", "   voted on. Weight is charged as if maximum votes."}}, FunctionMetadataV4{Name: "undelegate", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Undelegate the voting power of the sending account.", "", " Tokens may be unlocked following once an amount of time consistent with the lock period", " of the conviction with which the delegation was issued.", "", " The dispatch origin of this call must be _Signed_ and the signing account must be", " currently delegating.", "", " Emits `Undelegated`.", "", " Weight: `O(R)` where R is the number of referendums the voter delegating to has", "   voted on. Weight is charged as if maximum votes."}}, FunctionMetadataV4{Name: "clear_public_proposals", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Clears all public proposals.", "", " The dispatch origin of this call must be _Root_.", "", " Weight: `O(1)`."}}, FunctionMetadataV4{Name: "note_preimage", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "encoded_proposal", Type: "Vec<u8>"}}, Documentation: []Text{" Register the preimage for an upcoming proposal. This doesn't require the proposal to be", " in the dispatch queue but does require a deposit, returned once enacted.", "", " The dispatch origin of this call must be _Signed_.", "", " - `encoded_proposal`: The preimage of a proposal.", "", " Emits `PreimageNoted`.", "", " Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit)."}}, FunctionMetadataV4{Name: "note_preimage_operational", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "encoded_proposal", Type: "Vec<u8>"}}, Documentation: []Text{" Same as `note_preimage` but origin is `OperationalPreimageOrigin`."}}, FunctionMetadataV4{Name: "note_imminent_preimage", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "encoded_proposal", Type: "Vec<u8>"}}, Documentation: []Text{" Register the preimage for an upcoming proposal. This requires the proposal to be", " in the dispatch queue. No deposit is needed. When this call is successful, i.e.", " the preimage has not been uploaded before and matches some imminent proposal,", " no fee is paid.", "", " The dispatch origin of this call must be _Signed_.", "", " - `encoded_proposal`: The preimage of a proposal.", "", " Emits `PreimageNoted`.", "", " Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit)."}}, FunctionMetadataV4{Name: "note_imminent_preimage_operational", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "encoded_proposal", Type: "Vec<u8>"}}, Documentation: []Text{" Same as `note_imminent_preimage` but origin is `OperationalPreimageOrigin`."}}, FunctionMetadataV4{Name: "reap_preimage", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "proposal_len_upper_bound", Type: "Compact<u32>"}}, Documentation: []Text{" Remove an expired proposal preimage and collect the deposit.", "", " The dispatch origin of this call must be _Signed_.", "", " - `proposal_hash`: The preimage hash of a proposal.", " - `proposal_length_upper_bound`: an upper bound on length of the proposal.", "   Extrinsic is weighted according to this value with no refund.", "", " This will only work after `VotingPeriod` blocks from the time that the preimage was", " noted, if it's the same account doing it. If it's a different account, then it'll only", " work an additional `EnactmentPeriod` later.", "", " Emits `PreimageReaped`.", "", " Weight: `O(D)` where D is length of proposal."}}, FunctionMetadataV4{Name: "unlock", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "target", Type: "T::AccountId"}}, Documentation: []Text{" Unlock tokens that have an expired lock.", "", " The dispatch origin of this call must be _Signed_.", "", " - `target`: The account to remove the lock on.", "", " Weight: `O(R)` with R number of vote of target."}}, FunctionMetadataV4{Name: "remove_vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "ReferendumIndex"}}, Documentation: []Text{" Remove a vote for a referendum.", "", " If:", " - the referendum was cancelled, or", " - the referendum is ongoing, or", " - the referendum has ended such that", "   - the vote of the account was in opposition to the result; or", "   - there was no conviction to the account's vote; or", "   - the account made a split vote", " ...then the vote is removed cleanly and a following call to `unlock` may result in more", " funds being available.", "", " If, however, the referendum has ended and:", " - it finished corresponding to the vote of the account, and", " - the account made a standard vote with conviction, and", " - the lock period of the conviction is not over", " ...then the lock will be aggregated into the overall account's lock, which may involve", " *overlocking* (where the two locks are combined into a single lock that is the maximum", " of both the amount locked and the time is it locked for).", "", " The dispatch origin of this call must be _Signed_, and the signer must have a vote", " registered for referendum `index`.", "", " - `index`: The index of referendum of the vote to be removed.", "", " Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.", "   Weight is calculated for the maximum number of vote."}}, FunctionMetadataV4{Name: "remove_other_vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "target", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "index", Type: "ReferendumIndex"}}, Documentation: []Text{" Remove a vote for a referendum.", "", " If the `target` is equal to the signer, then this function is exactly equivalent to", " `remove_vote`. If not equal to the signer, then the vote must have expired,", " either because the referendum was cancelled, because the voter lost the referendum or", " because the conviction period is over.", "", " The dispatch origin of this call must be _Signed_.", "", " - `target`: The account of the vote to be removed; this account must have voted for", "   referendum `index`.", " - `index`: The index of referendum of the vote to be removed.", "", " Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.", "   Weight is calculated for the maximum number of vote."}}, FunctionMetadataV4{Name: "enact_proposal", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "index", Type: "ReferendumIndex"}}, Documentation: []Text{" Enact a proposal from a referendum. For now we just make the weight be the maximum."}}, FunctionMetadataV4{Name: "blacklist", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "maybe_ref_index", Type: "Option<ReferendumIndex>"}}, Documentation: []Text{" Permanently place a proposal into the blacklist. This prevents it from ever being", " proposed again.", "", " If called on a queued public or external proposal, then this will result in it being", " removed. If the `ref_index` supplied is an active referendum with the proposal hash,", " then it will be cancelled.", "", " The dispatch origin of this call must be `BlacklistOrigin`.", "", " - `proposal_hash`: The proposal hash to blacklist permanently.", " - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be", " cancelled.", "", " Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a", "   reasonable value)."}}, FunctionMetadataV4{Name: "cancel_proposal", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "prop_index", Type: "Compact<PropIndex>"}}, Documentation: []Text{" Remove a proposal.", "", " The dispatch origin of this call must be `CancelProposalOrigin`.", "", " - `prop_index`: The index of the proposal to cancel.", "", " Weight: `O(p)` where `p = PublicProps::<T>::decode_len()`"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Proposed", Args: []Type{"PropIndex", "Balance"}, Documentation: []Text{" A motion has been proposed by a public account. \\[proposal_index, deposit\\]"}}, EventMetadataV4{Name: "Tabled", Args: []Type{"PropIndex", "Balance", "Vec<AccountId>"}, Documentation: []Text{" A public proposal has been tabled for referendum vote. \\[proposal_index, deposit, depositors\\]"}}, EventMetadataV4{Name: "ExternalTabled", Args: []Type(nil), Documentation: []Text{" An external proposal has been tabled."}}, EventMetadataV4{Name: "Started", Args: []Type{"ReferendumIndex", "VoteThreshold"}, Documentation: []Text{" A referendum has begun. \\[ref_index, threshold\\]"}}, EventMetadataV4{Name: "Passed", Args: []Type{"ReferendumIndex"}, Documentation: []Text{" A proposal has been approved by referendum. \\[ref_index\\]"}}, EventMetadataV4{Name: "NotPassed", Args: []Type{"ReferendumIndex"}, Documentation: []Text{" A proposal has been rejected by referendum. \\[ref_index\\]"}}, EventMetadataV4{Name: "Cancelled", Args: []Type{"ReferendumIndex"}, Documentation: []Text{" A referendum has been cancelled. \\[ref_index\\]"}}, EventMetadataV4{Name: "Executed", Args: []Type{"ReferendumIndex", "bool"}, Documentation: []Text{" A proposal has been enacted. \\[ref_index, is_ok\\]"}}, EventMetadataV4{Name: "Delegated", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" An account has delegated their vote to another account. \\[who, target\\]"}}, EventMetadataV4{Name: "Undelegated", Args: []Type{"AccountId"}, Documentation: []Text{" An \\[account\\] has cancelled a previous delegation operation."}}, EventMetadataV4{Name: "Vetoed", Args: []Type{"AccountId", "Hash", "BlockNumber"}, Documentation: []Text{" An external proposal has been vetoed. \\[who, proposal_hash, until\\]"}}, EventMetadataV4{Name: "PreimageNoted", Args: []Type{"Hash", "AccountId", "Balance"}, Documentation: []Text{" A proposal's preimage was noted, and the deposit taken. \\[proposal_hash, who, deposit\\]"}}, EventMetadataV4{Name: "PreimageUsed", Args: []Type{"Hash", "AccountId", "Balance"}, Documentation: []Text{" A proposal preimage was removed and used (the deposit was returned).", " \\[proposal_hash, provider, deposit\\]"}}, EventMetadataV4{Name: "PreimageInvalid", Args: []Type{"Hash", "ReferendumIndex"}, Documentation: []Text{" A proposal could not be executed because its preimage was invalid.", " \\[proposal_hash, ref_index\\]"}}, EventMetadataV4{Name: "PreimageMissing", Args: []Type{"Hash", "ReferendumIndex"}, Documentation: []Text{" A proposal could not be executed because its preimage was missing.", " \\[proposal_hash, ref_index\\]"}}, EventMetadataV4{Name: "PreimageReaped", Args: []Type{"Hash", "AccountId", "Balance", "AccountId"}, Documentation: []Text{" A registered preimage was removed and the deposit collected by the reaper.", " \\[proposal_hash, provider, deposit, reaper\\]"}}, EventMetadataV4{Name: "Unlocked", Args: []Type{"AccountId"}, Documentation: []Text{" An \\[account\\] has been unlocked successfully."}}, EventMetadataV4{Name: "Blacklisted", Args: []Type{"Hash"}, Documentation: []Text{" A proposal \\[hash\\] has been blacklisted permanently."}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "EnactmentPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x2f, 0xd, 0x0}, Documentation: []Text{" The minimum period of locking and the period between a proposal being approved and enacted.", "", " It should generally be a little more than the unstake period to ensure that", " voting stakers have an opportunity to remove themselves from the system in the case where", " they are on the losing side of a vote."}}, ModuleConstantMetadataV6{Name: "LaunchPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x4e, 0xc, 0x0}, Documentation: []Text{" How often (in blocks) new public referenda are launched."}}, ModuleConstantMetadataV6{Name: "VotingPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x4e, 0xc, 0x0}, Documentation: []Text{" How often (in blocks) to check for new votes."}}, ModuleConstantMetadataV6{Name: "MinimumDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x0, 0xc1, 0x6f, 0xf2, 0x86, 0x23, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount to be used as a deposit for a public referendum proposal."}}, ModuleConstantMetadataV6{Name: "FastTrackVotingPeriod", Type: "T::BlockNumber", Value: Bytes{0x80, 0x51, 0x1, 0x0}, Documentation: []Text{" Minimum voting period allowed for a fast-track referendum."}}, ModuleConstantMetadataV6{Name: "CooloffPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x4e, 0xc, 0x0}, Documentation: []Text{" Period in blocks where an external proposal may not be re-submitted after being vetoed."}}, ModuleConstantMetadataV6{Name: "PreimageByteDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of balance that must be deposited per byte of preimage stored."}}, ModuleConstantMetadataV6{Name: "MaxVotes", Type: "u32", Value: Bytes{0x64, 0x0, 0x0, 0x0}, Documentation: []Text{" The maximum number of votes for an account.", "", " Also used to compute weight, an overly big value can", " lead to extrinsic with very big weight: see `delegate` for instance."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "ValueLow", Documentation: []Text{" Value too low"}}, ErrorMetadataV8{Name: "ProposalMissing", Documentation: []Text{" Proposal does not exist"}}, ErrorMetadataV8{Name: "BadIndex", Documentation: []Text{" Unknown index"}}, ErrorMetadataV8{Name: "AlreadyCanceled", Documentation: []Text{" Cannot cancel the same proposal twice"}}, ErrorMetadataV8{Name: "DuplicateProposal", Documentation: []Text{" Proposal already made"}}, ErrorMetadataV8{Name: "ProposalBlacklisted", Documentation: []Text{" Proposal still blacklisted"}}, ErrorMetadataV8{Name: "NotSimpleMajority", Documentation: []Text{" Next external proposal not simple majority"}}, ErrorMetadataV8{Name: "InvalidHash", Documentation: []Text{" Invalid hash"}}, ErrorMetadataV8{Name: "NoProposal", Documentation: []Text{" No external proposal"}}, ErrorMetadataV8{Name: "AlreadyVetoed", Documentation: []Text{" Identity may not veto a proposal twice"}}, ErrorMetadataV8{Name: "NotDelegated", Documentation: []Text{" Not delegated"}}, ErrorMetadataV8{Name: "DuplicatePreimage", Documentation: []Text{" Preimage already noted"}}, ErrorMetadataV8{Name: "NotImminent", Documentation: []Text{" Not imminent"}}, ErrorMetadataV8{Name: "TooEarly", Documentation: []Text{" Too early"}}, ErrorMetadataV8{Name: "Imminent", Documentation: []Text{" Imminent"}}, ErrorMetadataV8{Name: "PreimageMissing", Documentation: []Text{" Preimage not found"}}, ErrorMetadataV8{Name: "ReferendumInvalid", Documentation: []Text{" Vote given for invalid referendum"}}, ErrorMetadataV8{Name: "PreimageInvalid", Documentation: []Text{" Invalid preimage"}}, ErrorMetadataV8{Name: "NoneWaiting", Documentation: []Text{" No proposals waiting"}}, ErrorMetadataV8{Name: "NotLocked", Documentation: []Text{" The target account does not have a lock."}}, ErrorMetadataV8{Name: "NotExpired", Documentation: []Text{" The lock on the account to be unlocked has not yet expired."}}, ErrorMetadataV8{Name: "NotVoter", Documentation: []Text{" The given account did not vote on the referendum."}}, ErrorMetadataV8{Name: "NoPermission", Documentation: []Text{" The actor has no permission to conduct the action."}}, ErrorMetadataV8{Name: "AlreadyDelegating", Documentation: []Text{" The account is already delegating."}}, ErrorMetadataV8{Name: "InsufficientFunds", Documentation: []Text{" Too high a balance was provided that the account cannot afford."}}, ErrorMetadataV8{Name: "NotDelegating", Documentation: []Text{" The account is not currently delegating."}}, ErrorMetadataV8{Name: "VotesExist", Documentation: []Text{" The account currently has votes attached to it and the operation cannot succeed until", " these are removed, either through `unvote` or `reap_vote`."}}, ErrorMetadataV8{Name: "InstantNotAllowed", Documentation: []Text{" The instant referendum origin is currently disallowed."}}, ErrorMetadataV8{Name: "Nonsense", Documentation: []Text{" Delegation to oneself makes no sense."}}, ErrorMetadataV8{Name: "WrongUpperBound", Documentation: []Text{" Invalid upper bound."}}, ErrorMetadataV8{Name: "MaxVotesReached", Documentation: []Text{" Maximum number of votes reached."}}, ErrorMetadataV8{Name: "InvalidWitness", Documentation: []Text{" The provided witness data is wrong."}}, ErrorMetadataV8{Name: "TooManyProposals", Documentation: []Text{" Maximum number of proposals reached."}}}, Index: 0xb}, ModuleMetadataV13{Name: "Council", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Instance1Collective", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Proposals", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "BoundedVec<T::Hash, T::MaxProposals>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The hashes of the active proposals."}}, StorageFunctionMetadataV13{Name: "ProposalOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "T::Hash", Value: "<T as Config<I>>::Proposal", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Actual proposal for a given hash, if it's current."}}, StorageFunctionMetadataV13{Name: "Voting", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "T::Hash", Value: "Votes<T::AccountId, T::BlockNumber>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Votes on a given proposal, if it is ongoing."}}, StorageFunctionMetadataV13{Name: "ProposalCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Proposals so far."}}, StorageFunctionMetadataV13{Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current members of the collective. This is stored sorted (just by value)."}}, StorageFunctionMetadataV13{Name: "Prime", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The prime member that helps determine the default vote behavior in case of absentations."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "set_members", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new_members", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "prime", Type: "Option<T::AccountId>"}, FunctionArgumentMetadata{Name: "old_count", Type: "MemberCount"}}, Documentation: []Text{" Set the collective's membership.", "", " - `new_members`: The new member list. Be nice to the chain and provide it sorted.", " - `prime`: The prime member whose vote sets the default.", " - `old_count`: The upper bound for the previous number of members in storage.", "                Used for weight estimation.", "", " Requires root origin.", "", " NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but", "       the weight estimations rely on it to estimate dispatchable weight.", "", " # <weight>", " ## Weight", " - `O(MP + N)` where:", "   - `M` old-members-count (code- and governance-bounded)", "   - `N` new-members-count (code- and governance-bounded)", "   - `P` proposals-count (code-bounded)", " - DB:", "   - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members", "   - 1 storage read (codec `O(P)`) for reading the proposals", "   - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal", "   - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one", " # </weight>"}}, FunctionMetadataV4{Name: "execute", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal", Type: "Box<<T as Config<I>>::Proposal>"}, FunctionArgumentMetadata{Name: "length_bound", Type: "Compact<u32>"}}, Documentation: []Text{" Dispatch a proposal from a member using the `Member` origin.", "", " Origin must be a member of the collective.", "", " # <weight>", " ## Weight", " - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`", " - DB: 1 read (codec `O(M)`) + DB access of `proposal`", " - 1 event", " # </weight>"}}, FunctionMetadataV4{Name: "propose", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "threshold", Type: "Compact<MemberCount>"}, FunctionArgumentMetadata{Name: "proposal", Type: "Box<<T as Config<I>>::Proposal>"}, FunctionArgumentMetadata{Name: "length_bound", Type: "Compact<u32>"}}, Documentation: []Text{" Add a new proposal to either be voted on or executed directly.", "", " Requires the sender to be member.", "", " `threshold` determines whether `proposal` is executed directly (`threshold < 2`)", " or put up for voting.", "", " # <weight>", " ## Weight", " - `O(B + M + P1)` or `O(B + M + P2)` where:", "   - `B` is `proposal` size in bytes (length-fee-bounded)", "   - `M` is members-count (code- and governance-bounded)", "   - branching is influenced by `threshold` where:", "     - `P1` is proposal execution complexity (`threshold < 2`)", "     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)", " - DB:", "   - 1 storage read `is_member` (codec `O(M)`)", "   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)", "   - DB accesses influenced by `threshold`:", "     - EITHER storage accesses done by `proposal` (`threshold < 2`)", "     - OR proposal insertion (`threshold <= 2`)", "       - 1 storage mutation `Proposals` (codec `O(P2)`)", "       - 1 storage mutation `ProposalCount` (codec `O(1)`)", "       - 1 storage write `ProposalOf` (codec `O(B)`)", "       - 1 storage write `Voting` (codec `O(M)`)", "   - 1 event", " # </weight>"}}, FunctionMetadataV4{Name: "vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "index", Type: "Compact<ProposalIndex>"}, FunctionArgumentMetadata{Name: "approve", Type: "bool"}}, Documentation: []Text{" Add an aye or nay vote for the sender to the given proposal.", "", " Requires the sender to be a member.", "", " Transaction fees will be waived if the member is voting on any particular proposal", " for the first time and the call is successful. Subsequent vote changes will charge a fee.", " # <weight>", " ## Weight", " - `O(M)` where `M` is members-count (code- and governance-bounded)", " - DB:", "   - 1 storage read `Members` (codec `O(M)`)", "   - 1 storage mutation `Voting` (codec `O(M)`)", " - 1 event", " # </weight>"}}, FunctionMetadataV4{Name: "close", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "index", Type: "Compact<ProposalIndex>"}, FunctionArgumentMetadata{Name: "proposal_weight_bound", Type: "Compact<Weight>"}, FunctionArgumentMetadata{Name: "length_bound", Type: "Compact<u32>"}}, Documentation: []Text{" Close a vote that is either approved, disapproved or whose voting period has ended.", "", " May be called by any signed account in order to finish voting and close the proposal.", "", " If called before the end of the voting period it will only close the vote if it is", " has enough votes to be approved or disapproved.", "", " If called after the end of the voting period abstentions are counted as rejections", " unless there is a prime member set and the prime member cast an approval.", "", " If the close operation completes successfully with disapproval, the transaction fee will", " be waived. Otherwise execution of the approved operation will be charged to the caller.", "", " + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.", " + `length_bound`: The upper bound for the length of the proposal in storage. Checked via", "                   `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.", "", " # <weight>", " ## Weight", " - `O(B + M + P1 + P2)` where:", "   - `B` is `proposal` size in bytes (length-fee-bounded)", "   - `M` is members-count (code- and governance-bounded)", "   - `P1` is the complexity of `proposal` preimage.", "   - `P2` is proposal-count (code-bounded)", " - DB:", "  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)", "  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)", "  - any mutations done while executing `proposal` (`P1`)", " - up to 3 events", " # </weight>"}}, FunctionMetadataV4{Name: "disapprove_proposal", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Disapprove a proposal, close, and remove it from the system, regardless of its current state.", "", " Must be called by the Root origin.", "", " Parameters:", " * `proposal_hash`: The hash of the proposal that should be disapproved.", "", " # <weight>", " Complexity: O(P) where P is the number of max proposals", " DB Weight:", " * Reads: Proposals", " * Writes: Voting, Proposals, ProposalOf", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Proposed", Args: []Type{"AccountId", "ProposalIndex", "Hash", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been proposed (by given account) with a threshold (given", " `MemberCount`).", " \\[account, proposal_index, proposal_hash, threshold\\]"}}, EventMetadataV4{Name: "Voted", Args: []Type{"AccountId", "Hash", "bool", "MemberCount", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been voted on by given account, leaving", " a tally (yes votes and no votes given respectively as `MemberCount`).", " \\[account, proposal_hash, voted, yes, no\\]"}}, EventMetadataV4{Name: "Approved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was approved by the required threshold.", " \\[proposal_hash\\]"}}, EventMetadataV4{Name: "Disapproved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was not approved by the required threshold.", " \\[proposal_hash\\]"}}, EventMetadataV4{Name: "Executed", Args: []Type{"Hash", "DispatchResult"}, Documentation: []Text{" A motion was executed; result will be `Ok` if it returned without error.", " \\[proposal_hash, result\\]"}}, EventMetadataV4{Name: "MemberExecuted", Args: []Type{"Hash", "DispatchResult"}, Documentation: []Text{" A single member did some action; result will be `Ok` if it returned without error.", " \\[proposal_hash, result\\]"}}, EventMetadataV4{Name: "Closed", Args: []Type{"Hash", "MemberCount", "MemberCount"}, Documentation: []Text{" A proposal was closed because its threshold was reached or after its duration was up.", " \\[proposal_hash, yes, no\\]"}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "NotMember", Documentation: []Text{" Account is not a member"}}, ErrorMetadataV8{Name: "DuplicateProposal", Documentation: []Text{" Duplicate proposals not allowed"}}, ErrorMetadataV8{Name: "ProposalMissing", Documentation: []Text{" Proposal must exist"}}, ErrorMetadataV8{Name: "WrongIndex", Documentation: []Text{" Mismatched index"}}, ErrorMetadataV8{Name: "DuplicateVote", Documentation: []Text{" Duplicate vote ignored"}}, ErrorMetadataV8{Name: "AlreadyInitialized", Documentation: []Text{" Members are already initialized!"}}, ErrorMetadataV8{Name: "TooEarly", Documentation: []Text{" The close call was made too early, before the end of the voting."}}, ErrorMetadataV8{Name: "TooManyProposals", Documentation: []Text{" There can only be a maximum of `MaxProposals` active proposals."}}, ErrorMetadataV8{Name: "WrongProposalWeight", Documentation: []Text{" The given weight bound for the proposal was too low."}}, ErrorMetadataV8{Name: "WrongProposalLength", Documentation: []Text{" The given length bound for the proposal was too low."}}}, Index: 0xc}, ModuleMetadataV13{Name: "TechnicalCommittee", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Instance2Collective", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Proposals", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "BoundedVec<T::Hash, T::MaxProposals>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The hashes of the active proposals."}}, StorageFunctionMetadataV13{Name: "ProposalOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "T::Hash", Value: "<T as Config<I>>::Proposal", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Actual proposal for a given hash, if it's current."}}, StorageFunctionMetadataV13{Name: "Voting", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "T::Hash", Value: "Votes<T::AccountId, T::BlockNumber>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Votes on a given proposal, if it is ongoing."}}, StorageFunctionMetadataV13{Name: "ProposalCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Proposals so far."}}, StorageFunctionMetadataV13{Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current members of the collective. This is stored sorted (just by value)."}}, StorageFunctionMetadataV13{Name: "Prime", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The prime member that helps determine the default vote behavior in case of absentations."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "set_members", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new_members", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "prime", Type: "Option<T::AccountId>"}, FunctionArgumentMetadata{Name: "old_count", Type: "MemberCount"}}, Documentation: []Text{" Set the collective's membership.", "", " - `new_members`: The new member list. Be nice to the chain and provide it sorted.", " - `prime`: The prime member whose vote sets the default.", " - `old_count`: The upper bound for the previous number of members in storage.", "                Used for weight estimation.", "", " Requires root origin.", "", " NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but", "       the weight estimations rely on it to estimate dispatchable weight.", "", " # <weight>", " ## Weight", " - `O(MP + N)` where:", "   - `M` old-members-count (code- and governance-bounded)", "   - `N` new-members-count (code- and governance-bounded)", "   - `P` proposals-count (code-bounded)", " - DB:", "   - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members", "   - 1 storage read (codec `O(P)`) for reading the proposals", "   - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal", "   - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one", " # </weight>"}}, FunctionMetadataV4{Name: "execute", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal", Type: "Box<<T as Config<I>>::Proposal>"}, FunctionArgumentMetadata{Name: "length_bound", Type: "Compact<u32>"}}, Documentation: []Text{" Dispatch a proposal from a member using the `Member` origin.", "", " Origin must be a member of the collective.", "", " # <weight>", " ## Weight", " - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`", " - DB: 1 read (codec `O(M)`) + DB access of `proposal`", " - 1 event", " # </weight>"}}, FunctionMetadataV4{Name: "propose", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "threshold", Type: "Compact<MemberCount>"}, FunctionArgumentMetadata{Name: "proposal", Type: "Box<<T as Config<I>>::Proposal>"}, FunctionArgumentMetadata{Name: "length_bound", Type: "Compact<u32>"}}, Documentation: []Text{" Add a new proposal to either be voted on or executed directly.", "", " Requires the sender to be member.", "", " `threshold` determines whether `proposal` is executed directly (`threshold < 2`)", " or put up for voting.", "", " # <weight>", " ## Weight", " - `O(B + M + P1)` or `O(B + M + P2)` where:", "   - `B` is `proposal` size in bytes (length-fee-bounded)", "   - `M` is members-count (code- and governance-bounded)", "   - branching is influenced by `threshold` where:", "     - `P1` is proposal execution complexity (`threshold < 2`)", "     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)", " - DB:", "   - 1 storage read `is_member` (codec `O(M)`)", "   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)", "   - DB accesses influenced by `threshold`:", "     - EITHER storage accesses done by `proposal` (`threshold < 2`)", "     - OR proposal insertion (`threshold <= 2`)", "       - 1 storage mutation `Proposals` (codec `O(P2)`)", "       - 1 storage mutation `ProposalCount` (codec `O(1)`)", "       - 1 storage write `ProposalOf` (codec `O(B)`)", "       - 1 storage write `Voting` (codec `O(M)`)", "   - 1 event", " # </weight>"}}, FunctionMetadataV4{Name: "vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "index", Type: "Compact<ProposalIndex>"}, FunctionArgumentMetadata{Name: "approve", Type: "bool"}}, Documentation: []Text{" Add an aye or nay vote for the sender to the given proposal.", "", " Requires the sender to be a member.", "", " Transaction fees will be waived if the member is voting on any particular proposal", " for the first time and the call is successful. Subsequent vote changes will charge a fee.", " # <weight>", " ## Weight", " - `O(M)` where `M` is members-count (code- and governance-bounded)", " - DB:", "   - 1 storage read `Members` (codec `O(M)`)", "   - 1 storage mutation `Voting` (codec `O(M)`)", " - 1 event", " # </weight>"}}, FunctionMetadataV4{Name: "close", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "index", Type: "Compact<ProposalIndex>"}, FunctionArgumentMetadata{Name: "proposal_weight_bound", Type: "Compact<Weight>"}, FunctionArgumentMetadata{Name: "length_bound", Type: "Compact<u32>"}}, Documentation: []Text{" Close a vote that is either approved, disapproved or whose voting period has ended.", "", " May be called by any signed account in order to finish voting and close the proposal.", "", " If called before the end of the voting period it will only close the vote if it is", " has enough votes to be approved or disapproved.", "", " If called after the end of the voting period abstentions are counted as rejections", " unless there is a prime member set and the prime member cast an approval.", "", " If the close operation completes successfully with disapproval, the transaction fee will", " be waived. Otherwise execution of the approved operation will be charged to the caller.", "", " + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.", " + `length_bound`: The upper bound for the length of the proposal in storage. Checked via", "                   `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.", "", " # <weight>", " ## Weight", " - `O(B + M + P1 + P2)` where:", "   - `B` is `proposal` size in bytes (length-fee-bounded)", "   - `M` is members-count (code- and governance-bounded)", "   - `P1` is the complexity of `proposal` preimage.", "   - `P2` is proposal-count (code-bounded)", " - DB:", "  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)", "  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)", "  - any mutations done while executing `proposal` (`P1`)", " - up to 3 events", " # </weight>"}}, FunctionMetadataV4{Name: "disapprove_proposal", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Disapprove a proposal, close, and remove it from the system, regardless of its current state.", "", " Must be called by the Root origin.", "", " Parameters:", " * `proposal_hash`: The hash of the proposal that should be disapproved.", "", " # <weight>", " Complexity: O(P) where P is the number of max proposals", " DB Weight:", " * Reads: Proposals", " * Writes: Voting, Proposals, ProposalOf", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Proposed", Args: []Type{"AccountId", "ProposalIndex", "Hash", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been proposed (by given account) with a threshold (given", " `MemberCount`).", " \\[account, proposal_index, proposal_hash, threshold\\]"}}, EventMetadataV4{Name: "Voted", Args: []Type{"AccountId", "Hash", "bool", "MemberCount", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been voted on by given account, leaving", " a tally (yes votes and no votes given respectively as `MemberCount`).", " \\[account, proposal_hash, voted, yes, no\\]"}}, EventMetadataV4{Name: "Approved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was approved by the required threshold.", " \\[proposal_hash\\]"}}, EventMetadataV4{Name: "Disapproved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was not approved by the required threshold.", " \\[proposal_hash\\]"}}, EventMetadataV4{Name: "Executed", Args: []Type{"Hash", "DispatchResult"}, Documentation: []Text{" A motion was executed; result will be `Ok` if it returned without error.", " \\[proposal_hash, result\\]"}}, EventMetadataV4{Name: "MemberExecuted", Args: []Type{"Hash", "DispatchResult"}, Documentation: []Text{" A single member did some action; result will be `Ok` if it returned without error.", " \\[proposal_hash, result\\]"}}, EventMetadataV4{Name: "Closed", Args: []Type{"Hash", "MemberCount", "MemberCount"}, Documentation: []Text{" A proposal was closed because its threshold was reached or after its duration was up.", " \\[proposal_hash, yes, no\\]"}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "NotMember", Documentation: []Text{" Account is not a member"}}, ErrorMetadataV8{Name: "DuplicateProposal", Documentation: []Text{" Duplicate proposals not allowed"}}, ErrorMetadataV8{Name: "ProposalMissing", Documentation: []Text{" Proposal must exist"}}, ErrorMetadataV8{Name: "WrongIndex", Documentation: []Text{" Mismatched index"}}, ErrorMetadataV8{Name: "DuplicateVote", Documentation: []Text{" Duplicate vote ignored"}}, ErrorMetadataV8{Name: "AlreadyInitialized", Documentation: []Text{" Members are already initialized!"}}, ErrorMetadataV8{Name: "TooEarly", Documentation: []Text{" The close call was made too early, before the end of the voting."}}, ErrorMetadataV8{Name: "TooManyProposals", Documentation: []Text{" There can only be a maximum of `MaxProposals` active proposals."}}, ErrorMetadataV8{Name: "WrongProposalWeight", Documentation: []Text{" The given weight bound for the proposal was too low."}}, ErrorMetadataV8{Name: "WrongProposalLength", Documentation: []Text{" The given length bound for the proposal was too low."}}}, Index: 0xd}, ModuleMetadataV13{Name: "Elections", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Elections", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<SeatHolder<T::AccountId, BalanceOf<T>>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current elected members.", "", " Invariant: Always sorted based on account id."}}, StorageFunctionMetadataV13{Name: "RunnersUp", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<SeatHolder<T::AccountId, BalanceOf<T>>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current reserved runners-up.", "", " Invariant: Always sorted based on rank (worse to best). Upon removal of a member, the", " last (i.e. _best_) runner-up will be replaced."}}, StorageFunctionMetadataV13{Name: "Candidates", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<(T::AccountId, BalanceOf<T>)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The present candidate list. A current member or runner-up can never enter this vector", " and is always implicitly assumed to be a candidate.", "", " Second element is the deposit.", "", " Invariant: Always sorted based on account id."}}, StorageFunctionMetadataV13{Name: "ElectionRounds", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The total number of vote rounds that have happened, excluding the upcoming one."}}, StorageFunctionMetadataV13{Name: "Voting", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "Voter<T::AccountId, BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Votes and locked stake of a particular voter.", "", " TWOX-NOTE: SAFE as `AccountId` is a crypto hash."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "votes", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Vote for a set of candidates for the upcoming round of election. This can be called to", " set the initial votes, or update already existing votes.", "", " Upon initial voting, `value` units of `who`'s balance is locked and a deposit amount is", " reserved. The deposit is based on the number of votes and can be updated over time.", "", " The `votes` should:", "   - not be empty.", "   - be less than the number of possible candidates. Note that all current members and", "     runners-up are also automatically candidates for the next round.", "", " If `value` is more than `who`'s total balance, then the maximum of the two is used.", "", " The dispatch origin of this call must be signed.", "", " ### Warning", "", " It is the responsibility of the caller to **NOT** place all of their balance into the", " lock and keep some for further operations.", "", " # <weight>", " We assume the maximum weight among all 3 cases: vote_equal, vote_more and vote_less.", " # </weight>"}}, FunctionMetadataV4{Name: "remove_voter", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Remove `origin` as a voter.", "", " This removes the lock and returns the deposit.", "", " The dispatch origin of this call must be signed and be a voter."}}, FunctionMetadataV4{Name: "submit_candidacy", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "candidate_count", Type: "Compact<u32>"}}, Documentation: []Text{" Submit oneself for candidacy. A fixed amount of deposit is recorded.", "", " All candidates are wiped at the end of the term. They either become a member/runner-up,", " or leave the system while their deposit is slashed.", "", " The dispatch origin of this call must be signed.", "", " ### Warning", "", " Even if a candidate ends up being a member, they must call [`Call::renounce_candidacy`]", " to get their deposit back. Losing the spot in an election will always lead to a slash.", "", " # <weight>", " The number of current candidates must be provided as witness data.", " # </weight>"}}, FunctionMetadataV4{Name: "renounce_candidacy", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "renouncing", Type: "Renouncing"}}, Documentation: []Text{" Renounce one's intention to be a candidate for the next election round. 3 potential", " outcomes exist:", "", " - `origin` is a candidate and not elected in any set. In this case, the deposit is", "   unreserved, returned and origin is removed as a candidate.", " - `origin` is a current runner-up. In this case, the deposit is unreserved, returned and", "   origin is removed as a runner-up.", " - `origin` is a current member. In this case, the deposit is unreserved and origin is", "   removed as a member, consequently not being a candidate for the next round anymore.", "   Similar to [`remove_members`], if replacement runners exists, they are immediately", "   used. If the prime is renouncing, then no prime will exist until the next round.", "", " The dispatch origin of this call must be signed, and have one of the above roles.", "", " # <weight>", " The type of renouncing must be provided as witness data.", " # </weight>"}}, FunctionMetadataV4{Name: "remove_member", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "has_replacement", Type: "bool"}}, Documentation: []Text{" Remove a particular member from the set. This is effective immediately and the bond of", " the outgoing member is slashed.", "", " If a runner-up is available, then the best runner-up will be removed and replaces the", " outgoing member. Otherwise, a new phragmen election is started.", "", " The dispatch origin of this call must be root.", "", " Note that this does not affect the designated block number of the next election.", "", " # <weight>", " If we have a replacement, we use a small weight. Else, since this is a root call and", " will go into phragmen, we assume full block for now.", " # </weight>"}}, FunctionMetadataV4{Name: "clean_defunct_voters", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "_num_voters", Type: "u32"}, FunctionArgumentMetadata{Name: "_num_defunct", Type: "u32"}}, Documentation: []Text{" Clean all voters who are defunct (i.e. they do not serve any purpose at all). The", " deposit of the removed voters are returned.", "", " This is an root function to be used only for cleaning the state.", "", " The dispatch origin of this call must be root.", "", " # <weight>", " The total number of voters and those that are defunct must be provided as witness data.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "NewTerm", Args: []Type{"Vec<(AccountId, Balance)>"}, Documentation: []Text{" A new term with \\[new_members\\]. This indicates that enough candidates existed to run", " the election, not that enough have has been elected. The inner value must be examined", " for this purpose. A `NewTerm(\\[\\])` indicates that some candidates got their bond", " slashed and none were elected, whilst `EmptyTerm` means that no candidates existed to", " begin with."}}, EventMetadataV4{Name: "EmptyTerm", Args: []Type(nil), Documentation: []Text{" No (or not enough) candidates existed for this round. This is different from", " `NewTerm(\\[\\])`. See the description of `NewTerm`."}}, EventMetadataV4{Name: "ElectionError", Args: []Type(nil), Documentation: []Text{" Internal error happened while trying to perform election."}}, EventMetadataV4{Name: "MemberKicked", Args: []Type{"AccountId"}, Documentation: []Text{" A \\[member\\] has been removed. This should always be followed by either `NewTerm` or", " `EmptyTerm`."}}, EventMetadataV4{Name: "Renounced", Args: []Type{"AccountId"}, Documentation: []Text{" Someone has renounced their candidacy."}}, EventMetadataV4{Name: "CandidateSlashed", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" A \\[candidate\\] was slashed by \\[amount\\] due to failing to obtain a seat as member or", " runner-up.", "", " Note that old members and runners-up are also candidates."}}, EventMetadataV4{Name: "SeatHolderSlashed", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" A \\[seat holder\\] was slashed by \\[amount\\] by being forcefully removed from the set."}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "PalletId", Type: "LockIdentifier", Value: Bytes{0x70, 0x68, 0x72, 0x65, 0x6c, 0x65, 0x63, 0x74}, Documentation: []Text{" Identifier for the elections-phragmen pallet's lock"}}, ModuleConstantMetadataV6{Name: "CandidacyBond", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x80, 0xc6, 0xa4, 0x7e, 0x8d, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" How much should be locked up in order to submit one's candidacy."}}, ModuleConstantMetadataV6{Name: "VotingBondBase", Type: "BalanceOf<T>", Value: Bytes{0x0, 0xf0, 0x43, 0x6d, 0xe3, 0x6a, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Base deposit associated with voting.", "", " This should be sensibly high to economically ensure the pallet cannot be attacked by", " creating a gigantic number of votes."}}, ModuleConstantMetadataV6{Name: "VotingBondFactor", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x0, 0xcc, 0x7b, 0x9f, 0xae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of bond that need to be locked for each vote (32 bytes)."}}, ModuleConstantMetadataV6{Name: "DesiredMembers", Type: "u32", Value: Bytes{0xd, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of members to elect."}}, ModuleConstantMetadataV6{Name: "DesiredRunnersUp", Type: "u32", Value: Bytes{0x7, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of runners_up to keep."}}, ModuleConstantMetadataV6{Name: "TermDuration", Type: "T::BlockNumber", Value: Bytes{0x80, 0x13, 0x3, 0x0}, Documentation: []Text{" How long each seat is kept. This defines the next block number at which an election", " round will happen. If set to zero, no elections are ever triggered and the module will", " be in passive mode."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "UnableToVote", Documentation: []Text{" Cannot vote when no candidates or members exist."}}, ErrorMetadataV8{Name: "NoVotes", Documentation: []Text{" Must vote for at least one candidate."}}, ErrorMetadataV8{Name: "TooManyVotes", Documentation: []Text{" Cannot vote more than candidates."}}, ErrorMetadataV8{Name: "MaximumVotesExceeded", Documentation: []Text{" Cannot vote more than maximum allowed."}}, ErrorMetadataV8{Name: "LowBalance", Documentation: []Text{" Cannot vote with stake less than minimum balance."}}, ErrorMetadataV8{Name: "UnableToPayBond", Documentation: []Text{" Voter can not pay voting bond."}}, ErrorMetadataV8{Name: "MustBeVoter", Documentation: []Text{" Must be a voter."}}, ErrorMetadataV8{Name: "ReportSelf", Documentation: []Text{" Cannot report self."}}, ErrorMetadataV8{Name: "DuplicatedCandidate", Documentation: []Text{" Duplicated candidate submission."}}, ErrorMetadataV8{Name: "MemberSubmit", Documentation: []Text{" Member cannot re-submit candidacy."}}, ErrorMetadataV8{Name: "RunnerUpSubmit", Documentation: []Text{" Runner cannot re-submit candidacy."}}, ErrorMetadataV8{Name: "InsufficientCandidateFunds", Documentation: []Text{" Candidate does not have enough funds."}}, ErrorMetadataV8{Name: "NotMember", Documentation: []Text{" Not a member."}}, ErrorMetadataV8{Name: "InvalidWitnessData", Documentation: []Text{" The provided count of number of candidates is incorrect."}}, ErrorMetadataV8{Name: "InvalidVoteCount", Documentation: []Text{" The provided count of number of votes is incorrect."}}, ErrorMetadataV8{Name: "InvalidRenouncing", Documentation: []Text{" The renouncing origin presented a wrong `Renouncing` parameter."}}, ErrorMetadataV8{Name: "InvalidReplacement", Documentation: []Text{" Prediction regarding replacement after member removal is wrong."}}}, Index: 0xe}, ModuleMetadataV13{Name: "TechnicalMembership", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Instance1Membership", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current membership, stored as an ordered Vec."}}, StorageFunctionMetadataV13{Name: "Prime", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current prime member, if one exists."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "add_member", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}}, Documentation: []Text{" Add a member `who` to the set.", "", " May only be called from `T::AddOrigin`."}}, FunctionMetadataV4{Name: "remove_member", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}}, Documentation: []Text{" Remove a member `who` from the set.", "", " May only be called from `T::RemoveOrigin`."}}, FunctionMetadataV4{Name: "swap_member", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "remove", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "add", Type: "T::AccountId"}}, Documentation: []Text{" Swap out one member `remove` for another `add`.", "", " May only be called from `T::SwapOrigin`.", "", " Prime membership is *not* passed from `remove` to `add`, if extant."}}, FunctionMetadataV4{Name: "reset_members", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "members", Type: "Vec<T::AccountId>"}}, Documentation: []Text{" Change the membership to a new set, disregarding the existing membership. Be nice and", " pass `members` pre-sorted.", "", " May only be called from `T::ResetOrigin`."}}, FunctionMetadataV4{Name: "change_key", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new", Type: "T::AccountId"}}, Documentation: []Text{" Swap out the sending member for some other key `new`.", "", " May only be called from `Signed` origin of a current member.", "", " Prime membership is passed from the origin account to `new`, if extant."}}, FunctionMetadataV4{Name: "set_prime", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}}, Documentation: []Text{" Set the prime member. Must be a current member.", "", " May only be called from `T::PrimeOrigin`."}}, FunctionMetadataV4{Name: "clear_prime", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Remove the prime member if it exists.", "", " May only be called from `T::PrimeOrigin`."}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "MemberAdded", Args: []Type(nil), Documentation: []Text{" The given member was added; see the transaction for who."}}, EventMetadataV4{Name: "MemberRemoved", Args: []Type(nil), Documentation: []Text{" The given member was removed; see the transaction for who."}}, EventMetadataV4{Name: "MembersSwapped", Args: []Type(nil), Documentation: []Text{" Two members were swapped; see the transaction for who."}}, EventMetadataV4{Name: "MembersReset", Args: []Type(nil), Documentation: []Text{" The membership was reset; see the transaction for who the new set is."}}, EventMetadataV4{Name: "KeyChanged", Args: []Type(nil), Documentation: []Text{" One of the members' keys changed."}}, EventMetadataV4{Name: "Dummy", Args: []Type{"sp_std::marker::PhantomData<(AccountId, Event)>"}, Documentation: []Text{" Phantom member, never used."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "AlreadyMember", Documentation: []Text{" Already a member."}}, ErrorMetadataV8{Name: "NotMember", Documentation: []Text{" Not a member."}}}, Index: 0xf}, ModuleMetadataV13{Name: "Grandpa", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Grandpa", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "State", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "StoredState<T::BlockNumber>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" State of the current authority set."}}, StorageFunctionMetadataV13{Name: "PendingChange", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "StoredPendingChange<T::BlockNumber>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Pending change: (signaled at, scheduled change)."}}, StorageFunctionMetadataV13{Name: "NextForced", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" next block number where we can force a change."}}, StorageFunctionMetadataV13{Name: "Stalled", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "(T::BlockNumber, T::BlockNumber)", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" `true` if we are currently stalled."}}, StorageFunctionMetadataV13{Name: "CurrentSetId", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "SetId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of changes (both in terms of keys and underlying economic responsibilities)", " in the \"set\" of Grandpa validators from genesis."}}, StorageFunctionMetadataV13{Name: "SetIdSession", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "SetId", Value: "SessionIndex", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping from grandpa set ID to the index of the *most recent* session for which its", " members were responsible.", "", " TWOX-NOTE: `SetId` is not under user control."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "report_equivocation", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "equivocation_proof", Type: "EquivocationProof<T::Hash, T::BlockNumber>"}, FunctionArgumentMetadata{Name: "key_owner_proof", Type: "T::KeyOwnerProof"}}, Documentation: []Text{" Report voter equivocation/misbehavior. This method will verify the", " equivocation proof and validate the given key ownership proof", " against the extracted offender. If both are valid, the offence", " will be reported."}}, FunctionMetadataV4{Name: "report_equivocation_unsigned", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "equivocation_proof", Type: "EquivocationProof<T::Hash, T::BlockNumber>"}, FunctionArgumentMetadata{Name: "key_owner_proof", Type: "T::KeyOwnerProof"}}, Documentation: []Text{" Report voter equivocation/misbehavior. This method will verify the", " equivocation proof and validate the given key ownership proof", " against the extracted offender. If both are valid, the offence", " will be reported.", "", " This extrinsic must be called unsigned and it is expected that only", " block authors will call it (validated in `ValidateUnsigned`), as such", " if the block author is defined it will be defined as the equivocation", " reporter."}}, FunctionMetadataV4{Name: "note_stalled", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "delay", Type: "T::BlockNumber"}, FunctionArgumentMetadata{Name: "best_finalized_block_number", Type: "T::BlockNumber"}}, Documentation: []Text{" Note that the current authority set of the GRANDPA finality gadget has", " stalled. This will trigger a forced authority set change at the beginning", " of the next session, to be enacted `delay` blocks after that. The delay", " should be high enough to safely assume that the block signalling the", " forced change will not be re-orged (e.g. 1000 blocks). The GRANDPA voters", " will start the new authority set using the given finalized block as base.", " Only callable by root."}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "NewAuthorities", Args: []Type{"AuthorityList"}, Documentation: []Text{" New authority set has been applied. \\[authority_set\\]"}}, EventMetadataV4{Name: "Paused", Args: []Type(nil), Documentation: []Text{" Current authority set has been paused."}}, EventMetadataV4{Name: "Resumed", Args: []Type(nil), Documentation: []Text{" Current authority set has been resumed."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "PauseFailed", Documentation: []Text{" Attempt to signal GRANDPA pause when the authority set isn't live", " (either paused or already pending pause)."}}, ErrorMetadataV8{Name: "ResumeFailed", Documentation: []Text{" Attempt to signal GRANDPA resume when the authority set isn't paused", " (either live or already pending resume)."}}, ErrorMetadataV8{Name: "ChangePending", Documentation: []Text{" Attempt to signal GRANDPA change with one already pending."}}, ErrorMetadataV8{Name: "TooSoon", Documentation: []Text{" Cannot signal forced change so soon after last."}}, ErrorMetadataV8{Name: "InvalidKeyOwnershipProof", Documentation: []Text{" A key ownership proof provided as part of an equivocation report is invalid."}}, ErrorMetadataV8{Name: "InvalidEquivocationProof", Documentation: []Text{" An equivocation proof provided as part of an equivocation report is invalid."}}, ErrorMetadataV8{Name: "DuplicateOffenceReport", Documentation: []Text{" A given equivocation report is valid but already previously reported."}}}, Index: 0x10}, ModuleMetadataV13{Name: "Treasury", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Treasury", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "ProposalCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "ProposalIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of proposals that have been made."}}, StorageFunctionMetadataV13{Name: "Proposals", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "ProposalIndex", Value: "Proposal<T::AccountId, BalanceOf<T, I>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Proposals that have been made."}}, StorageFunctionMetadataV13{Name: "Approvals", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "BoundedVec<ProposalIndex, T::MaxApprovals>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Proposal indices that have been approved but not yet awarded."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "propose_spend", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T, I>>"}, FunctionArgumentMetadata{Name: "beneficiary", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Put forward a suggestion for spending. A deposit proportional to the value", " is reserved and slashed if the proposal is rejected. It is returned once the", " proposal is awarded.", "", " # <weight>", " - Complexity: O(1)", " - DbReads: `ProposalCount`, `origin account`", " - DbWrites: `ProposalCount`, `Proposals`, `origin account`", " # </weight>"}}, FunctionMetadataV4{Name: "reject_proposal", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_id", Type: "Compact<ProposalIndex>"}}, Documentation: []Text{" Reject a proposed spend. The original deposit will be slashed.", "", " May only be called from `T::RejectOrigin`.", "", " # <weight>", " - Complexity: O(1)", " - DbReads: `Proposals`, `rejected proposer account`", " - DbWrites: `Proposals`, `rejected proposer account`", " # </weight>"}}, FunctionMetadataV4{Name: "approve_proposal", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_id", Type: "Compact<ProposalIndex>"}}, Documentation: []Text{" Approve a proposal. At a later time, the proposal will be allocated to the beneficiary", " and the original deposit will be returned.", "", " May only be called from `T::ApproveOrigin`.", "", " # <weight>", " - Complexity: O(1).", " - DbReads: `Proposals`, `Approvals`", " - DbWrite: `Approvals`", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Proposed", Args: []Type{"ProposalIndex"}, Documentation: []Text{" New proposal. \\[proposal_index\\]"}}, EventMetadataV4{Name: "Spending", Args: []Type{"Balance"}, Documentation: []Text{" We have ended a spend period and will now allocate funds. \\[budget_remaining\\]"}}, EventMetadataV4{Name: "Awarded", Args: []Type{"ProposalIndex", "Balance", "AccountId"}, Documentation: []Text{" Some funds have been allocated. \\[proposal_index, award, beneficiary\\]"}}, EventMetadataV4{Name: "Rejected", Args: []Type{"ProposalIndex", "Balance"}, Documentation: []Text{" A proposal was rejected; funds were slashed. \\[proposal_index, slashed\\]"}}, EventMetadataV4{Name: "Burnt", Args: []Type{"Balance"}, Documentation: []Text{" Some of our funds have been burnt. \\[burn\\]"}}, EventMetadataV4{Name: "Rollover", Args: []Type{"Balance"}, Documentation: []Text{" Spending has finished; this is the amount that rolls over until next spend.", " \\[budget_remaining\\]"}}, EventMetadataV4{Name: "Deposit", Args: []Type{"Balance"}, Documentation: []Text{" Some funds have been deposited. \\[deposit\\]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "ProposalBond", Type: "Permill", Value: Bytes{0x50, 0xc3, 0x0, 0x0}, Documentation: []Text{" Fraction of a proposal's value that should be bonded in order to place the proposal.", " An accepted proposal gets these back. A rejected proposal does not."}}, ModuleConstantMetadataV6{Name: "ProposalBondMinimum", Type: "BalanceOf<T, I>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Minimum amount of funds that should be placed in a deposit for making a proposal."}}, ModuleConstantMetadataV6{Name: "SpendPeriod", Type: "T::BlockNumber", Value: Bytes{0x80, 0x70, 0x0, 0x0}, Documentation: []Text{" Period between successive spends."}}, ModuleConstantMetadataV6{Name: "Burn", Type: "Permill", Value: Bytes{0x20, 0xa1, 0x7, 0x0}, Documentation: []Text{" Percentage of spare funds (if any) that are burnt per spend period."}}, ModuleConstantMetadataV6{Name: "PalletId", Type: "PalletId", Value: Bytes{0x70, 0x79, 0x2f, 0x74, 0x72, 0x73, 0x72, 0x79}, Documentation: []Text{" The treasury's module id, used for deriving its sovereign account ID."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InsufficientProposersBalance", Documentation: []Text{" Proposer's balance is too low."}}, ErrorMetadataV8{Name: "InvalidIndex", Documentation: []Text{" No proposal or bounty at that index."}}, ErrorMetadataV8{Name: "TooManyApprovals", Documentation: []Text{" Too many approvals in the queue."}}}, Index: 0x11}, ModuleMetadataV13{Name: "Contracts", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Contracts", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "PristineCode", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "CodeHash<T>", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping from an original code hash to the original code, untouched by instrumentation."}}, StorageFunctionMetadataV13{Name: "CodeStorage", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "CodeHash<T>", Value: "PrefabWasmModule<T>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping between an original code hash and instrumented wasm code, ready for execution."}}, StorageFunctionMetadataV13{Name: "AccountCounter", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "u64", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The subtrie counter."}}, StorageFunctionMetadataV13{Name: "ContractInfoOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "ContractInfo<T>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The code associated with a given account.", "", " TWOX-NOTE: SAFE since `AccountId` is a secure hash."}}, StorageFunctionMetadataV13{Name: "DeletionQueue", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<DeletedContract>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Evicted contracts that await child trie deletion.", "", " Child trie deletion is a heavy operation depending on the amount of storage items", " stored in said trie. Therefore this operation is performed lazily in `on_initialize`."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "call", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}, FunctionArgumentMetadata{Name: "gas_limit", Type: "Compact<Weight>"}, FunctionArgumentMetadata{Name: "data", Type: "Vec<u8>"}}, Documentation: []Text{" Makes a call to an account, optionally transferring some balance.", "", " * If the account is a smart-contract account, the associated code will be", " executed and any value will be transferred.", " * If the account is a regular account, any value will be transferred.", " * If no account exists and the call value is not less than `existential_deposit`,", " a regular account will be created and any value will be transferred."}}, FunctionMetadataV4{Name: "instantiate_with_code", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "endowment", Type: "Compact<BalanceOf<T>>"}, FunctionArgumentMetadata{Name: "gas_limit", Type: "Compact<Weight>"}, FunctionArgumentMetadata{Name: "code", Type: "Vec<u8>"}, FunctionArgumentMetadata{Name: "data", Type: "Vec<u8>"}, FunctionArgumentMetadata{Name: "salt", Type: "Vec<u8>"}}, Documentation: []Text{" Instantiates a new contract from the supplied `code` optionally transferring", " some balance.", "", " This is the only function that can deploy new code to the chain.", "", " # Parameters", "", " * `endowment`: The balance to transfer from the `origin` to the newly created contract.", " * `gas_limit`: The gas limit enforced when executing the constructor.", " * `code`: The contract code to deploy in raw bytes.", " * `data`: The input data to pass to the contract constructor.", " * `salt`: Used for the address derivation. See [`Pallet::contract_address`].", "", " Instantiation is executed as follows:", "", " - The supplied `code` is instrumented, deployed, and a `code_hash` is created for that code.", " - If the `code_hash` already exists on the chain the underlying `code` will be shared.", " - The destination address is computed based on the sender, code_hash and the salt.", " - The smart-contract account is created at the computed address.", " - The `endowment` is transferred to the new account.", " - The `deploy` function is executed in the context of the newly-created account."}}, FunctionMetadataV4{Name: "instantiate", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "endowment", Type: "Compact<BalanceOf<T>>"}, FunctionArgumentMetadata{Name: "gas_limit", Type: "Compact<Weight>"}, FunctionArgumentMetadata{Name: "code_hash", Type: "CodeHash<T>"}, FunctionArgumentMetadata{Name: "data", Type: "Vec<u8>"}, FunctionArgumentMetadata{Name: "salt", Type: "Vec<u8>"}}, Documentation: []Text{" Instantiates a contract from a previously deployed wasm binary.", "", " This function is identical to [`Self::instantiate_with_code`] but without the", " code deployment step. Instead, the `code_hash` of an on-chain deployed wasm binary", " must be supplied."}}, FunctionMetadataV4{Name: "claim_surcharge", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "dest", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "aux_sender", Type: "Option<T::AccountId>"}}, Documentation: []Text{" Allows block producers to claim a small reward for evicting a contract. If a block", " producer fails to do so, a regular users will be allowed to claim the reward.", "", " In case of a successful eviction no fees are charged from the sender. However, the", " reward is capped by the total amount of rent that was paid by the contract while", " it was alive.", "", " If contract is not evicted as a result of this call, [`Error::ContractNotEvictable`]", " is returned and the sender is not eligible for the reward."}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Instantiated", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" Contract deployed by address at the specified address. \\[deployer, contract\\]"}}, EventMetadataV4{Name: "Evicted", Args: []Type{"AccountId"}, Documentation: []Text{" Contract has been evicted and is now in tombstone state. \\[contract\\]"}}, EventMetadataV4{Name: "Terminated", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" Contract has been terminated without leaving a tombstone.", " \\[contract, beneficiary\\]", "", " # Params", "", " - `contract`: The contract that was terminated.", " - `beneficiary`: The account that received the contracts remaining balance.", "", " # Note", "", " The only way for a contract to be removed without a tombstone and emitting", " this event is by calling `seal_terminate`."}}, EventMetadataV4{Name: "Restored", Args: []Type{"AccountId", "AccountId", "Hash", "Balance"}, Documentation: []Text{" Restoration of a contract has been successful.", " \\[restorer, dest, code_hash, rent_allowance\\]", "", " # Params", "", " - `restorer`: Account ID of the restoring contract.", " - `dest`: Account ID of the restored contract.", " - `code_hash`: Code hash of the restored contract.", " - `rent_allowance`: Rent allowance of the restored contract."}}, EventMetadataV4{Name: "CodeStored", Args: []Type{"Hash"}, Documentation: []Text{" Code with the specified hash has been stored. \\[code_hash\\]"}}, EventMetadataV4{Name: "ScheduleUpdated", Args: []Type{"u32"}, Documentation: []Text{" Triggered when the current schedule is updated.", " \\[version\\]", "", " # Params", "", " - `version`: The version of the newly set schedule."}}, EventMetadataV4{Name: "ContractEmitted", Args: []Type{"AccountId", "Vec<u8>"}, Documentation: []Text{" A custom event emitted by the contract.", " \\[contract, data\\]", "", " # Params", "", " - `contract`: The contract that emitted the event.", " - `data`: Data supplied by the contract. Metadata generated during contract", "           compilation is needed to decode it."}}, EventMetadataV4{Name: "CodeRemoved", Args: []Type{"Hash"}, Documentation: []Text{" A code with the specified hash was removed.", " \\[code_hash\\]", "", " This happens when the last contract that uses this code hash was removed or evicted."}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "Schedule", Type: "Schedule<T>", Value: Bytes{0x4, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x80, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x2, 0x0, 0x0, 0x0, 0x8e, 0x6, 0x0, 0x0, 0xe2, 0xfc, 0x1, 0x0, 0xcd, 0xf, 0x3, 0x0, 0x9, 0x17, 0x0, 0x0, 0x86, 0x1d, 0x0, 0x0, 0x3, 0xc, 0x0, 0x0, 0x1f, 0x18, 0x0, 0x0, 0x56, 0x29, 0x0, 0x0, 0x82, 0x0, 0x0, 0x0, 0xb0, 0x59, 0x1, 0x0, 0x55, 0x81, 0x2, 0x0, 0xc0, 0xb, 0x0, 0x0, 0x29, 0x7, 0x0, 0x0, 0x59, 0x8, 0x0, 0x0, 0x3b, 0x6, 0x0, 0x0, 0xb8, 0x16, 0x0, 0x0, 0xa6, 0x1a, 0x0, 0x0, 0x60, 0x7, 0x0, 0x0, 0xd, 0xe8, 0xb6, 0x7, 0xb1, 0x6, 0x0, 0x0, 0x7d, 0x6, 0x0, 0x0, 0xe6, 0x9, 0x0, 0x0, 0xdc, 0x7, 0x0, 0x0, 0xd5, 0x5, 0x0, 0x0, 0xd7, 0x5, 0x0, 0x0, 0x5b, 0x6, 0x0, 0x0, 0x43, 0x9, 0x0, 0x0, 0x39, 0x9, 0x0, 0x0, 0x1c, 0x9, 0x0, 0x0, 0x4d, 0x9, 0x0, 0x0, 0x1d, 0x9, 0x0, 0x0, 0x30, 0x9, 0x0, 0x0, 0x18, 0x9, 0x0, 0x0, 0x41, 0x9, 0x0, 0x0, 0x38, 0x9, 0x0, 0x0, 0x68, 0x9, 0x0, 0x0, 0x7d, 0x8, 0x0, 0x0, 0xf8, 0x8, 0x0, 0x0, 0x8e, 0x8, 0x0, 0x0, 0x3, 0x22, 0x0, 0x0, 0x37, 0x1e, 0x0, 0x0, 0xfd, 0x21, 0x0, 0x0, 0xe7, 0x1d, 0x0, 0x0, 0xa6, 0x8, 0x0, 0x0, 0xab, 0x8, 0x0, 0x0, 0xd5, 0x8, 0x0, 0x0, 0xdb, 0x9, 0x0, 0x0, 0xd8, 0x9, 0x0, 0x0, 0x19, 0xa, 0x0, 0x0, 0x1e, 0xb, 0x0, 0x0, 0xc, 0x9, 0x0, 0x0, 0x52, 0xf7, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6e, 0xe5, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9c, 0x21, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x30, 0x39, 0x50, 0x0, 0x0, 0x0, 0x0, 0x0, 0x70, 0x2a, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x64, 0x4f, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0xce, 0x3a, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0xdc, 0x54, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf0, 0x18, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1e, 0x31, 0x24, 0x0, 0x0, 0x0, 0x0, 0x0, 0xb0, 0xc1, 0x47, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9a, 0x12, 0x12, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc0, 0x40, 0x6d, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x78, 0x54, 0x42, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe3, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf0, 0x3a, 0x7d, 0x20, 0x0, 0x0, 0x0, 0x0, 0x67, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x40, 0xa9, 0xe7, 0x29, 0x0, 0x0, 0x0, 0x0, 0x2c, 0x1e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x65, 0xf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xac, 0x13, 0xaa, 0x9, 0x0, 0x0, 0x0, 0x0, 0x6c, 0x83, 0x5b, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc2, 0x29, 0x87, 0x0, 0x0, 0x0, 0x0, 0x0, 0xda, 0xd6, 0xc9, 0x7, 0x0, 0x0, 0x0, 0x0, 0x94, 0x9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc0, 0x68, 0x13, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7c, 0xb, 0x19, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x10, 0xb2, 0x9, 0x0, 0x0, 0x0, 0x0, 0xb5, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xfe, 0xe1, 0x30, 0x8, 0x0, 0x0, 0x0, 0x0, 0xc2, 0x74, 0x8, 0x2, 0x0, 0x0, 0x0, 0x0, 0xdb, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6c, 0x54, 0x8a, 0xa, 0x0, 0x0, 0x0, 0x0, 0xaa, 0xb1, 0xda, 0xf, 0x0, 0x0, 0x0, 0x0, 0xf5, 0xe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x60, 0x8b, 0x39, 0x8, 0x0, 0x0, 0x0, 0x0, 0x50, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8e, 0x63, 0xf0, 0x22, 0x0, 0x0, 0x0, 0x0, 0x7e, 0x21, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x67, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2c, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x29, 0x9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa4, 0x1f, 0x23, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc3, 0x12, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7c, 0xa6, 0x23, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0xd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xbd, 0x1f, 0x0, 0x0, 0x0, 0x0, 0x0, 0x15, 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xa6, 0xa8, 0x1f, 0x0, 0x0, 0x0, 0x0, 0x0, 0xfc, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Cost schedule and limits."}}, ModuleConstantMetadataV6{Name: "SignedClaimHandicap", Type: "T::BlockNumber", Value: Bytes{0x2, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of block delay an extrinsic claim surcharge has.", "", " When claim surcharge is called by an extrinsic the rent is checked", " for current_block - delay"}}, ModuleConstantMetadataV6{Name: "TombstoneDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0xf0, 0xe8, 0x85, 0x7a, 0x9c, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount required to generate a tombstone."}}, ModuleConstantMetadataV6{Name: "DepositPerContract", Type: "BalanceOf<T>", Value: Bytes{0x0, 0xf0, 0xe8, 0x85, 0x7a, 0x9c, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The balance every contract needs to deposit to stay alive indefinitely.", "", " This is different from the [`Self::TombstoneDeposit`] because this only needs to be", " deposited while the contract is alive. Costs for additional storage are added to", " this base cost.", "", " This is a simple way to ensure that contracts with empty storage eventually get deleted by", " making them pay rent. This creates an incentive to remove them early in order to save rent."}}, ModuleConstantMetadataV6{Name: "DepositPerStorageByte", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x60, 0xde, 0xfb, 0x74, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The balance a contract needs to deposit per storage byte to stay alive indefinitely.", "", " Let's suppose the deposit is 1,000 BU (balance units)/byte and the rent is 1 BU/byte/day,", " then a contract with 1,000,000 BU that uses 1,000 bytes of storage would pay no rent.", " But if the balance reduced to 500,000 BU and the storage stayed the same at 1,000,", " then it would pay 500 BU/day."}}, ModuleConstantMetadataV6{Name: "DepositPerStorageItem", Type: "BalanceOf<T>", Value: Bytes{0x0, 0xf0, 0xab, 0x75, 0xa4, 0xd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The balance a contract needs to deposit per storage item to stay alive indefinitely.", "", " It works the same as [`Self::DepositPerStorageByte`] but for storage items."}}, ModuleConstantMetadataV6{Name: "RentFraction", Type: "Perbill", Value: Bytes{0x85, 0x4, 0x0, 0x0}, Documentation: []Text{" The fraction of the deposit that should be used as rent per block.", "", " When a contract hasn't enough balance deposited to stay alive indefinitely it needs", " to pay per block for the storage it consumes that is not covered by the deposit.", " This determines how high this rent payment is per block as a fraction of the deposit."}}, ModuleConstantMetadataV6{Name: "SurchargeReward", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x5c, 0xb2, 0xec, 0x22, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Reward that is received by the party whose touch has led", " to removal of a contract."}}, ModuleConstantMetadataV6{Name: "DeletionQueueDepth", Type: "u32", Value: Bytes{0x85, 0x4, 0x0, 0x0}, Documentation: []Text{" The maximum number of tries that can be queued for deletion."}}, ModuleConstantMetadataV6{Name: "DeletionWeightLimit", Type: "Weight", Value: Bytes{0x0, 0xd0, 0xed, 0x90, 0x2e, 0x0, 0x0, 0x0}, Documentation: []Text{" The maximum amount of weight that can be consumed per block for lazy trie removal."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InvalidScheduleVersion", Documentation: []Text{" A new schedule must have a greater version than the current one."}}, ErrorMetadataV8{Name: "InvalidSurchargeClaim", Documentation: []Text{" An origin must be signed or inherent and auxiliary sender only provided on inherent."}}, ErrorMetadataV8{Name: "InvalidSourceContract", Documentation: []Text{" Cannot restore from nonexisting or tombstone contract."}}, ErrorMetadataV8{Name: "InvalidDestinationContract", Documentation: []Text{" Cannot restore to nonexisting or alive contract."}}, ErrorMetadataV8{Name: "InvalidTombstone", Documentation: []Text{" Tombstones don't match."}}, ErrorMetadataV8{Name: "InvalidContractOrigin", Documentation: []Text{" An origin TrieId written in the current block."}}, ErrorMetadataV8{Name: "OutOfGas", Documentation: []Text{" The executed contract exhausted its gas limit."}}, ErrorMetadataV8{Name: "OutputBufferTooSmall", Documentation: []Text{" The output buffer supplied to a contract API call was too small."}}, ErrorMetadataV8{Name: "BelowSubsistenceThreshold", Documentation: []Text{" Performing the requested transfer would have brought the contract below", " the subsistence threshold. No transfer is allowed to do this in order to allow", " for a tombstone to be created. Use `seal_terminate` to remove a contract without", " leaving a tombstone behind."}}, ErrorMetadataV8{Name: "NewContractNotFunded", Documentation: []Text{" The newly created contract is below the subsistence threshold after executing", " its contructor. No contracts are allowed to exist below that threshold."}}, ErrorMetadataV8{Name: "TransferFailed", Documentation: []Text{" Performing the requested transfer failed for a reason originating in the", " chosen currency implementation of the runtime. Most probably the balance is", " too low or locks are placed on it."}}, ErrorMetadataV8{Name: "MaxCallDepthReached", Documentation: []Text{" Performing a call was denied because the calling depth reached the limit", " of what is specified in the schedule."}}, ErrorMetadataV8{Name: "ContractNotFound", Documentation: []Text{" No contract was found at the specified address."}}, ErrorMetadataV8{Name: "ContractIsTombstone", Documentation: []Text{" A tombstone exist at the specified address.", "", " Tombstone cannot be called. Anyone can use `seal_restore_to` in order to revive", " the contract, though."}}, ErrorMetadataV8{Name: "RentNotPaid", Documentation: []Text{" The called contract does not have enough balance to pay for its storage.", "", " The contract ran out of balance and is therefore eligible for eviction into a", " tombstone. Anyone can evict the contract by submitting a `claim_surcharge`", " extrinsic. Alternatively, a plain balance transfer can be used in order to", " increase the contracts funds so that it can be called again."}}, ErrorMetadataV8{Name: "CodeTooLarge", Documentation: []Text{" The code supplied to `instantiate_with_code` exceeds the limit specified in the", " current schedule."}}, ErrorMetadataV8{Name: "CodeNotFound", Documentation: []Text{" No code could be found at the supplied code hash."}}, ErrorMetadataV8{Name: "OutOfBounds", Documentation: []Text{" A buffer outside of sandbox memory was passed to a contract API function."}}, ErrorMetadataV8{Name: "DecodingFailed", Documentation: []Text{" Input passed to a contract API function failed to decode as expected type."}}, ErrorMetadataV8{Name: "ContractTrapped", Documentation: []Text{" Contract trapped during execution."}}, ErrorMetadataV8{Name: "ValueTooLarge", Documentation: []Text{" The size defined in `T::MaxValueSize` was exceeded."}}, ErrorMetadataV8{Name: "ReentranceDenied", Documentation: []Text{" The action performed is not allowed while the contract performing it is already", " on the call stack. Those actions are contract self destruction and restoration", " of a tombstone."}}, ErrorMetadataV8{Name: "InputAlreadyRead", Documentation: []Text{" `seal_input` was called twice from the same contract execution context."}}, ErrorMetadataV8{Name: "RandomSubjectTooLong", Documentation: []Text{" The subject passed to `seal_random` exceeds the limit."}}, ErrorMetadataV8{Name: "TooManyTopics", Documentation: []Text{" The amount of topics passed to `seal_deposit_events` exceeds the limit."}}, ErrorMetadataV8{Name: "DuplicateTopics", Documentation: []Text{" The topics passed to `seal_deposit_events` contains at least one duplicate."}}, ErrorMetadataV8{Name: "NoChainExtension", Documentation: []Text{" The chain does not provide a chain extension. Calling the chain extension results", " in this error. Note that this usually  shouldn't happen as deploying such contracts", " is rejected."}}, ErrorMetadataV8{Name: "DeletionQueueFull", Documentation: []Text{" Removal of a contract failed because the deletion queue is full.", "", " This can happen when either calling [`Pallet::claim_surcharge`] or `seal_terminate`.", " The queue is filled by deleting contracts and emptied by a fixed amount each block.", " Trying again during another block is the only way to resolve this issue."}}, ErrorMetadataV8{Name: "ContractNotEvictable", Documentation: []Text{" A contract could not be evicted because it has enough balance to pay rent.", "", " This can be returned from [`Pallet::claim_surcharge`] because the target", " contract has enough balance to pay for its rent."}}, ErrorMetadataV8{Name: "StorageExhausted", Documentation: []Text{" A storage modification exhausted the 32bit type that holds the storage size.", "", " This can either happen when the accumulated storage in bytes is too large or", " when number of storage items is too large."}}, ErrorMetadataV8{Name: "DuplicateContract", Documentation: []Text{" A contract with the same AccountId already exists."}}, ErrorMetadataV8{Name: "TerminatedInConstructor", Documentation: []Text{" A contract self destructed in its constructor.", "", " This can be triggered by a call to `seal_terminate` or `seal_restore_to`."}}, ErrorMetadataV8{Name: "DebugMessageInvalidUTF8", Documentation: []Text{" The debug message specified to `seal_debug_message` does contain invalid UTF-8."}}}, Index: 0x12}, ModuleMetadataV13{Name: "Sudo", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Sudo", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Key", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The `AccountId` of the sudo key."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "sudo", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Config>::Call>"}}, Documentation: []Text{" Authenticates the sudo key and dispatches a function call with `Root` origin.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB write (event).", " - Weight of derivative `call` execution + 10,000.", " # </weight>"}}, FunctionMetadataV4{Name: "sudo_unchecked_weight", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Config>::Call>"}, FunctionArgumentMetadata{Name: "_weight", Type: "Weight"}}, Documentation: []Text{" Authenticates the sudo key and dispatches a function call with `Root` origin.", " This function does not check the weight of the call, and instead allows the", " Sudo user to specify the weight of the call.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - O(1).", " - The weight of this call is defined by the caller.", " # </weight>"}}, FunctionMetadataV4{Name: "set_key", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB change.", " # </weight>"}}, FunctionMetadataV4{Name: "sudo_as", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Config>::Call>"}}, Documentation: []Text{" Authenticates the sudo key and dispatches a function call with `Signed` origin from", " a given account.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB write (event).", " - Weight of derivative `call` execution + 10,000.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Sudid", Args: []Type{"DispatchResult"}, Documentation: []Text{" A sudo just took place. \\[result\\]"}}, EventMetadataV4{Name: "KeyChanged", Args: []Type{"AccountId"}, Documentation: []Text{" The \\[sudoer\\] just switched identity; the old key is supplied."}}, EventMetadataV4{Name: "SudoAsDone", Args: []Type{"DispatchResult"}, Documentation: []Text{" A sudo just took place. \\[result\\]"}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "RequireSudo", Documentation: []Text{" Sender must be the Sudo account"}}}, Index: 0x13}, ModuleMetadataV13{Name: "ImOnline", HasStorage: true, Storage: StorageMetadataV13{Prefix: "ImOnline", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "HeartbeatAfter", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The block number after which it's ok to send heartbeats in the current", " session.", "", " At the beginning of each session we set this to a value that should fall", " roughly in the middle of the session duration. The idea is to first wait for", " the validators to produce a block in the current session, so that the", " heartbeat later on will not be necessary.", "", " This value will only be used as a fallback if we fail to get a proper session", " progress estimate from `NextSessionRotation`, as those estimates should be", " more accurate then the value we calculate for `HeartbeatAfter`."}}, StorageFunctionMetadataV13{Name: "Keys", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<T::AuthorityId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current set of keys that may issue a heartbeat."}}, StorageFunctionMetadataV13{Name: "ReceivedHeartbeats", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "SessionIndex", Key2: "AuthIndex", Value: "Vec<u8>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" For each session index, we keep a mapping of `AuthIndex` to", " `offchain::OpaqueNetworkState`."}}, StorageFunctionMetadataV13{Name: "AuthoredBlocks", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "SessionIndex", Key2: "ValidatorId<T>", Value: "u32", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" For each session index, we keep a mapping of `ValidatorId<T>` to the", " number of blocks authored by the given authority."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "heartbeat", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "heartbeat", Type: "Heartbeat<T::BlockNumber>"}, FunctionArgumentMetadata{Name: "_signature", Type: "<T::AuthorityId as RuntimeAppPublic>::Signature"}}, Documentation: []Text{" # <weight>", " - Complexity: `O(K + E)` where K is length of `Keys` (heartbeat.validators_len)", "   and E is length of `heartbeat.network_state.external_address`", "   - `O(K)`: decoding of length `K`", "   - `O(E)`: decoding/encoding of length `E`", " - DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,", "   `ReceivedHeartbeats`", " - DbWrites: `ReceivedHeartbeats`", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "HeartbeatReceived", Args: []Type{"AuthorityId"}, Documentation: []Text{" A new heartbeat was received from `AuthorityId` \\[authority_id\\]"}}, EventMetadataV4{Name: "AllGood", Args: []Type(nil), Documentation: []Text{" At the end of the session, no offence was committed."}}, EventMetadataV4{Name: "SomeOffline", Args: []Type{"Vec<IdentificationTuple>"}, Documentation: []Text{" At the end of the session, at least one validator was found to be \\[offline\\]."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InvalidKey", Documentation: []Text{" Non existent public key."}}, ErrorMetadataV8{Name: "DuplicatedHeartbeat", Documentation: []Text{" Duplicated heartbeat."}}}, Index: 0x14}, ModuleMetadataV13{Name: "AuthorityDiscovery", HasStorage: false, Storage: StorageMetadataV13{Prefix: "", Items: []StorageFunctionMetadataV13(nil)}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil), Index: 0x15}, ModuleMetadataV13{Name: "Offences", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Offences", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Reports", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "ReportIdOf<T>", Value: "OffenceDetails<T::AccountId, T::IdentificationTuple>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The primary structure that holds all offence records keyed by report identifiers."}}, StorageFunctionMetadataV13{Name: "ConcurrentReportsIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "Kind", Key2: "OpaqueTimeSlot", Value: "Vec<ReportIdOf<T>>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" A vector of reports of the same kind that happened at the same time slot."}}, StorageFunctionMetadataV13{Name: "ReportsByKindIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "Kind", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Enumerates all reports of a kind along with the time they happened.", "", " All reports are sorted by the time of offence.", "", " Note that the actual type of this mapping is `Vec<u8>`, this is because values of", " different types are not supported at the moment so we are doing the manual serialization."}}}}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Offence", Args: []Type{"Kind", "OpaqueTimeSlot"}, Documentation: []Text{" There is an offence reported of the given `kind` happened at the `session_index` and", " (kind-specific) time slot. This event is not deposited for duplicate slashes.", " \\[kind, timeslot\\]."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil), Index: 0x16}, ModuleMetadataV13{Name: "Historical", HasStorage: false, Storage: StorageMetadataV13{Prefix: "", Items: []StorageFunctionMetadataV13(nil)}, HasCalls: false, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil), Index: 0x17}, ModuleMetadataV13{Name: "RandomnessCollectiveFlip", HasStorage: true, Storage: StorageMetadataV13{Prefix: "RandomnessCollectiveFlip", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "RandomMaterial", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<T::Hash>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Series of block headers from the last 81 blocks that acts as random seed material. This", " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of", " the oldest hash."}}}}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil), Index: 0x18}, ModuleMetadataV13{Name: "Identity", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Identity", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "IdentityOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "Registration<BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Information that is pertinent to identify the entity behind an account.", "", " TWOX-NOTE: OK ― `AccountId` is a secure hash."}}, StorageFunctionMetadataV13{Name: "SuperOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::AccountId", Value: "(T::AccountId, Data)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The super-identity of an alternative \"sub\" identity together with its name, within that", " context. If the account is not some other account's sub-identity, then just `None`."}}, StorageFunctionMetadataV13{Name: "SubsOf", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "(BalanceOf<T>, Vec<T::AccountId>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Alternative \"sub\" identities of this account.", "", " The first item is the deposit, the second is a vector of the accounts.", "", " TWOX-NOTE: OK ― `AccountId` is a secure hash."}}, StorageFunctionMetadataV13{Name: "Registrars", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<Option<RegistrarInfo<BalanceOf<T>, T::AccountId>>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The set of registrars. Not expected to get very big as can only be added through a", " special origin (likely a council motion).", "", " The index into this can be cast to `RegistrarIndex` to get a valid value."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "add_registrar", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "account", Type: "T::AccountId"}}, Documentation: []Text{" Add a registrar to the system.", "", " The dispatch origin for this call must be `T::RegistrarOrigin`.", "", " - `account`: the account of the registrar.", "", " Emits `RegistrarAdded` if successful.", "", " # <weight>", " - `O(R)` where `R` registrar-count (governance-bounded and code-bounded).", " - One storage mutation (codec `O(R)`).", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "set_identity", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "info", Type: "IdentityInfo"}}, Documentation: []Text{" Set an account's identity information and reserve the appropriate deposit.", "", " If the account already has identity information, the deposit is taken as part payment", " for the new deposit.", "", " The dispatch origin for this call must be _Signed_.", "", " - `info`: The identity information.", "", " Emits `IdentitySet` if successful.", "", " # <weight>", " - `O(X + X' + R)`", "   - where `X` additional-field-count (deposit-bounded and code-bounded)", "   - where `R` judgements-count (registrar-count-bounded)", " - One balance reserve operation.", " - One storage mutation (codec-read `O(X' + R)`, codec-write `O(X + R)`).", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "set_subs", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "subs", Type: "Vec<(T::AccountId, Data)>"}}, Documentation: []Text{" Set the sub-accounts of the sender.", "", " Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned", " and an amount `SubAccountDeposit` will be reserved for each item in `subs`.", "", " The dispatch origin for this call must be _Signed_ and the sender must have a registered", " identity.", "", " - `subs`: The identity's (new) sub-accounts.", "", " # <weight>", " - `O(P + S)`", "   - where `P` old-subs-count (hard- and deposit-bounded).", "   - where `S` subs-count (hard- and deposit-bounded).", " - At most one balance operations.", " - DB:", "   - `P + S` storage mutations (codec complexity `O(1)`)", "   - One storage read (codec complexity `O(P)`).", "   - One storage write (codec complexity `O(S)`).", "   - One storage-exists (`IdentityOf::contains_key`).", " # </weight>"}}, FunctionMetadataV4{Name: "clear_identity", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Clear an account's identity info and all sub-accounts and return all deposits.", "", " Payment: All reserved balances on the account are returned.", "", " The dispatch origin for this call must be _Signed_ and the sender must have a registered", " identity.", "", " Emits `IdentityCleared` if successful.", "", " # <weight>", " - `O(R + S + X)`", "   - where `R` registrar-count (governance-bounded).", "   - where `S` subs-count (hard- and deposit-bounded).", "   - where `X` additional-field-count (deposit-bounded and code-bounded).", " - One balance-unreserve operation.", " - `2` storage reads and `S + 2` storage deletions.", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "request_judgement", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "reg_index", Type: "Compact<RegistrarIndex>"}, FunctionArgumentMetadata{Name: "max_fee", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Request a judgement from a registrar.", "", " Payment: At most `max_fee` will be reserved for payment to the registrar if judgement", " given.", "", " The dispatch origin for this call must be _Signed_ and the sender must have a", " registered identity.", "", " - `reg_index`: The index of the registrar whose judgement is requested.", " - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:", "", " ```nocompile", " Self::registrars().get(reg_index).unwrap().fee", " ```", "", " Emits `JudgementRequested` if successful.", "", " # <weight>", " - `O(R + X)`.", " - One balance-reserve operation.", " - Storage: 1 read `O(R)`, 1 mutate `O(X + R)`.", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "cancel_request", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "reg_index", Type: "RegistrarIndex"}}, Documentation: []Text{" Cancel a previous request.", "", " Payment: A previously reserved deposit is returned on success.", "", " The dispatch origin for this call must be _Signed_ and the sender must have a", " registered identity.", "", " - `reg_index`: The index of the registrar whose judgement is no longer requested.", "", " Emits `JudgementUnrequested` if successful.", "", " # <weight>", " - `O(R + X)`.", " - One balance-reserve operation.", " - One storage mutation `O(R + X)`.", " - One event", " # </weight>"}}, FunctionMetadataV4{Name: "set_fee", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "Compact<RegistrarIndex>"}, FunctionArgumentMetadata{Name: "fee", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Set the fee required for a judgement to be requested from a registrar.", "", " The dispatch origin for this call must be _Signed_ and the sender must be the account", " of the registrar whose index is `index`.", "", " - `index`: the index of the registrar whose fee is to be set.", " - `fee`: the new fee.", "", " # <weight>", " - `O(R)`.", " - One storage mutation `O(R)`.", " - Benchmark: 7.315 + R * 0.329 µs (min squares analysis)", " # </weight>"}}, FunctionMetadataV4{Name: "set_account_id", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "Compact<RegistrarIndex>"}, FunctionArgumentMetadata{Name: "new", Type: "T::AccountId"}}, Documentation: []Text{" Change the account associated with a registrar.", "", " The dispatch origin for this call must be _Signed_ and the sender must be the account", " of the registrar whose index is `index`.", "", " - `index`: the index of the registrar whose fee is to be set.", " - `new`: the new account ID.", "", " # <weight>", " - `O(R)`.", " - One storage mutation `O(R)`.", " - Benchmark: 8.823 + R * 0.32 µs (min squares analysis)", " # </weight>"}}, FunctionMetadataV4{Name: "set_fields", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "Compact<RegistrarIndex>"}, FunctionArgumentMetadata{Name: "fields", Type: "IdentityFields"}}, Documentation: []Text{" Set the field information for a registrar.", "", " The dispatch origin for this call must be _Signed_ and the sender must be the account", " of the registrar whose index is `index`.", "", " - `index`: the index of the registrar whose fee is to be set.", " - `fields`: the fields that the registrar concerns themselves with.", "", " # <weight>", " - `O(R)`.", " - One storage mutation `O(R)`.", " - Benchmark: 7.464 + R * 0.325 µs (min squares analysis)", " # </weight>"}}, FunctionMetadataV4{Name: "provide_judgement", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "reg_index", Type: "Compact<RegistrarIndex>"}, FunctionArgumentMetadata{Name: "target", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "judgement", Type: "Judgement<BalanceOf<T>>"}}, Documentation: []Text{" Provide a judgement for an account's identity.", "", " The dispatch origin for this call must be _Signed_ and the sender must be the account", " of the registrar whose index is `reg_index`.", "", " - `reg_index`: the index of the registrar whose judgement is being made.", " - `target`: the account whose identity the judgement is upon. This must be an account", "   with a registered identity.", " - `judgement`: the judgement of the registrar of index `reg_index` about `target`.", "", " Emits `JudgementGiven` if successful.", "", " # <weight>", " - `O(R + X)`.", " - One balance-transfer operation.", " - Up to one account-lookup operation.", " - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "kill_identity", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "target", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Remove an account's identity and sub-account information and slash the deposits.", "", " Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by", " `Slash`. Verification request deposits are not returned; they should be cancelled", " manually using `cancel_request`.", "", " The dispatch origin for this call must match `T::ForceOrigin`.", "", " - `target`: the account whose identity the judgement is upon. This must be an account", "   with a registered identity.", "", " Emits `IdentityKilled` if successful.", "", " # <weight>", " - `O(R + S + X)`.", " - One balance-reserve operation.", " - `S + 2` storage mutations.", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "add_sub", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "sub", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "data", Type: "Data"}}, Documentation: []Text{" Add the given account to the sender's subs.", "", " Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated", " to the sender.", "", " The dispatch origin for this call must be _Signed_ and the sender must have a registered", " sub identity of `sub`."}}, FunctionMetadataV4{Name: "rename_sub", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "sub", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "data", Type: "Data"}}, Documentation: []Text{" Alter the associated name of the given sub-account.", "", " The dispatch origin for this call must be _Signed_ and the sender must have a registered", " sub identity of `sub`."}}, FunctionMetadataV4{Name: "remove_sub", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "sub", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Remove the given account from the sender's subs.", "", " Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated", " to the sender.", "", " The dispatch origin for this call must be _Signed_ and the sender must have a registered", " sub identity of `sub`."}}, FunctionMetadataV4{Name: "quit_sub", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Remove the sender as a sub-account.", "", " Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated", " to the sender (*not* the original depositor).", "", " The dispatch origin for this call must be _Signed_ and the sender must have a registered", " super-identity.", "", " NOTE: This should not normally be used, but is provided in the case that the non-", " controller of an account is maliciously registered as a sub-account."}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "IdentitySet", Args: []Type{"AccountId"}, Documentation: []Text{" A name was set or reset (which will remove all judgements). \\[who\\]"}}, EventMetadataV4{Name: "IdentityCleared", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" A name was cleared, and the given balance returned. \\[who, deposit\\]"}}, EventMetadataV4{Name: "IdentityKilled", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" A name was removed and the given balance slashed. \\[who, deposit\\]"}}, EventMetadataV4{Name: "JudgementRequested", Args: []Type{"AccountId", "RegistrarIndex"}, Documentation: []Text{" A judgement was asked from a registrar. \\[who, registrar_index\\]"}}, EventMetadataV4{Name: "JudgementUnrequested", Args: []Type{"AccountId", "RegistrarIndex"}, Documentation: []Text{" A judgement request was retracted. \\[who, registrar_index\\]"}}, EventMetadataV4{Name: "JudgementGiven", Args: []Type{"AccountId", "RegistrarIndex"}, Documentation: []Text{" A judgement was given by a registrar. \\[target, registrar_index\\]"}}, EventMetadataV4{Name: "RegistrarAdded", Args: []Type{"RegistrarIndex"}, Documentation: []Text{" A registrar was added. \\[registrar_index\\]"}}, EventMetadataV4{Name: "SubIdentityAdded", Args: []Type{"AccountId", "AccountId", "Balance"}, Documentation: []Text{" A sub-identity was added to an identity and the deposit paid. \\[sub, main, deposit\\]"}}, EventMetadataV4{Name: "SubIdentityRemoved", Args: []Type{"AccountId", "AccountId", "Balance"}, Documentation: []Text{" A sub-identity was removed from an identity and the deposit freed.", " \\[sub, main, deposit\\]"}}, EventMetadataV4{Name: "SubIdentityRevoked", Args: []Type{"AccountId", "AccountId", "Balance"}, Documentation: []Text{" A sub-identity was cleared, and the given deposit repatriated from the", " main identity account to the sub-identity account. \\[sub, main, deposit\\]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "BasicDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x80, 0xc6, 0xa4, 0x7e, 0x8d, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount held on deposit for a registered identity"}}, ModuleConstantMetadataV6{Name: "FieldDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0xa0, 0x31, 0xa9, 0x5f, 0xe3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount held on deposit per additional field for a registered identity."}}, ModuleConstantMetadataV6{Name: "SubAccountDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x80, 0xf4, 0x20, 0xe6, 0xb5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount held on deposit for a registered subaccount. This should account for the fact", " that one storage item's value will increase by the size of an account ID, and there will be", " another trie item whose value is the size of an account ID plus 32 bytes."}}, ModuleConstantMetadataV6{Name: "MaxSubAccounts", Type: "u32", Value: Bytes{0x64, 0x0, 0x0, 0x0}, Documentation: []Text{" The maximum number of sub-accounts allowed per identified account."}}, ModuleConstantMetadataV6{Name: "MaxAdditionalFields", Type: "u32", Value: Bytes{0x64, 0x0, 0x0, 0x0}, Documentation: []Text{" Maximum number of additional fields that may be stored in an ID. Needed to bound the I/O", " required to access an identity, but can be pretty high."}}, ModuleConstantMetadataV6{Name: "MaxRegistrars", Type: "u32", Value: Bytes{0x14, 0x0, 0x0, 0x0}, Documentation: []Text{" Maxmimum number of registrars allowed in the system. Needed to bound the complexity", " of, e.g., updating judgements."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "TooManySubAccounts", Documentation: []Text{" Too many subs-accounts."}}, ErrorMetadataV8{Name: "NotFound", Documentation: []Text{" Account isn't found."}}, ErrorMetadataV8{Name: "NotNamed", Documentation: []Text{" Account isn't named."}}, ErrorMetadataV8{Name: "EmptyIndex", Documentation: []Text{" Empty index."}}, ErrorMetadataV8{Name: "FeeChanged", Documentation: []Text{" Fee is changed."}}, ErrorMetadataV8{Name: "NoIdentity", Documentation: []Text{" No identity found."}}, ErrorMetadataV8{Name: "StickyJudgement", Documentation: []Text{" Sticky judgement."}}, ErrorMetadataV8{Name: "JudgementGiven", Documentation: []Text{" Judgement given."}}, ErrorMetadataV8{Name: "InvalidJudgement", Documentation: []Text{" Invalid judgement."}}, ErrorMetadataV8{Name: "InvalidIndex", Documentation: []Text{" The index is invalid."}}, ErrorMetadataV8{Name: "InvalidTarget", Documentation: []Text{" The target is invalid."}}, ErrorMetadataV8{Name: "TooManyFields", Documentation: []Text{" Too many additional fields."}}, ErrorMetadataV8{Name: "TooManyRegistrars", Documentation: []Text{" Maximum amount of registrars reached. Cannot add any more."}}, ErrorMetadataV8{Name: "AlreadyClaimed", Documentation: []Text{" Account ID is already named."}}, ErrorMetadataV8{Name: "NotSub", Documentation: []Text{" Sender is not a sub-account."}}, ErrorMetadataV8{Name: "NotOwned", Documentation: []Text{" Sub-account isn't owned by sender."}}}, Index: 0x19}, ModuleMetadataV13{Name: "Society", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Society", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Founder", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The first member."}}, StorageFunctionMetadataV13{Name: "Rules", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "T::Hash", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" A hash of the rules of this society concerning membership. Can only be set once and", " only by the founder."}}, StorageFunctionMetadataV13{Name: "Candidates", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<Bid<T::AccountId, BalanceOf<T, I>>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current set of candidates; bidders that are attempting to become members."}}, StorageFunctionMetadataV13{Name: "SuspendedCandidates", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "(BalanceOf<T, I>, BidKind<T::AccountId, BalanceOf<T, I>>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The set of suspended candidates."}}, StorageFunctionMetadataV13{Name: "Pot", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "BalanceOf<T, I>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Amount of our account balance that is specifically for the next round's bid(s)."}}, StorageFunctionMetadataV13{Name: "Head", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The most primary from the most recently approved members."}}, StorageFunctionMetadataV13{Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current set of members, ordered."}}, StorageFunctionMetadataV13{Name: "SuspendedMembers", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "bool", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The set of suspended members."}}, StorageFunctionMetadataV13{Name: "Bids", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<Bid<T::AccountId, BalanceOf<T, I>>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current bids, stored ordered by the value of the bid."}}, StorageFunctionMetadataV13{Name: "Vouching", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "VouchingStatus", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Members currently vouching or banned from vouching again"}}, StorageFunctionMetadataV13{Name: "Payouts", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "Vec<(T::BlockNumber, BalanceOf<T, I>)>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Pending payouts; ordered by block number, with the amount that should be paid out."}}, StorageFunctionMetadataV13{Name: "Strikes", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "StrikeCount", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The ongoing number of losing votes cast by the member."}}, StorageFunctionMetadataV13{Name: "Votes", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "T::AccountId", Key2: "T::AccountId", Value: "Vote", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Double map from Candidate -> Voter -> (Maybe) Vote."}}, StorageFunctionMetadataV13{Name: "Defender", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The defending member currently being challenged."}}, StorageFunctionMetadataV13{Name: "DefenderVotes", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "Vote", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Votes for the defender."}}, StorageFunctionMetadataV13{Name: "MaxMembers", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The max number of members for the society at one time."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "bid", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "value", Type: "BalanceOf<T, I>"}}, Documentation: []Text{" A user outside of the society can make a bid for entry.", "", " Payment: `CandidateDeposit` will be reserved for making a bid. It is returned", " when the bid becomes a member, or if the bid calls `unbid`.", "", " The dispatch origin for this call must be _Signed_.", "", " Parameters:", " - `value`: A one time payment the bid would like to receive when joining the society.", "", " # <weight>", " Key: B (len of bids), C (len of candidates), M (len of members), X (balance reserve)", " - Storage Reads:", " \t- One storage read to check for suspended candidate. O(1)", " \t- One storage read to check for suspended member. O(1)", " \t- One storage read to retrieve all current bids. O(B)", " \t- One storage read to retrieve all current candidates. O(C)", " \t- One storage read to retrieve all members. O(M)", " - Storage Writes:", " \t- One storage mutate to add a new bid to the vector O(B) (TODO: possible optimization w/ read)", " \t- Up to one storage removal if bid.len() > MAX_BID_COUNT. O(1)", " - Notable Computation:", " \t- O(B + C + log M) search to check user is not already a part of society.", " \t- O(log B) search to insert the new bid sorted.", " - External Module Operations:", " \t- One balance reserve operation. O(X)", " \t- Up to one balance unreserve operation if bids.len() > MAX_BID_COUNT.", " - Events:", " \t- One event for new bid.", " \t- Up to one event for AutoUnbid if bid.len() > MAX_BID_COUNT.", "", " Total Complexity: O(M + B + C + logM + logB + X)", " # </weight>"}}, FunctionMetadataV4{Name: "unbid", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "pos", Type: "u32"}}, Documentation: []Text{" A bidder can remove their bid for entry into society.", " By doing so, they will have their candidate deposit returned or", " they will unvouch their voucher.", "", " Payment: The bid deposit is unreserved if the user made a bid.", "", " The dispatch origin for this call must be _Signed_ and a bidder.", "", " Parameters:", " - `pos`: Position in the `Bids` vector of the bid who wants to unbid.", "", " # <weight>", " Key: B (len of bids), X (balance unreserve)", " - One storage read and write to retrieve and update the bids. O(B)", " - Either one unreserve balance action O(X) or one vouching storage removal. O(1)", " - One event.", "", " Total Complexity: O(B + X)", " # </weight>"}}, FunctionMetadataV4{Name: "vouch", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "value", Type: "BalanceOf<T, I>"}, FunctionArgumentMetadata{Name: "tip", Type: "BalanceOf<T, I>"}}, Documentation: []Text{" As a member, vouch for someone to join society by placing a bid on their behalf.", "", " There is no deposit required to vouch for a new bid, but a member can only vouch for", " one bid at a time. If the bid becomes a suspended candidate and ultimately rejected by", " the suspension judgement origin, the member will be banned from vouching again.", "", " As a vouching member, you can claim a tip if the candidate is accepted. This tip will", " be paid as a portion of the reward the member will receive for joining the society.", "", " The dispatch origin for this call must be _Signed_ and a member.", "", " Parameters:", " - `who`: The user who you would like to vouch for.", " - `value`: The total reward to be paid between you and the candidate if they become", " a member in the society.", " - `tip`: Your cut of the total `value` payout when the candidate is inducted into", " the society. Tips larger than `value` will be saturated upon payout.", "", " # <weight>", " Key: B (len of bids), C (len of candidates), M (len of members)", " - Storage Reads:", " \t- One storage read to retrieve all members. O(M)", " \t- One storage read to check member is not already vouching. O(1)", " \t- One storage read to check for suspended candidate. O(1)", " \t- One storage read to check for suspended member. O(1)", " \t- One storage read to retrieve all current bids. O(B)", " \t- One storage read to retrieve all current candidates. O(C)", " - Storage Writes:", " \t- One storage write to insert vouching status to the member. O(1)", " \t- One storage mutate to add a new bid to the vector O(B) (TODO: possible optimization w/ read)", " \t- Up to one storage removal if bid.len() > MAX_BID_COUNT. O(1)", " - Notable Computation:", " \t- O(log M) search to check sender is a member.", " \t- O(B + C + log M) search to check user is not already a part of society.", " \t- O(log B) search to insert the new bid sorted.", " - External Module Operations:", " \t- One balance reserve operation. O(X)", " \t- Up to one balance unreserve operation if bids.len() > MAX_BID_COUNT.", " - Events:", " \t- One event for vouch.", " \t- Up to one event for AutoUnbid if bid.len() > MAX_BID_COUNT.", "", " Total Complexity: O(M + B + C + logM + logB + X)", " # </weight>"}}, FunctionMetadataV4{Name: "unvouch", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "pos", Type: "u32"}}, Documentation: []Text{" As a vouching member, unvouch a bid. This only works while vouched user is", " only a bidder (and not a candidate).", "", " The dispatch origin for this call must be _Signed_ and a vouching member.", "", " Parameters:", " - `pos`: Position in the `Bids` vector of the bid who should be unvouched.", "", " # <weight>", " Key: B (len of bids)", " - One storage read O(1) to check the signer is a vouching member.", " - One storage mutate to retrieve and update the bids. O(B)", " - One vouching storage removal. O(1)", " - One event.", "", " Total Complexity: O(B)", " # </weight>"}}, FunctionMetadataV4{Name: "vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "candidate", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "approve", Type: "bool"}}, Documentation: []Text{" As a member, vote on a candidate.", "", " The dispatch origin for this call must be _Signed_ and a member.", "", " Parameters:", " - `candidate`: The candidate that the member would like to bid on.", " - `approve`: A boolean which says if the candidate should be", "              approved (`true`) or rejected (`false`).", "", " # <weight>", " Key: C (len of candidates), M (len of members)", " - One storage read O(M) and O(log M) search to check user is a member.", " - One account lookup.", " - One storage read O(C) and O(C) search to check that user is a candidate.", " - One storage write to add vote to votes. O(1)", " - One event.", "", " Total Complexity: O(M + logM + C)", " # </weight>"}}, FunctionMetadataV4{Name: "defender_vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "approve", Type: "bool"}}, Documentation: []Text{" As a member, vote on the defender.", "", " The dispatch origin for this call must be _Signed_ and a member.", "", " Parameters:", " - `approve`: A boolean which says if the candidate should be", " approved (`true`) or rejected (`false`).", "", " # <weight>", " - Key: M (len of members)", " - One storage read O(M) and O(log M) search to check user is a member.", " - One storage write to add vote to votes. O(1)", " - One event.", "", " Total Complexity: O(M + logM)", " # </weight>"}}, FunctionMetadataV4{Name: "payout", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Transfer the first matured payout for the sender and remove it from the records.", "", " NOTE: This extrinsic needs to be called multiple times to claim multiple matured payouts.", "", " Payment: The member will receive a payment equal to their first matured", " payout to their free balance.", "", " The dispatch origin for this call must be _Signed_ and a member with", " payouts remaining.", "", " # <weight>", " Key: M (len of members), P (number of payouts for a particular member)", " - One storage read O(M) and O(log M) search to check signer is a member.", " - One storage read O(P) to get all payouts for a member.", " - One storage read O(1) to get the current block number.", " - One currency transfer call. O(X)", " - One storage write or removal to update the member's payouts. O(P)", "", " Total Complexity: O(M + logM + P + X)", " # </weight>"}}, FunctionMetadataV4{Name: "found", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "founder", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "max_members", Type: "u32"}, FunctionArgumentMetadata{Name: "rules", Type: "Vec<u8>"}}, Documentation: []Text{" Found the society.", "", " This is done as a discrete action in order to allow for the", " module to be included into a running chain and can only be done once.", "", " The dispatch origin for this call must be from the _FounderSetOrigin_.", "", " Parameters:", " - `founder` - The first member and head of the newly founded society.", " - `max_members` - The initial max number of members for the society.", " - `rules` - The rules of this society concerning membership.", "", " # <weight>", " - Two storage mutates to set `Head` and `Founder`. O(1)", " - One storage write to add the first member to society. O(1)", " - One event.", "", " Total Complexity: O(1)", " # </weight>"}}, FunctionMetadataV4{Name: "unfound", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Annul the founding of the society.", "", " The dispatch origin for this call must be Signed, and the signing account must be both", " the `Founder` and the `Head`. This implies that it may only be done when there is one", " member.", "", " # <weight>", " - Two storage reads O(1).", " - Four storage removals O(1).", " - One event.", "", " Total Complexity: O(1)", " # </weight>"}}, FunctionMetadataV4{Name: "judge_suspended_member", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "forgive", Type: "bool"}}, Documentation: []Text{" Allow suspension judgement origin to make judgement on a suspended member.", "", " If a suspended member is forgiven, we simply add them back as a member, not affecting", " any of the existing storage items for that member.", "", " If a suspended member is rejected, remove all associated storage items, including", " their payouts, and remove any vouched bids they currently have.", "", " The dispatch origin for this call must be from the _SuspensionJudgementOrigin_.", "", " Parameters:", " - `who` - The suspended member to be judged.", " - `forgive` - A boolean representing whether the suspension judgement origin", "               forgives (`true`) or rejects (`false`) a suspended member.", "", " # <weight>", " Key: B (len of bids), M (len of members)", " - One storage read to check `who` is a suspended member. O(1)", " - Up to one storage write O(M) with O(log M) binary search to add a member back to society.", " - Up to 3 storage removals O(1) to clean up a removed member.", " - Up to one storage write O(B) with O(B) search to remove vouched bid from bids.", " - Up to one additional event if unvouch takes place.", " - One storage removal. O(1)", " - One event for the judgement.", "", " Total Complexity: O(M + logM + B)", " # </weight>"}}, FunctionMetadataV4{Name: "judge_suspended_candidate", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "judgement", Type: "Judgement"}}, Documentation: []Text{" Allow suspended judgement origin to make judgement on a suspended candidate.", "", " If the judgement is `Approve`, we add them to society as a member with the appropriate", " payment for joining society.", "", " If the judgement is `Reject`, we either slash the deposit of the bid, giving it back", " to the society treasury, or we ban the voucher from vouching again.", "", " If the judgement is `Rebid`, we put the candidate back in the bid pool and let them go", " through the induction process again.", "", " The dispatch origin for this call must be from the _SuspensionJudgementOrigin_.", "", " Parameters:", " - `who` - The suspended candidate to be judged.", " - `judgement` - `Approve`, `Reject`, or `Rebid`.", "", " # <weight>", " Key: B (len of bids), M (len of members), X (balance action)", " - One storage read to check `who` is a suspended candidate.", " - One storage removal of the suspended candidate.", " - Approve Logic", " \t- One storage read to get the available pot to pay users with. O(1)", " \t- One storage write to update the available pot. O(1)", " \t- One storage read to get the current block number. O(1)", " \t- One storage read to get all members. O(M)", " \t- Up to one unreserve currency action.", " \t- Up to two new storage writes to payouts.", " \t- Up to one storage write with O(log M) binary search to add a member to society.", " - Reject Logic", " \t- Up to one repatriate reserved currency action. O(X)", " \t- Up to one storage write to ban the vouching member from vouching again.", " - Rebid Logic", " \t- Storage mutate with O(log B) binary search to place the user back into bids.", " - Up to one additional event if unvouch takes place.", " - One storage removal.", " - One event for the judgement.", "", " Total Complexity: O(M + logM + B + X)", " # </weight>"}}, FunctionMetadataV4{Name: "set_max_members", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "max", Type: "u32"}}, Documentation: []Text{" Allows root origin to change the maximum number of members in society.", " Max membership count must be greater than 1.", "", " The dispatch origin for this call must be from _ROOT_.", "", " Parameters:", " - `max` - The maximum number of members for the society.", "", " # <weight>", " - One storage write to update the max. O(1)", " - One event.", "", " Total Complexity: O(1)", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Founded", Args: []Type{"AccountId"}, Documentation: []Text{" The society is founded by the given identity. \\[founder\\]"}}, EventMetadataV4{Name: "Bid", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" A membership bid just happened. The given account is the candidate's ID and their offer", " is the second. \\[candidate_id, offer\\]"}}, EventMetadataV4{Name: "Vouch", Args: []Type{"AccountId", "Balance", "AccountId"}, Documentation: []Text{" A membership bid just happened by vouching. The given account is the candidate's ID and", " their offer is the second. The vouching party is the third. \\[candidate_id, offer, vouching\\]"}}, EventMetadataV4{Name: "AutoUnbid", Args: []Type{"AccountId"}, Documentation: []Text{" A \\[candidate\\] was dropped (due to an excess of bids in the system)."}}, EventMetadataV4{Name: "Unbid", Args: []Type{"AccountId"}, Documentation: []Text{" A \\[candidate\\] was dropped (by their request)."}}, EventMetadataV4{Name: "Unvouch", Args: []Type{"AccountId"}, Documentation: []Text{" A \\[candidate\\] was dropped (by request of who vouched for them)."}}, EventMetadataV4{Name: "Inducted", Args: []Type{"AccountId", "Vec<AccountId>"}, Documentation: []Text{" A group of candidates have been inducted. The batch's primary is the first value, the", " batch in full is the second. \\[primary, candidates\\]"}}, EventMetadataV4{Name: "SuspendedMemberJudgement", Args: []Type{"AccountId", "bool"}, Documentation: []Text{" A suspended member has been judged. \\[who, judged\\]"}}, EventMetadataV4{Name: "CandidateSuspended", Args: []Type{"AccountId"}, Documentation: []Text{" A \\[candidate\\] has been suspended"}}, EventMetadataV4{Name: "MemberSuspended", Args: []Type{"AccountId"}, Documentation: []Text{" A \\[member\\] has been suspended"}}, EventMetadataV4{Name: "Challenged", Args: []Type{"AccountId"}, Documentation: []Text{" A \\[member\\] has been challenged"}}, EventMetadataV4{Name: "Vote", Args: []Type{"AccountId", "AccountId", "bool"}, Documentation: []Text{" A vote has been placed \\[candidate, voter, vote\\]"}}, EventMetadataV4{Name: "DefenderVote", Args: []Type{"AccountId", "bool"}, Documentation: []Text{" A vote has been placed for a defending member \\[voter, vote\\]"}}, EventMetadataV4{Name: "NewMaxMembers", Args: []Type{"u32"}, Documentation: []Text{" A new \\[max\\] member count has been set"}}, EventMetadataV4{Name: "Unfounded", Args: []Type{"AccountId"}, Documentation: []Text{" Society is unfounded. \\[founder\\]"}}, EventMetadataV4{Name: "Deposit", Args: []Type{"Balance"}, Documentation: []Text{" Some funds were deposited into the society account. \\[value\\]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "CandidateDeposit", Type: "BalanceOf<T, I>", Value: Bytes{0x0, 0x80, 0xc6, 0xa4, 0x7e, 0x8d, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount of a deposit required for a bid to be made."}}, ModuleConstantMetadataV6{Name: "WrongSideDeduction", Type: "BalanceOf<T, I>", Value: Bytes{0x0, 0x80, 0xf4, 0x20, 0xe6, 0xb5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of the unpaid reward that gets deducted in the case that either a skeptic", " doesn't vote or someone votes in the wrong way."}}, ModuleConstantMetadataV6{Name: "MaxStrikes", Type: "u32", Value: Bytes{0xa, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of times a member may vote the wrong way (or not at all, when they are a skeptic)", " before they become suspended."}}, ModuleConstantMetadataV6{Name: "PeriodSpend", Type: "BalanceOf<T, I>", Value: Bytes{0x0, 0x0, 0xc5, 0x2e, 0xbc, 0xa2, 0xb1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of incentive paid within each period. Doesn't include VoterTip."}}, ModuleConstantMetadataV6{Name: "RotationPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x77, 0x1, 0x0}, Documentation: []Text{" The number of blocks between candidate/membership rotation periods."}}, ModuleConstantMetadataV6{Name: "ChallengePeriod", Type: "T::BlockNumber", Value: Bytes{0x80, 0x13, 0x3, 0x0}, Documentation: []Text{" The number of blocks between membership challenges."}}, ModuleConstantMetadataV6{Name: "PalletId", Type: "PalletId", Value: Bytes{0x70, 0x79, 0x2f, 0x73, 0x6f, 0x63, 0x69, 0x65}, Documentation: []Text{" The societies's module id"}}, ModuleConstantMetadataV6{Name: "MaxCandidateIntake", Type: "u32", Value: Bytes{0xa, 0x0, 0x0, 0x0}, Documentation: []Text{" Maximum candidate intake per round."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "BadPosition", Documentation: []Text{" An incorrect position was provided."}}, ErrorMetadataV8{Name: "NotMember", Documentation: []Text{" User is not a member."}}, ErrorMetadataV8{Name: "AlreadyMember", Documentation: []Text{" User is already a member."}}, ErrorMetadataV8{Name: "Suspended", Documentation: []Text{" User is suspended."}}, ErrorMetadataV8{Name: "NotSuspended", Documentation: []Text{" User is not suspended."}}, ErrorMetadataV8{Name: "NoPayout", Documentation: []Text{" Nothing to payout."}}, ErrorMetadataV8{Name: "AlreadyFounded", Documentation: []Text{" Society already founded."}}, ErrorMetadataV8{Name: "InsufficientPot", Documentation: []Text{" Not enough in pot to accept candidate."}}, ErrorMetadataV8{Name: "AlreadyVouching", Documentation: []Text{" Member is already vouching or banned from vouching again."}}, ErrorMetadataV8{Name: "NotVouching", Documentation: []Text{" Member is not vouching."}}, ErrorMetadataV8{Name: "Head", Documentation: []Text{" Cannot remove the head of the chain."}}, ErrorMetadataV8{Name: "Founder", Documentation: []Text{" Cannot remove the founder."}}, ErrorMetadataV8{Name: "AlreadyBid", Documentation: []Text{" User has already made a bid."}}, ErrorMetadataV8{Name: "AlreadyCandidate", Documentation: []Text{" User is already a candidate."}}, ErrorMetadataV8{Name: "NotCandidate", Documentation: []Text{" User is not a candidate."}}, ErrorMetadataV8{Name: "MaxMembers", Documentation: []Text{" Too many members in the society."}}, ErrorMetadataV8{Name: "NotFounder", Documentation: []Text{" The caller is not the founder."}}, ErrorMetadataV8{Name: "NotHead", Documentation: []Text{" The caller is not the head."}}}, Index: 0x1a}, ModuleMetadataV13{Name: "Recovery", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Recovery", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Recoverable", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "RecoveryConfig<T::BlockNumber, BalanceOf<T>, T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The set of recoverable accounts and their recovery configuration."}}, StorageFunctionMetadataV13{Name: "ActiveRecoveries", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "T::AccountId", Key2: "T::AccountId", Value: "ActiveRecovery<T::BlockNumber, BalanceOf<T>, T::AccountId>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Active recovery attempts.", "", " First account is the account to be recovered, and the second account", " is the user trying to recover the account."}}, StorageFunctionMetadataV13{Name: "Proxy", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::AccountId", Value: "T::AccountId", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The list of allowed proxy accounts.", "", " Map from the user who can access it to the recovered account."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "as_recovered", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "account", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Config>::Call>"}}, Documentation: []Text{" Send a call through a recovered account.", "", " The dispatch origin for this call must be _Signed_ and registered to", " be able to make calls on behalf of the recovered account.", "", " Parameters:", " - `account`: The recovered account you want to make a call on-behalf-of.", " - `call`: The call you want to make with the recovered account.", "", " # <weight>", " - The weight of the `call` + 10,000.", " - One storage lookup to check account is recovered by `who`. O(1)", " # </weight>"}}, FunctionMetadataV4{Name: "set_recovered", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "lost", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "rescuer", Type: "T::AccountId"}}, Documentation: []Text{" Allow ROOT to bypass the recovery process and set an a rescuer account", " for a lost account directly.", "", " The dispatch origin for this call must be _ROOT_.", "", " Parameters:", " - `lost`: The \"lost account\" to be recovered.", " - `rescuer`: The \"rescuer account\" which can call as the lost account.", "", " # <weight>", " - One storage write O(1)", " - One event", " # </weight>"}}, FunctionMetadataV4{Name: "create_recovery", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "friends", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "threshold", Type: "u16"}, FunctionArgumentMetadata{Name: "delay_period", Type: "T::BlockNumber"}}, Documentation: []Text{" Create a recovery configuration for your account. This makes your account recoverable.", "", " Payment: `ConfigDepositBase` + `FriendDepositFactor` * #_of_friends balance", " will be reserved for storing the recovery configuration. This deposit is returned", " in full when the user calls `remove_recovery`.", "", " The dispatch origin for this call must be _Signed_.", "", " Parameters:", " - `friends`: A list of friends you trust to vouch for recovery attempts.", "   Should be ordered and contain no duplicate values.", " - `threshold`: The number of friends that must vouch for a recovery attempt", "   before the account can be recovered. Should be less than or equal to", "   the length of the list of friends.", " - `delay_period`: The number of blocks after a recovery attempt is initialized", "   that needs to pass before the account can be recovered.", "", " # <weight>", " - Key: F (len of friends)", " - One storage read to check that account is not already recoverable. O(1).", " - A check that the friends list is sorted and unique. O(F)", " - One currency reserve operation. O(X)", " - One storage write. O(1). Codec O(F).", " - One event.", "", " Total Complexity: O(F + X)", " # </weight>"}}, FunctionMetadataV4{Name: "initiate_recovery", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "account", Type: "T::AccountId"}}, Documentation: []Text{" Initiate the process for recovering a recoverable account.", "", " Payment: `RecoveryDeposit` balance will be reserved for initiating the", " recovery process. This deposit will always be repatriated to the account", " trying to be recovered. See `close_recovery`.", "", " The dispatch origin for this call must be _Signed_.", "", " Parameters:", " - `account`: The lost account that you want to recover. This account", "   needs to be recoverable (i.e. have a recovery configuration).", "", " # <weight>", " - One storage read to check that account is recoverable. O(F)", " - One storage read to check that this recovery process hasn't already started. O(1)", " - One currency reserve operation. O(X)", " - One storage read to get the current block number. O(1)", " - One storage write. O(1).", " - One event.", "", " Total Complexity: O(F + X)", " # </weight>"}}, FunctionMetadataV4{Name: "vouch_recovery", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "lost", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "rescuer", Type: "T::AccountId"}}, Documentation: []Text{" Allow a \"friend\" of a recoverable account to vouch for an active recovery", " process for that account.", "", " The dispatch origin for this call must be _Signed_ and must be a \"friend\"", " for the recoverable account.", "", " Parameters:", " - `lost`: The lost account that you want to recover.", " - `rescuer`: The account trying to rescue the lost account that you", "   want to vouch for.", "", " The combination of these two parameters must point to an active recovery", " process.", "", " # <weight>", " Key: F (len of friends in config), V (len of vouching friends)", " - One storage read to get the recovery configuration. O(1), Codec O(F)", " - One storage read to get the active recovery process. O(1), Codec O(V)", " - One binary search to confirm caller is a friend. O(logF)", " - One binary search to confirm caller has not already vouched. O(logV)", " - One storage write. O(1), Codec O(V).", " - One event.", "", " Total Complexity: O(F + logF + V + logV)", " # </weight>"}}, FunctionMetadataV4{Name: "claim_recovery", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "account", Type: "T::AccountId"}}, Documentation: []Text{" Allow a successful rescuer to claim their recovered account.", "", " The dispatch origin for this call must be _Signed_ and must be a \"rescuer\"", " who has successfully completed the account recovery process: collected", " `threshold` or more vouches, waited `delay_period` blocks since initiation.", "", " Parameters:", " - `account`: The lost account that you want to claim has been successfully", "   recovered by you.", "", " # <weight>", " Key: F (len of friends in config), V (len of vouching friends)", " - One storage read to get the recovery configuration. O(1), Codec O(F)", " - One storage read to get the active recovery process. O(1), Codec O(V)", " - One storage read to get the current block number. O(1)", " - One storage write. O(1), Codec O(V).", " - One event.", "", " Total Complexity: O(F + V)", " # </weight>"}}, FunctionMetadataV4{Name: "close_recovery", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "rescuer", Type: "T::AccountId"}}, Documentation: []Text{" As the controller of a recoverable account, close an active recovery", " process for your account.", "", " Payment: By calling this function, the recoverable account will receive", " the recovery deposit `RecoveryDeposit` placed by the rescuer.", "", " The dispatch origin for this call must be _Signed_ and must be a", " recoverable account with an active recovery process for it.", "", " Parameters:", " - `rescuer`: The account trying to rescue this recoverable account.", "", " # <weight>", " Key: V (len of vouching friends)", " - One storage read/remove to get the active recovery process. O(1), Codec O(V)", " - One balance call to repatriate reserved. O(X)", " - One event.", "", " Total Complexity: O(V + X)", " # </weight>"}}, FunctionMetadataV4{Name: "remove_recovery", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Remove the recovery process for your account. Recovered accounts are still accessible.", "", " NOTE: The user must make sure to call `close_recovery` on all active", " recovery attempts before calling this function else it will fail.", "", " Payment: By calling this function the recoverable account will unreserve", " their recovery configuration deposit.", " (`ConfigDepositBase` + `FriendDepositFactor` * #_of_friends)", "", " The dispatch origin for this call must be _Signed_ and must be a", " recoverable account (i.e. has a recovery configuration).", "", " # <weight>", " Key: F (len of friends)", " - One storage read to get the prefix iterator for active recoveries. O(1)", " - One storage read/remove to get the recovery configuration. O(1), Codec O(F)", " - One balance call to unreserved. O(X)", " - One event.", "", " Total Complexity: O(F + X)", " # </weight>"}}, FunctionMetadataV4{Name: "cancel_recovered", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "account", Type: "T::AccountId"}}, Documentation: []Text{" Cancel the ability to use `as_recovered` for `account`.", "", " The dispatch origin for this call must be _Signed_ and registered to", " be able to make calls on behalf of the recovered account.", "", " Parameters:", " - `account`: The recovered account you are able to call on-behalf-of.", "", " # <weight>", " - One storage mutation to check account is recovered by `who`. O(1)", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "RecoveryCreated", Args: []Type{"AccountId"}, Documentation: []Text{" A recovery process has been set up for an \\[account\\]."}}, EventMetadataV4{Name: "RecoveryInitiated", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" A recovery process has been initiated for lost account by rescuer account.", " \\[lost, rescuer\\]"}}, EventMetadataV4{Name: "RecoveryVouched", Args: []Type{"AccountId", "AccountId", "AccountId"}, Documentation: []Text{" A recovery process for lost account by rescuer account has been vouched for by sender.", " \\[lost, rescuer, sender\\]"}}, EventMetadataV4{Name: "RecoveryClosed", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" A recovery process for lost account by rescuer account has been closed.", " \\[lost, rescuer\\]"}}, EventMetadataV4{Name: "AccountRecovered", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" Lost account has been successfully recovered by rescuer account.", " \\[lost, rescuer\\]"}}, EventMetadataV4{Name: "RecoveryRemoved", Args: []Type{"AccountId"}, Documentation: []Text{" A recovery process has been removed for an \\[account\\]."}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "ConfigDepositBase", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x63, 0x52, 0xbf, 0xc6, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The base amount of currency needed to reserve for creating a recovery configuration.", "", " This is held for an additional storage item whose value size is", " `2 + sizeof(BlockNumber, Balance)` bytes."}}, ModuleConstantMetadataV6{Name: "FriendDepositFactor", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x20, 0x3d, 0x88, 0x79, 0x2d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of currency needed per additional user when creating a recovery configuration.", "", " This is held for adding `sizeof(AccountId)` bytes more into a pre-existing storage value."}}, ModuleConstantMetadataV6{Name: "MaxFriends", Type: "u16", Value: Bytes{0x9, 0x0}, Documentation: []Text{" The maximum amount of friends allowed in a recovery configuration."}}, ModuleConstantMetadataV6{Name: "RecoveryDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x63, 0x52, 0xbf, 0xc6, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The base amount of currency needed to reserve for starting a recovery.", "", " This is primarily held for deterring malicious recovery attempts, and should", " have a value large enough that a bad actor would choose not to place this", " deposit. It also acts to fund additional storage item whose value size is", " `sizeof(BlockNumber, Balance + T * AccountId)` bytes. Where T is a configurable", " threshold."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "NotAllowed", Documentation: []Text{" User is not allowed to make a call on behalf of this account"}}, ErrorMetadataV8{Name: "ZeroThreshold", Documentation: []Text{" Threshold must be greater than zero"}}, ErrorMetadataV8{Name: "NotEnoughFriends", Documentation: []Text{" Friends list must be greater than zero and threshold"}}, ErrorMetadataV8{Name: "MaxFriends", Documentation: []Text{" Friends list must be less than max friends"}}, ErrorMetadataV8{Name: "NotSorted", Documentation: []Text{" Friends list must be sorted and free of duplicates"}}, ErrorMetadataV8{Name: "NotRecoverable", Documentation: []Text{" This account is not set up for recovery"}}, ErrorMetadataV8{Name: "AlreadyRecoverable", Documentation: []Text{" This account is already set up for recovery"}}, ErrorMetadataV8{Name: "AlreadyStarted", Documentation: []Text{" A recovery process has already started for this account"}}, ErrorMetadataV8{Name: "NotStarted", Documentation: []Text{" A recovery process has not started for this rescuer"}}, ErrorMetadataV8{Name: "NotFriend", Documentation: []Text{" This account is not a friend who can vouch"}}, ErrorMetadataV8{Name: "DelayPeriod", Documentation: []Text{" The friend must wait until the delay period to vouch for this recovery"}}, ErrorMetadataV8{Name: "AlreadyVouched", Documentation: []Text{" This user has already vouched for this recovery"}}, ErrorMetadataV8{Name: "Threshold", Documentation: []Text{" The threshold for recovering this account has not been met"}}, ErrorMetadataV8{Name: "StillActive", Documentation: []Text{" There are still active recovery attempts that need to be closed"}}, ErrorMetadataV8{Name: "AlreadyProxy", Documentation: []Text{" This account is already set up for recovery"}}, ErrorMetadataV8{Name: "BadState", Documentation: []Text{" Some internal state is broken."}}}, Index: 0x1b}, ModuleMetadataV13{Name: "Vesting", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Vesting", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Vesting", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::AccountId", Value: "VestingInfo<BalanceOf<T>, T::BlockNumber>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Information regarding the vesting of a given account."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "vest", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Unlock any vested funds of the sender account.", "", " The dispatch origin for this call must be _Signed_ and the sender must have funds still", " locked under this pallet.", "", " Emits either `VestingCompleted` or `VestingUpdated`.", "", " # <weight>", " - `O(1)`.", " - DbWeight: 2 Reads, 2 Writes", "     - Reads: Vesting Storage, Balances Locks, [Sender Account]", "     - Writes: Vesting Storage, Balances Locks, [Sender Account]", " # </weight>"}}, FunctionMetadataV4{Name: "vest_other", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "target", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Unlock any vested funds of a `target` account.", "", " The dispatch origin for this call must be _Signed_.", "", " - `target`: The account whose vested funds should be unlocked. Must have funds still", " locked under this pallet.", "", " Emits either `VestingCompleted` or `VestingUpdated`.", "", " # <weight>", " - `O(1)`.", " - DbWeight: 3 Reads, 3 Writes", "     - Reads: Vesting Storage, Balances Locks, Target Account", "     - Writes: Vesting Storage, Balances Locks, Target Account", " # </weight>"}}, FunctionMetadataV4{Name: "vested_transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "target", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "schedule", Type: "VestingInfo<BalanceOf<T>, T::BlockNumber>"}}, Documentation: []Text{" Create a vested transfer.", "", " The dispatch origin for this call must be _Signed_.", "", " - `target`: The account that should be transferred the vested funds.", " - `amount`: The amount of funds to transfer and will be vested.", " - `schedule`: The vesting schedule attached to the transfer.", "", " Emits `VestingCreated`.", "", " # <weight>", " - `O(1)`.", " - DbWeight: 3 Reads, 3 Writes", "     - Reads: Vesting Storage, Balances Locks, Target Account, [Sender Account]", "     - Writes: Vesting Storage, Balances Locks, Target Account, [Sender Account]", " # </weight>"}}, FunctionMetadataV4{Name: "force_vested_transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "source", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "target", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "schedule", Type: "VestingInfo<BalanceOf<T>, T::BlockNumber>"}}, Documentation: []Text{" Force a vested transfer.", "", " The dispatch origin for this call must be _Root_.", "", " - `source`: The account whose funds should be transferred.", " - `target`: The account that should be transferred the vested funds.", " - `amount`: The amount of funds to transfer and will be vested.", " - `schedule`: The vesting schedule attached to the transfer.", "", " Emits `VestingCreated`.", "", " # <weight>", " - `O(1)`.", " - DbWeight: 4 Reads, 4 Writes", "     - Reads: Vesting Storage, Balances Locks, Target Account, Source Account", "     - Writes: Vesting Storage, Balances Locks, Target Account, Source Account", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "VestingUpdated", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" The amount vested has been updated. This could indicate more funds are available. The", " balance given is the amount which is left unvested (and thus locked).", " \\[account, unvested\\]"}}, EventMetadataV4{Name: "VestingCompleted", Args: []Type{"AccountId"}, Documentation: []Text{" An \\[account\\] has become fully vested. No further vesting can happen."}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "MinVestedTransfer", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x0, 0xc1, 0x6f, 0xf2, 0x86, 0x23, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount transferred to call `vested_transfer`."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "NotVesting", Documentation: []Text{" The account given is not vesting."}}, ErrorMetadataV8{Name: "ExistingVestingSchedule", Documentation: []Text{" An existing vesting schedule already exists for this account that cannot be clobbered."}}, ErrorMetadataV8{Name: "AmountLow", Documentation: []Text{" Amount being transferred is too low to create a vesting schedule."}}}, Index: 0x1c}, ModuleMetadataV13{Name: "Scheduler", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Scheduler", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Agenda", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::BlockNumber", Value: "Vec<Option<Scheduled<<T as Config>::Call, T::BlockNumber, T::\nPalletsOrigin, T::AccountId>>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Items to be executed, indexed by the block number that they should be executed on."}}, StorageFunctionMetadataV13{Name: "Lookup", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "Vec<u8>", Value: "TaskAddress<T::BlockNumber>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Lookup from identity to the block number and index of the task."}}, StorageFunctionMetadataV13{Name: "StorageVersion", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Releases", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Storage version of the pallet.", "", " New networks start with last version."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "schedule", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "when", Type: "T::BlockNumber"}, FunctionArgumentMetadata{Name: "maybe_periodic", Type: "Option<schedule::Period<T::BlockNumber>>"}, FunctionArgumentMetadata{Name: "priority", Type: "schedule::Priority"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Config>::Call>"}}, Documentation: []Text{" Anonymously schedule a task.", "", " # <weight>", " - S = Number of already scheduled calls", " - Base Weight: 22.29 + .126 * S µs", " - DB Weight:", "     - Read: Agenda", "     - Write: Agenda", " - Will use base weight of 25 which should be good for up to 30 scheduled calls", " # </weight>"}}, FunctionMetadataV4{Name: "cancel", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "when", Type: "T::BlockNumber"}, FunctionArgumentMetadata{Name: "index", Type: "u32"}}, Documentation: []Text{" Cancel an anonymously scheduled task.", "", " # <weight>", " - S = Number of already scheduled calls", " - Base Weight: 22.15 + 2.869 * S µs", " - DB Weight:", "     - Read: Agenda", "     - Write: Agenda, Lookup", " - Will use base weight of 100 which should be good for up to 30 scheduled calls", " # </weight>"}}, FunctionMetadataV4{Name: "schedule_named", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Vec<u8>"}, FunctionArgumentMetadata{Name: "when", Type: "T::BlockNumber"}, FunctionArgumentMetadata{Name: "maybe_periodic", Type: "Option<schedule::Period<T::BlockNumber>>"}, FunctionArgumentMetadata{Name: "priority", Type: "schedule::Priority"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Config>::Call>"}}, Documentation: []Text{" Schedule a named task.", "", " # <weight>", " - S = Number of already scheduled calls", " - Base Weight: 29.6 + .159 * S µs", " - DB Weight:", "     - Read: Agenda, Lookup", "     - Write: Agenda, Lookup", " - Will use base weight of 35 which should be good for more than 30 scheduled calls", " # </weight>"}}, FunctionMetadataV4{Name: "cancel_named", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Vec<u8>"}}, Documentation: []Text{" Cancel a named scheduled task.", "", " # <weight>", " - S = Number of already scheduled calls", " - Base Weight: 24.91 + 2.907 * S µs", " - DB Weight:", "     - Read: Agenda, Lookup", "     - Write: Agenda, Lookup", " - Will use base weight of 100 which should be good for up to 30 scheduled calls", " # </weight>"}}, FunctionMetadataV4{Name: "schedule_after", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "after", Type: "T::BlockNumber"}, FunctionArgumentMetadata{Name: "maybe_periodic", Type: "Option<schedule::Period<T::BlockNumber>>"}, FunctionArgumentMetadata{Name: "priority", Type: "schedule::Priority"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Config>::Call>"}}, Documentation: []Text{" Anonymously schedule a task after a delay.", "", " # <weight>", " Same as [`schedule`].", " # </weight>"}}, FunctionMetadataV4{Name: "schedule_named_after", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Vec<u8>"}, FunctionArgumentMetadata{Name: "after", Type: "T::BlockNumber"}, FunctionArgumentMetadata{Name: "maybe_periodic", Type: "Option<schedule::Period<T::BlockNumber>>"}, FunctionArgumentMetadata{Name: "priority", Type: "schedule::Priority"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Config>::Call>"}}, Documentation: []Text{" Schedule a named task after a delay.", "", " # <weight>", " Same as [`schedule_named`].", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Scheduled", Args: []Type{"BlockNumber", "u32"}, Documentation: []Text{" Scheduled some task. \\[when, index\\]"}}, EventMetadataV4{Name: "Canceled", Args: []Type{"BlockNumber", "u32"}, Documentation: []Text{" Canceled some task. \\[when, index\\]"}}, EventMetadataV4{Name: "Dispatched", Args: []Type{"TaskAddress<BlockNumber>", "Option<Vec<u8>>", "DispatchResult"}, Documentation: []Text{" Dispatched some task. \\[task, id, result\\]"}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "FailedToSchedule", Documentation: []Text{" Failed to schedule a call"}}, ErrorMetadataV8{Name: "NotFound", Documentation: []Text{" Cannot find the scheduled call."}}, ErrorMetadataV8{Name: "TargetBlockNumberInPast", Documentation: []Text{" Given target block number is in the past."}}, ErrorMetadataV8{Name: "RescheduleNoChange", Documentation: []Text{" Reschedule failed because it does not change scheduled time."}}}, Index: 0x1d}, ModuleMetadataV13{Name: "Proxy", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Proxy", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Proxies", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "(BoundedVec<ProxyDefinition<T::AccountId, T::ProxyType, T::\n BlockNumber>, T::MaxProxies,>, BalanceOf<T>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The set of account proxies. Maps the account which has delegated to the accounts", " which are being delegated to, together with the amount held on deposit."}}, StorageFunctionMetadataV13{Name: "Announcements", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "(BoundedVec<Announcement<T::AccountId, CallHashOf<T>, T::\n BlockNumber>, T::MaxPending,>, BalanceOf<T>,)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The announcements made by the proxy (key)."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "proxy", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "real", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "force_proxy_type", Type: "Option<T::ProxyType>"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Config>::Call>"}}, Documentation: []Text{" Dispatch the given `call` from an account that the sender is authorised for through", " `add_proxy`.", "", " Removes any corresponding announcement(s).", "", " The dispatch origin for this call must be _Signed_.", "", " Parameters:", " - `real`: The account that the proxy will make a call on behalf of.", " - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.", " - `call`: The call to be made by the `real` account.", "", " # <weight>", " Weight is a function of the number of proxies the user has (P).", " # </weight>"}}, FunctionMetadataV4{Name: "add_proxy", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "delegate", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "proxy_type", Type: "T::ProxyType"}, FunctionArgumentMetadata{Name: "delay", Type: "T::BlockNumber"}}, Documentation: []Text{" Register a proxy account for the sender that is able to make calls on its behalf.", "", " The dispatch origin for this call must be _Signed_.", "", " Parameters:", " - `proxy`: The account that the `caller` would like to make a proxy.", " - `proxy_type`: The permissions allowed for this proxy account.", " - `delay`: The announcement period required of the initial proxy. Will generally be", " zero.", "", " # <weight>", " Weight is a function of the number of proxies the user has (P).", " # </weight>"}}, FunctionMetadataV4{Name: "remove_proxy", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "delegate", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "proxy_type", Type: "T::ProxyType"}, FunctionArgumentMetadata{Name: "delay", Type: "T::BlockNumber"}}, Documentation: []Text{" Unregister a proxy account for the sender.", "", " The dispatch origin for this call must be _Signed_.", "", " Parameters:", " - `proxy`: The account that the `caller` would like to remove as a proxy.", " - `proxy_type`: The permissions currently enabled for the removed proxy account.", "", " # <weight>", " Weight is a function of the number of proxies the user has (P).", " # </weight>"}}, FunctionMetadataV4{Name: "remove_proxies", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Unregister all proxy accounts for the sender.", "", " The dispatch origin for this call must be _Signed_.", "", " WARNING: This may be called on accounts created by `anonymous`, however if done, then", " the unreserved fees will be inaccessible. **All access to this account will be lost.**", "", " # <weight>", " Weight is a function of the number of proxies the user has (P).", " # </weight>"}}, FunctionMetadataV4{Name: "anonymous", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proxy_type", Type: "T::ProxyType"}, FunctionArgumentMetadata{Name: "delay", Type: "T::BlockNumber"}, FunctionArgumentMetadata{Name: "index", Type: "u16"}}, Documentation: []Text{" Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and", " initialize it with a proxy of `proxy_type` for `origin` sender.", "", " Requires a `Signed` origin.", "", " - `proxy_type`: The type of the proxy that the sender will be registered as over the", " new account. This will almost always be the most permissive `ProxyType` possible to", " allow for maximum flexibility.", " - `index`: A disambiguation index, in case this is called multiple times in the same", " transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just", " want to use `0`.", " - `delay`: The announcement period required of the initial proxy. Will generally be", " zero.", "", " Fails with `Duplicate` if this has already been called in this transaction, from the", " same sender, with the same parameters.", "", " Fails if there are insufficient funds to pay for deposit.", "", " # <weight>", " Weight is a function of the number of proxies the user has (P).", " # </weight>", " TODO: Might be over counting 1 read"}}, FunctionMetadataV4{Name: "kill_anonymous", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "spawner", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "proxy_type", Type: "T::ProxyType"}, FunctionArgumentMetadata{Name: "index", Type: "u16"}, FunctionArgumentMetadata{Name: "height", Type: "Compact<T::BlockNumber>"}, FunctionArgumentMetadata{Name: "ext_index", Type: "Compact<u32>"}}, Documentation: []Text{" Removes a previously spawned anonymous proxy.", "", " WARNING: **All access to this account will be lost.** Any funds held in it will be", " inaccessible.", "", " Requires a `Signed` origin, and the sender account must have been created by a call to", " `anonymous` with corresponding parameters.", "", " - `spawner`: The account that originally called `anonymous` to create this account.", " - `index`: The disambiguation index originally passed to `anonymous`. Probably `0`.", " - `proxy_type`: The proxy type originally passed to `anonymous`.", " - `height`: The height of the chain when the call to `anonymous` was processed.", " - `ext_index`: The extrinsic index in which the call to `anonymous` was processed.", "", " Fails with `NoPermission` in case the caller is not a previously created anonymous", " account whose `anonymous` call has corresponding parameters.", "", " # <weight>", " Weight is a function of the number of proxies the user has (P).", " # </weight>"}}, FunctionMetadataV4{Name: "announce", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "real", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "call_hash", Type: "CallHashOf<T>"}}, Documentation: []Text{" Publish the hash of a proxy-call that will be made in the future.", "", " This must be called some number of blocks before the corresponding `proxy` is attempted", " if the delay associated with the proxy relationship is greater than zero.", "", " No more than `MaxPending` announcements may be made at any one time.", "", " This will take a deposit of `AnnouncementDepositFactor` as well as", " `AnnouncementDepositBase` if there are no other pending announcements.", "", " The dispatch origin for this call must be _Signed_ and a proxy of `real`.", "", " Parameters:", " - `real`: The account that the proxy will make a call on behalf of.", " - `call_hash`: The hash of the call to be made by the `real` account.", "", " # <weight>", " Weight is a function of:", " - A: the number of announcements made.", " - P: the number of proxies the user has.", " # </weight>"}}, FunctionMetadataV4{Name: "remove_announcement", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "real", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "call_hash", Type: "CallHashOf<T>"}}, Documentation: []Text{" Remove a given announcement.", "", " May be called by a proxy account to remove a call they previously announced and return", " the deposit.", "", " The dispatch origin for this call must be _Signed_.", "", " Parameters:", " - `real`: The account that the proxy will make a call on behalf of.", " - `call_hash`: The hash of the call to be made by the `real` account.", "", " # <weight>", " Weight is a function of:", " - A: the number of announcements made.", " - P: the number of proxies the user has.", " # </weight>"}}, FunctionMetadataV4{Name: "reject_announcement", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "delegate", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "call_hash", Type: "CallHashOf<T>"}}, Documentation: []Text{" Remove the given announcement of a delegate.", "", " May be called by a target (proxied) account to remove a call that one of their delegates", " (`delegate`) has announced they want to execute. The deposit is returned.", "", " The dispatch origin for this call must be _Signed_.", "", " Parameters:", " - `delegate`: The account that previously announced the call.", " - `call_hash`: The hash of the call to be made.", "", " # <weight>", " Weight is a function of:", " - A: the number of announcements made.", " - P: the number of proxies the user has.", " # </weight>"}}, FunctionMetadataV4{Name: "proxy_announced", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "delegate", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "real", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "force_proxy_type", Type: "Option<T::ProxyType>"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Config>::Call>"}}, Documentation: []Text{" Dispatch the given `call` from an account that the sender is authorized for through", " `add_proxy`.", "", " Removes any corresponding announcement(s).", "", " The dispatch origin for this call must be _Signed_.", "", " Parameters:", " - `real`: The account that the proxy will make a call on behalf of.", " - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.", " - `call`: The call to be made by the `real` account.", "", " # <weight>", " Weight is a function of:", " - A: the number of announcements made.", " - P: the number of proxies the user has.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "ProxyExecuted", Args: []Type{"DispatchResult"}, Documentation: []Text{" A proxy was executed correctly, with the given \\[result\\]."}}, EventMetadataV4{Name: "AnonymousCreated", Args: []Type{"AccountId", "AccountId", "ProxyType", "u16"}, Documentation: []Text{" Anonymous account has been created by new proxy with given", " disambiguation index and proxy type. \\[anonymous, who, proxy_type, disambiguation_index\\]"}}, EventMetadataV4{Name: "Announced", Args: []Type{"AccountId", "AccountId", "Hash"}, Documentation: []Text{" An announcement was placed to make a call in the future. \\[real, proxy, call_hash\\]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "ProxyDepositBase", Type: "BalanceOf<T>", Value: Bytes{0x0, 0xf0, 0x9e, 0x54, 0x4c, 0x39, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The base amount of currency needed to reserve for creating a proxy.", "", " This is held for an additional storage item whose value size is", " `sizeof(Balance)` bytes and whose key size is `sizeof(AccountId)` bytes."}}, ModuleConstantMetadataV6{Name: "ProxyDepositFactor", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x60, 0xaa, 0x77, 0x14, 0xb4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of currency needed per proxy added.", "", " This is held for adding 32 bytes plus an instance of `ProxyType` more into a pre-existing", " storage value. Thus, when configuring `ProxyDepositFactor` one should take into account", " `32 + proxy_type.encode().len()` bytes of data."}}, ModuleConstantMetadataV6{Name: "MaxProxies", Type: "u32", Value: Bytes{0x20, 0x0, 0x0, 0x0}, Documentation: []Text{" The maximum amount of proxies allowed for a single account."}}, ModuleConstantMetadataV6{Name: "MaxPending", Type: "u32", Value: Bytes{0x20, 0x0, 0x0, 0x0}, Documentation: []Text{" The maximum amount of time-delayed announcements that are allowed to be pending."}}, ModuleConstantMetadataV6{Name: "AnnouncementDepositBase", Type: "BalanceOf<T>", Value: Bytes{0x0, 0xf0, 0x9e, 0x54, 0x4c, 0x39, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The base amount of currency needed to reserve for creating an announcement.", "", " This is held when a new storage item holding a `Balance` is created (typically 16 bytes)."}}, ModuleConstantMetadataV6{Name: "AnnouncementDepositFactor", Type: "BalanceOf<T>", Value: Bytes{0x0, 0xc0, 0x54, 0xef, 0x28, 0x68, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of currency needed per announcement made.", "", " This is held for adding an `AccountId`, `Hash` and `BlockNumber` (typically 68 bytes)", " into a pre-existing storage value."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "TooMany", Documentation: []Text{" There are too many proxies registered or too many announcements pending."}}, ErrorMetadataV8{Name: "NotFound", Documentation: []Text{" Proxy registration not found."}}, ErrorMetadataV8{Name: "NotProxy", Documentation: []Text{" Sender is not a proxy of the account to be proxied."}}, ErrorMetadataV8{Name: "Unproxyable", Documentation: []Text{" A call which is incompatible with the proxy type's filter was attempted."}}, ErrorMetadataV8{Name: "Duplicate", Documentation: []Text{" Account is already a proxy."}}, ErrorMetadataV8{Name: "NoPermission", Documentation: []Text{" Call may not be made by proxy because it may escalate its privileges."}}, ErrorMetadataV8{Name: "Unannounced", Documentation: []Text{" Announcement, if made at all, was made too recently."}}, ErrorMetadataV8{Name: "NoSelfProxy", Documentation: []Text{" Cannot add self as proxy."}}}, Index: 0x1e}, ModuleMetadataV13{Name: "Multisig", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Multisig", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Multisigs", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "T::AccountId", Key2: "[u8; 32]", Value: "Multisig<T::BlockNumber, BalanceOf<T>, T::AccountId>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The set of open multisig operations."}}, StorageFunctionMetadataV13{Name: "Calls", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "[u8; 32]", Value: "(OpaqueCall, T::AccountId, BalanceOf<T>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text(nil)}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "as_multi_threshold_1", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "other_signatories", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Config>::Call>"}}, Documentation: []Text{" Immediately dispatch a multi-signature call using a single approval from the caller.", "", " The dispatch origin for this call must be _Signed_.", "", " - `other_signatories`: The accounts (other than the sender) who are part of the", " multi-signature, but do not participate in the approval process.", " - `call`: The call to be executed.", "", " Result is equivalent to the dispatched result.", "", " # <weight>", " O(Z + C) where Z is the length of the call and C its execution weight.", " -------------------------------", " - DB Weight: None", " - Plus Call Weight", " # </weight>"}}, FunctionMetadataV4{Name: "as_multi", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "threshold", Type: "u16"}, FunctionArgumentMetadata{Name: "other_signatories", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "maybe_timepoint", Type: "Option<Timepoint<T::BlockNumber>>"}, FunctionArgumentMetadata{Name: "call", Type: "OpaqueCall"}, FunctionArgumentMetadata{Name: "store_call", Type: "bool"}, FunctionArgumentMetadata{Name: "max_weight", Type: "Weight"}}, Documentation: []Text{" Register approval for a dispatch to be made from a deterministic composite account if", " approved by a total of `threshold - 1` of `other_signatories`.", "", " If there are enough, then dispatch the call.", "", " Payment: `DepositBase` will be reserved if this is the first approval, plus", " `threshold` times `DepositFactor`. It is returned once this dispatch happens or", " is cancelled.", "", " The dispatch origin for this call must be _Signed_.", "", " - `threshold`: The total number of approvals for this dispatch before it is executed.", " - `other_signatories`: The accounts (other than the sender) who can approve this", " dispatch. May not be empty.", " - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is", " not the first approval, then it must be `Some`, with the timepoint (block number and", " transaction index) of the first approval transaction.", " - `call`: The call to be executed.", "", " NOTE: Unless this is the final approval, you will generally want to use", " `approve_as_multi` instead, since it only requires a hash of the call.", "", " Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise", " on success, result is `Ok` and the result from the interior call, if it was executed,", " may be found in the deposited `MultisigExecuted` event.", "", " # <weight>", " - `O(S + Z + Call)`.", " - Up to one balance-reserve or unreserve operation.", " - One passthrough operation, one insert, both `O(S)` where `S` is the number of", "   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.", " - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.", " - One encode & hash, both of complexity `O(S)`.", " - Up to one binary search and insert (`O(logS + S)`).", " - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.", " - One event.", " - The weight of the `call`.", " - Storage: inserts one item, value size bounded by `MaxSignatories`, with a", "   deposit taken for its lifetime of", "   `DepositBase + threshold * DepositFactor`.", " -------------------------------", " - DB Weight:", "     - Reads: Multisig Storage, [Caller Account], Calls (if `store_call`)", "     - Writes: Multisig Storage, [Caller Account], Calls (if `store_call`)", " - Plus Call Weight", " # </weight>"}}, FunctionMetadataV4{Name: "approve_as_multi", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "threshold", Type: "u16"}, FunctionArgumentMetadata{Name: "other_signatories", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "maybe_timepoint", Type: "Option<Timepoint<T::BlockNumber>>"}, FunctionArgumentMetadata{Name: "call_hash", Type: "[u8; 32]"}, FunctionArgumentMetadata{Name: "max_weight", Type: "Weight"}}, Documentation: []Text{" Register approval for a dispatch to be made from a deterministic composite account if", " approved by a total of `threshold - 1` of `other_signatories`.", "", " Payment: `DepositBase` will be reserved if this is the first approval, plus", " `threshold` times `DepositFactor`. It is returned once this dispatch happens or", " is cancelled.", "", " The dispatch origin for this call must be _Signed_.", "", " - `threshold`: The total number of approvals for this dispatch before it is executed.", " - `other_signatories`: The accounts (other than the sender) who can approve this", " dispatch. May not be empty.", " - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is", " not the first approval, then it must be `Some`, with the timepoint (block number and", " transaction index) of the first approval transaction.", " - `call_hash`: The hash of the call to be executed.", "", " NOTE: If this is the final approval, you will want to use `as_multi` instead.", "", " # <weight>", " - `O(S)`.", " - Up to one balance-reserve or unreserve operation.", " - One passthrough operation, one insert, both `O(S)` where `S` is the number of", "   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.", " - One encode & hash, both of complexity `O(S)`.", " - Up to one binary search and insert (`O(logS + S)`).", " - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.", " - One event.", " - Storage: inserts one item, value size bounded by `MaxSignatories`, with a", "   deposit taken for its lifetime of", "   `DepositBase + threshold * DepositFactor`.", " ----------------------------------", " - DB Weight:", "     - Read: Multisig Storage, [Caller Account]", "     - Write: Multisig Storage, [Caller Account]", " # </weight>"}}, FunctionMetadataV4{Name: "cancel_as_multi", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "threshold", Type: "u16"}, FunctionArgumentMetadata{Name: "other_signatories", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "timepoint", Type: "Timepoint<T::BlockNumber>"}, FunctionArgumentMetadata{Name: "call_hash", Type: "[u8; 32]"}}, Documentation: []Text{" Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously", " for this operation will be unreserved on success.", "", " The dispatch origin for this call must be _Signed_.", "", " - `threshold`: The total number of approvals for this dispatch before it is executed.", " - `other_signatories`: The accounts (other than the sender) who can approve this", " dispatch. May not be empty.", " - `timepoint`: The timepoint (block number and transaction index) of the first approval", " transaction for this dispatch.", " - `call_hash`: The hash of the call to be executed.", "", " # <weight>", " - `O(S)`.", " - Up to one balance-reserve or unreserve operation.", " - One passthrough operation, one insert, both `O(S)` where `S` is the number of", "   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.", " - One encode & hash, both of complexity `O(S)`.", " - One event.", " - I/O: 1 read `O(S)`, one remove.", " - Storage: removes one item.", " ----------------------------------", " - DB Weight:", "     - Read: Multisig Storage, [Caller Account], Refund Account, Calls", "     - Write: Multisig Storage, [Caller Account], Refund Account, Calls", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "NewMultisig", Args: []Type{"AccountId", "AccountId", "CallHash"}, Documentation: []Text{" A new multisig operation has begun. \\[approving, multisig, call_hash\\]"}}, EventMetadataV4{Name: "MultisigApproval", Args: []Type{"AccountId", "Timepoint<BlockNumber>", "AccountId", "CallHash"}, Documentation: []Text{" A multisig operation has been approved by someone.", " \\[approving, timepoint, multisig, call_hash\\]"}}, EventMetadataV4{Name: "MultisigExecuted", Args: []Type{"AccountId", "Timepoint<BlockNumber>", "AccountId", "CallHash", "DispatchResult"}, Documentation: []Text{" A multisig operation has been executed. \\[approving, timepoint, multisig, call_hash\\]"}}, EventMetadataV4{Name: "MultisigCancelled", Args: []Type{"AccountId", "Timepoint<BlockNumber>", "AccountId", "CallHash"}, Documentation: []Text{" A multisig operation has been cancelled. \\[cancelling, timepoint, multisig, call_hash\\]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "DepositBase", Type: "BalanceOf<T>", Value: Bytes{0x0, 0xf0, 0x1c, 0xa, 0xdb, 0xed, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The base amount of currency needed to reserve for creating a multisig execution or to store", " a dispatch call for later.", "", " This is held for an additional storage item whose value size is", " `4 + sizeof((BlockNumber, Balance, AccountId))` bytes and whose key size is", " `32 + sizeof(AccountId)` bytes."}}, ModuleConstantMetadataV6{Name: "DepositFactor", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x0, 0xcc, 0x7b, 0x9f, 0xae, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of currency needed per unit threshold when creating a multisig execution.", "", " This is held for adding 32 bytes more into a pre-existing storage value."}}, ModuleConstantMetadataV6{Name: "MaxSignatories", Type: "u16", Value: Bytes{0x64, 0x0}, Documentation: []Text{" The maximum amount of signatories allowed in the multisig."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "MinimumThreshold", Documentation: []Text{" Threshold must be 2 or greater."}}, ErrorMetadataV8{Name: "AlreadyApproved", Documentation: []Text{" Call is already approved by this signatory."}}, ErrorMetadataV8{Name: "NoApprovalsNeeded", Documentation: []Text{" Call doesn't need any (more) approvals."}}, ErrorMetadataV8{Name: "TooFewSignatories", Documentation: []Text{" There are too few signatories in the list."}}, ErrorMetadataV8{Name: "TooManySignatories", Documentation: []Text{" There are too many signatories in the list."}}, ErrorMetadataV8{Name: "SignatoriesOutOfOrder", Documentation: []Text{" The signatories were provided out of order; they should be ordered."}}, ErrorMetadataV8{Name: "SenderInSignatories", Documentation: []Text{" The sender was contained in the other signatories; it shouldn't be."}}, ErrorMetadataV8{Name: "NotFound", Documentation: []Text{" Multisig operation not found when attempting to cancel."}}, ErrorMetadataV8{Name: "NotOwner", Documentation: []Text{" Only the account that originally created the multisig is able to cancel it."}}, ErrorMetadataV8{Name: "NoTimepoint", Documentation: []Text{" No timepoint was given, yet the multisig operation is already underway."}}, ErrorMetadataV8{Name: "WrongTimepoint", Documentation: []Text{" A different timepoint was given to the multisig operation that is underway."}}, ErrorMetadataV8{Name: "UnexpectedTimepoint", Documentation: []Text{" A timepoint was given, yet no multisig operation is underway."}}, ErrorMetadataV8{Name: "MaxWeightTooLow", Documentation: []Text{" The maximum weight information provided was too low."}}, ErrorMetadataV8{Name: "AlreadyStored", Documentation: []Text{" The data to be stored is already stored."}}}, Index: 0x1f}, ModuleMetadataV13{Name: "Bounties", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Treasury", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "BountyCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "BountyIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of bounty proposals that have been made."}}, StorageFunctionMetadataV13{Name: "Bounties", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "BountyIndex", Value: "Bounty<T::AccountId, BalanceOf<T>, T::BlockNumber>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Bounties that have been made."}}, StorageFunctionMetadataV13{Name: "BountyDescriptions", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "BountyIndex", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The description of each bounty."}}, StorageFunctionMetadataV13{Name: "BountyApprovals", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<BountyIndex>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Bounty indices that have been approved but not yet funded."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "propose_bounty", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}, FunctionArgumentMetadata{Name: "description", Type: "Vec<u8>"}}, Documentation: []Text{" Propose a new bounty.", "", " The dispatch origin for this call must be _Signed_.", "", " Payment: `TipReportDepositBase` will be reserved from the origin account, as well as", " `DataDepositPerByte` for each byte in `reason`. It will be unreserved upon approval,", " or slashed when rejected.", "", " - `curator`: The curator account whom will manage this bounty.", " - `fee`: The curator fee.", " - `value`: The total payment amount of this bounty, curator fee included.", " - `description`: The description of this bounty."}}, FunctionMetadataV4{Name: "approve_bounty", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "bounty_id", Type: "Compact<BountyIndex>"}}, Documentation: []Text{" Approve a bounty proposal. At a later time, the bounty will be funded and become active", " and the original deposit will be returned.", "", " May only be called from `T::ApproveOrigin`.", "", " # <weight>", " - O(1).", " # </weight>"}}, FunctionMetadataV4{Name: "propose_curator", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "bounty_id", Type: "Compact<BountyIndex>"}, FunctionArgumentMetadata{Name: "curator", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "fee", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Assign a curator to a funded bounty.", "", " May only be called from `T::ApproveOrigin`.", "", " # <weight>", " - O(1).", " # </weight>"}}, FunctionMetadataV4{Name: "unassign_curator", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "bounty_id", Type: "Compact<BountyIndex>"}}, Documentation: []Text{" Unassign curator from a bounty.", "", " This function can only be called by the `RejectOrigin` a signed origin.", "", " If this function is called by the `RejectOrigin`, we assume that the curator is malicious", " or inactive. As a result, we will slash the curator when possible.", "", " If the origin is the curator, we take this as a sign they are unable to do their job and", " they willingly give up. We could slash them, but for now we allow them to recover their", " deposit and exit without issue. (We may want to change this if it is abused.)", "", " Finally, the origin can be anyone if and only if the curator is \"inactive\". This allows", " anyone in the community to call out that a curator is not doing their due diligence, and", " we should pick a new curator. In this case the curator should also be slashed.", "", " # <weight>", " - O(1).", " # </weight>"}}, FunctionMetadataV4{Name: "accept_curator", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "bounty_id", Type: "Compact<BountyIndex>"}}, Documentation: []Text{" Accept the curator role for a bounty.", " A deposit will be reserved from curator and refund upon successful payout.", "", " May only be called from the curator.", "", " # <weight>", " - O(1).", " # </weight>"}}, FunctionMetadataV4{Name: "award_bounty", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "bounty_id", Type: "Compact<BountyIndex>"}, FunctionArgumentMetadata{Name: "beneficiary", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Award bounty to a beneficiary account. The beneficiary will be able to claim the funds after a delay.", "", " The dispatch origin for this call must be the curator of this bounty.", "", " - `bounty_id`: Bounty ID to award.", " - `beneficiary`: The beneficiary account whom will receive the payout.", "", " # <weight>", " - O(1).", " # </weight>"}}, FunctionMetadataV4{Name: "claim_bounty", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "bounty_id", Type: "Compact<BountyIndex>"}}, Documentation: []Text{" Claim the payout from an awarded bounty after payout delay.", "", " The dispatch origin for this call must be the beneficiary of this bounty.", "", " - `bounty_id`: Bounty ID to claim.", "", " # <weight>", " - O(1).", " # </weight>"}}, FunctionMetadataV4{Name: "close_bounty", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "bounty_id", Type: "Compact<BountyIndex>"}}, Documentation: []Text{" Cancel a proposed or active bounty. All the funds will be sent to treasury and", " the curator deposit will be unreserved if possible.", "", " Only `T::RejectOrigin` is able to cancel a bounty.", "", " - `bounty_id`: Bounty ID to cancel.", "", " # <weight>", " - O(1).", " # </weight>"}}, FunctionMetadataV4{Name: "extend_bounty_expiry", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "bounty_id", Type: "Compact<BountyIndex>"}, FunctionArgumentMetadata{Name: "_remark", Type: "Vec<u8>"}}, Documentation: []Text{" Extend the expiry time of an active bounty.", "", " The dispatch origin for this call must be the curator of this bounty.", "", " - `bounty_id`: Bounty ID to extend.", " - `remark`: additional information.", "", " # <weight>", " - O(1).", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "BountyProposed", Args: []Type{"BountyIndex"}, Documentation: []Text{" New bounty proposal. \\[index\\]"}}, EventMetadataV4{Name: "BountyRejected", Args: []Type{"BountyIndex", "Balance"}, Documentation: []Text{" A bounty proposal was rejected; funds were slashed. \\[index, bond\\]"}}, EventMetadataV4{Name: "BountyBecameActive", Args: []Type{"BountyIndex"}, Documentation: []Text{" A bounty proposal is funded and became active. \\[index\\]"}}, EventMetadataV4{Name: "BountyAwarded", Args: []Type{"BountyIndex", "AccountId"}, Documentation: []Text{" A bounty is awarded to a beneficiary. \\[index, beneficiary\\]"}}, EventMetadataV4{Name: "BountyClaimed", Args: []Type{"BountyIndex", "Balance", "AccountId"}, Documentation: []Text{" A bounty is claimed by beneficiary. \\[index, payout, beneficiary\\]"}}, EventMetadataV4{Name: "BountyCanceled", Args: []Type{"BountyIndex"}, Documentation: []Text{" A bounty is cancelled. \\[index\\]"}}, EventMetadataV4{Name: "BountyExtended", Args: []Type{"BountyIndex"}, Documentation: []Text{" A bounty expiry is extended. \\[index\\]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "DataDepositPerByte", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount held on deposit per byte within bounty description."}}, ModuleConstantMetadataV6{Name: "BountyDepositBase", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount held on deposit for placing a bounty proposal."}}, ModuleConstantMetadataV6{Name: "BountyDepositPayoutDelay", Type: "T::BlockNumber", Value: Bytes{0x80, 0x70, 0x0, 0x0}, Documentation: []Text{" The delay period for which a bounty beneficiary need to wait before claim the payout."}}, ModuleConstantMetadataV6{Name: "BountyUpdatePeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x27, 0x6, 0x0}, Documentation: []Text{" Bounty duration in blocks."}}, ModuleConstantMetadataV6{Name: "BountyCuratorDeposit", Type: "Permill", Value: Bytes{0x20, 0xa1, 0x7, 0x0}, Documentation: []Text{" Percentage of the curator fee that will be reserved upfront as deposit for bounty curator."}}, ModuleConstantMetadataV6{Name: "BountyValueMinimum", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x63, 0x52, 0xbf, 0xc6, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Minimum value for a bounty."}}, ModuleConstantMetadataV6{Name: "MaximumReasonLength", Type: "u32", Value: Bytes{0x0, 0x40, 0x0, 0x0}, Documentation: []Text{" Maximum acceptable reason length."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InsufficientProposersBalance", Documentation: []Text{" Proposer's balance is too low."}}, ErrorMetadataV8{Name: "InvalidIndex", Documentation: []Text{" No proposal or bounty at that index."}}, ErrorMetadataV8{Name: "ReasonTooBig", Documentation: []Text{" The reason given is just too big."}}, ErrorMetadataV8{Name: "UnexpectedStatus", Documentation: []Text{" The bounty status is unexpected."}}, ErrorMetadataV8{Name: "RequireCurator", Documentation: []Text{" Require bounty curator."}}, ErrorMetadataV8{Name: "InvalidValue", Documentation: []Text{" Invalid bounty value."}}, ErrorMetadataV8{Name: "InvalidFee", Documentation: []Text{" Invalid bounty fee."}}, ErrorMetadataV8{Name: "PendingPayout", Documentation: []Text{" A bounty payout is pending.", " To cancel the bounty, you must unassign and slash the curator."}}, ErrorMetadataV8{Name: "Premature", Documentation: []Text{" The bounties cannot be claimed/closed because it's still in the countdown period."}}}, Index: 0x20}, ModuleMetadataV13{Name: "Tips", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Treasury", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Tips", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::Hash", Value: "OpenTip<T::AccountId, BalanceOf<T>, T::BlockNumber, T::Hash>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" TipsMap that are not yet completed. Keyed by the hash of `(reason, who)` from the value.", " This has the insecure enumerable hash function since the key itself is already", " guaranteed to be a secure hash."}}, StorageFunctionMetadataV13{Name: "Reasons", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "T::Hash", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Simple preimage lookup from the reason's hash to the original data. Again, has an", " insecure enumerable hash since the key is guaranteed to be the result of a secure hash."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "report_awesome", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "reason", Type: "Vec<u8>"}, FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}}, Documentation: []Text{" Report something `reason` that deserves a tip and claim any eventual the finder's fee.", "", " The dispatch origin for this call must be _Signed_.", "", " Payment: `TipReportDepositBase` will be reserved from the origin account, as well as", " `DataDepositPerByte` for each byte in `reason`.", "", " - `reason`: The reason for, or the thing that deserves, the tip; generally this will be", "   a UTF-8-encoded URL.", " - `who`: The account which should be credited for the tip.", "", " Emits `NewTip` if successful.", "", " # <weight>", " - Complexity: `O(R)` where `R` length of `reason`.", "   - encoding and hashing of 'reason'", " - DbReads: `Reasons`, `Tips`", " - DbWrites: `Reasons`, `Tips`", " # </weight>"}}, FunctionMetadataV4{Name: "retract_tip", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "hash", Type: "T::Hash"}}, Documentation: []Text{" Retract a prior tip-report from `report_awesome`, and cancel the process of tipping.", "", " If successful, the original deposit will be unreserved.", "", " The dispatch origin for this call must be _Signed_ and the tip identified by `hash`", " must have been reported by the signing account through `report_awesome` (and not", " through `tip_new`).", "", " - `hash`: The identity of the open tip for which a tip value is declared. This is formed", "   as the hash of the tuple of the original tip `reason` and the beneficiary account ID.", "", " Emits `TipRetracted` if successful.", "", " # <weight>", " - Complexity: `O(1)`", "   - Depends on the length of `T::Hash` which is fixed.", " - DbReads: `Tips`, `origin account`", " - DbWrites: `Reasons`, `Tips`, `origin account`", " # </weight>"}}, FunctionMetadataV4{Name: "tip_new", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "reason", Type: "Vec<u8>"}, FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "tip_value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Give a tip for something new; no finder's fee will be taken.", "", " The dispatch origin for this call must be _Signed_ and the signing account must be a", " member of the `Tippers` set.", "", " - `reason`: The reason for, or the thing that deserves, the tip; generally this will be", "   a UTF-8-encoded URL.", " - `who`: The account which should be credited for the tip.", " - `tip_value`: The amount of tip that the sender would like to give. The median tip", "   value of active tippers will be given to the `who`.", "", " Emits `NewTip` if successful.", "", " # <weight>", " - Complexity: `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.", "   - `O(T)`: decoding `Tipper` vec of length `T`", "     `T` is charged as upper bound given by `ContainsLengthBound`.", "     The actual cost depends on the implementation of `T::Tippers`.", "   - `O(R)`: hashing and encoding of reason of length `R`", " - DbReads: `Tippers`, `Reasons`", " - DbWrites: `Reasons`, `Tips`", " # </weight>"}}, FunctionMetadataV4{Name: "tip", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "hash", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "tip_value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Declare a tip value for an already-open tip.", "", " The dispatch origin for this call must be _Signed_ and the signing account must be a", " member of the `Tippers` set.", "", " - `hash`: The identity of the open tip for which a tip value is declared. This is formed", "   as the hash of the tuple of the hash of the original tip `reason` and the beneficiary", "   account ID.", " - `tip_value`: The amount of tip that the sender would like to give. The median tip", "   value of active tippers will be given to the `who`.", "", " Emits `TipClosing` if the threshold of tippers has been reached and the countdown period", " has started.", "", " # <weight>", " - Complexity: `O(T)` where `T` is the number of tippers.", "   decoding `Tipper` vec of length `T`, insert tip and check closing,", "   `T` is charged as upper bound given by `ContainsLengthBound`.", "   The actual cost depends on the implementation of `T::Tippers`.", "", "   Actually weight could be lower as it depends on how many tips are in `OpenTip` but it", "   is weighted as if almost full i.e of length `T-1`.", " - DbReads: `Tippers`, `Tips`", " - DbWrites: `Tips`", " # </weight>"}}, FunctionMetadataV4{Name: "close_tip", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "hash", Type: "T::Hash"}}, Documentation: []Text{" Close and payout a tip.", "", " The dispatch origin for this call must be _Signed_.", "", " The tip identified by `hash` must have finished its countdown period.", "", " - `hash`: The identity of the open tip for which a tip value is declared. This is formed", "   as the hash of the tuple of the original tip `reason` and the beneficiary account ID.", "", " # <weight>", " - Complexity: `O(T)` where `T` is the number of tippers.", "   decoding `Tipper` vec of length `T`.", "   `T` is charged as upper bound given by `ContainsLengthBound`.", "   The actual cost depends on the implementation of `T::Tippers`.", " - DbReads: `Tips`, `Tippers`, `tip finder`", " - DbWrites: `Reasons`, `Tips`, `Tippers`, `tip finder`", " # </weight>"}}, FunctionMetadataV4{Name: "slash_tip", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "hash", Type: "T::Hash"}}, Documentation: []Text{" Remove and slash an already-open tip.", "", " May only be called from `T::RejectOrigin`.", "", " As a result, the finder is slashed and the deposits are lost.", "", " Emits `TipSlashed` if successful.", "", " # <weight>", "   `T` is charged as upper bound given by `ContainsLengthBound`.", "   The actual cost depends on the implementation of `T::Tippers`.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "NewTip", Args: []Type{"Hash"}, Documentation: []Text{" A new tip suggestion has been opened. \\[tip_hash\\]"}}, EventMetadataV4{Name: "TipClosing", Args: []Type{"Hash"}, Documentation: []Text{" A tip suggestion has reached threshold and is closing. \\[tip_hash\\]"}}, EventMetadataV4{Name: "TipClosed", Args: []Type{"Hash", "AccountId", "Balance"}, Documentation: []Text{" A tip suggestion has been closed. \\[tip_hash, who, payout\\]"}}, EventMetadataV4{Name: "TipRetracted", Args: []Type{"Hash"}, Documentation: []Text{" A tip suggestion has been retracted. \\[tip_hash\\]"}}, EventMetadataV4{Name: "TipSlashed", Args: []Type{"Hash", "AccountId", "Balance"}, Documentation: []Text{" A tip suggestion has been slashed. \\[tip_hash, finder, deposit\\]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "TipCountdown", Type: "T::BlockNumber", Value: Bytes{0x80, 0x70, 0x0, 0x0}, Documentation: []Text{" The period for which a tip remains open after is has achieved threshold tippers."}}, ModuleConstantMetadataV6{Name: "TipFindersFee", Type: "Percent", Value: Bytes{0x14}, Documentation: []Text{" The amount of the final tip which goes to the original reporter of the tip."}}, ModuleConstantMetadataV6{Name: "TipReportDepositBase", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount held on deposit for placing a tip report."}}, ModuleConstantMetadataV6{Name: "DataDepositPerByte", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount held on deposit per byte within the tip report reason."}}, ModuleConstantMetadataV6{Name: "MaximumReasonLength", Type: "u32", Value: Bytes{0x0, 0x40, 0x0, 0x0}, Documentation: []Text{" Maximum acceptable reason length."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "ReasonTooBig", Documentation: []Text{" The reason given is just too big."}}, ErrorMetadataV8{Name: "AlreadyKnown", Documentation: []Text{" The tip was already found/started."}}, ErrorMetadataV8{Name: "UnknownTip", Documentation: []Text{" The tip hash is unknown."}}, ErrorMetadataV8{Name: "NotFinder", Documentation: []Text{" The account attempting to retract the tip is not the finder of the tip."}}, ErrorMetadataV8{Name: "StillOpen", Documentation: []Text{" The tip cannot be claimed/closed because there are not enough tippers yet."}}, ErrorMetadataV8{Name: "Premature", Documentation: []Text{" The tip cannot be claimed/closed because it's still in the countdown period."}}}, Index: 0x21}, ModuleMetadataV13{Name: "Assets", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Assets", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Asset", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::AssetId", Value: "AssetDetails<T::Balance, T::AccountId, DepositBalanceOf<T, I>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Details of an asset."}}, StorageFunctionMetadataV13{Name: "Account", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "T::AssetId", Key2: "T::AccountId", Value: "AssetBalance<T::Balance, T::Extra>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of units of assets held by any given account."}}, StorageFunctionMetadataV13{Name: "Approvals", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: true, AsNMap: NMapTypeV13{Keys: []Type{"T::AssetId", "T::AccountId", "T::AccountId"}, Hashers: []StorageHasherV10{StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, Value: "Approval<T::Balance, DepositBalanceOf<T, I>>"}}, Fallback: Bytes{0x0}, Documentation: []Text{" Approved balance transfers. First balance is the amount approved for transfer. Second", " is the amount of `T::Currency` reserved for storing this.", " First key is the asset ID, second key is the owner and third key is the delegate."}}, StorageFunctionMetadataV13{Name: "Metadata", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::AssetId", Value: "AssetMetadata<DepositBalanceOf<T, I>, BoundedVec<u8, T::StringLimit>\n>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Metadata of an asset."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "create", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}, FunctionArgumentMetadata{Name: "admin", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "min_balance", Type: "T::Balance"}}, Documentation: []Text{" Issue a new class of fungible assets from a public origin.", "", " This new asset class has no assets initially and its owner is the origin.", "", " The origin must be Signed and the sender must have sufficient funds free.", "", " Funds of sender are reserved by `AssetDeposit`.", "", " Parameters:", " - `id`: The identifier of the new asset. This must not be currently in use to identify", " an existing asset.", " - `admin`: The admin of this class of assets. The admin is the initial address of each", " member of the asset class's admin team.", " - `min_balance`: The minimum balance of this new asset that any single account must", " have. If an account's balance is reduced below this, then it collapses to zero.", "", " Emits `Created` event when successful.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "force_create", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}, FunctionArgumentMetadata{Name: "owner", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "is_sufficient", Type: "bool"}, FunctionArgumentMetadata{Name: "min_balance", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Issue a new class of fungible assets from a privileged origin.", "", " This new asset class has no assets initially.", "", " The origin must conform to `ForceOrigin`.", "", " Unlike `create`, no funds are reserved.", "", " - `id`: The identifier of the new asset. This must not be currently in use to identify", " an existing asset.", " - `owner`: The owner of this class of assets. The owner has full superuser permissions", " over this asset, but may later change and configure the permissions using `transfer_ownership`", " and `set_team`.", " - `min_balance`: The minimum balance of this new asset that any single account must", " have. If an account's balance is reduced below this, then it collapses to zero.", "", " Emits `ForceCreated` event when successful.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "destroy", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}, FunctionArgumentMetadata{Name: "witness", Type: "DestroyWitness"}}, Documentation: []Text{" Destroy a class of fungible assets.", "", " The origin must conform to `ForceOrigin` or must be Signed and the sender must be the", " owner of the asset `id`.", "", " - `id`: The identifier of the asset to be destroyed. This must identify an existing", " asset.", "", " Emits `Destroyed` event when successful.", "", " Weight: `O(c + p + a)` where:", " - `c = (witness.accounts - witness.sufficients)`", " - `s = witness.sufficients`", " - `a = witness.approvals`"}}, FunctionMetadataV4{Name: "mint", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}, FunctionArgumentMetadata{Name: "beneficiary", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "amount", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Mint assets of a particular class.", "", " The origin must be Signed and the sender must be the Issuer of the asset `id`.", "", " - `id`: The identifier of the asset to have some amount minted.", " - `beneficiary`: The account to be credited with the minted assets.", " - `amount`: The amount of the asset to be minted.", "", " Emits `Issued` event when successful.", "", " Weight: `O(1)`", " Modes: Pre-existing balance of `beneficiary`; Account pre-existence of `beneficiary`."}}, FunctionMetadataV4{Name: "burn", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}, FunctionArgumentMetadata{Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "amount", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Reduce the balance of `who` by as much as possible up to `amount` assets of `id`.", "", " Origin must be Signed and the sender should be the Manager of the asset `id`.", "", " Bails with `BalanceZero` if the `who` is already dead.", "", " - `id`: The identifier of the asset to have some amount burned.", " - `who`: The account to be debited from.", " - `amount`: The maximum amount by which `who`'s balance should be reduced.", "", " Emits `Burned` with the actual amount burned. If this takes the balance to below the", " minimum for the asset, then the amount burned is increased to take it to zero.", "", " Weight: `O(1)`", " Modes: Post-existence of `who`; Pre & post Zombie-status of `who`."}}, FunctionMetadataV4{Name: "transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}, FunctionArgumentMetadata{Name: "target", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "amount", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Move some assets from the sender account to another.", "", " Origin must be Signed.", "", " - `id`: The identifier of the asset to have some amount transferred.", " - `target`: The account to be credited.", " - `amount`: The amount by which the sender's balance of assets should be reduced and", " `target`'s balance increased. The amount actually transferred may be slightly greater in", " the case that the transfer would otherwise take the sender balance above zero but below", " the minimum balance. Must be greater than zero.", "", " Emits `Transferred` with the actual amount transferred. If this takes the source balance", " to below the minimum for the asset, then the amount transferred is increased to take it", " to zero.", "", " Weight: `O(1)`", " Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of", " `target`."}}, FunctionMetadataV4{Name: "transfer_keep_alive", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}, FunctionArgumentMetadata{Name: "target", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "amount", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Move some assets from the sender account to another, keeping the sender account alive.", "", " Origin must be Signed.", "", " - `id`: The identifier of the asset to have some amount transferred.", " - `target`: The account to be credited.", " - `amount`: The amount by which the sender's balance of assets should be reduced and", " `target`'s balance increased. The amount actually transferred may be slightly greater in", " the case that the transfer would otherwise take the sender balance above zero but below", " the minimum balance. Must be greater than zero.", "", " Emits `Transferred` with the actual amount transferred. If this takes the source balance", " to below the minimum for the asset, then the amount transferred is increased to take it", " to zero.", "", " Weight: `O(1)`", " Modes: Pre-existence of `target`; Post-existence of sender; Account pre-existence of", " `target`."}}, FunctionMetadataV4{Name: "force_transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}, FunctionArgumentMetadata{Name: "source", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "amount", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Move some assets from one account to another.", "", " Origin must be Signed and the sender should be the Admin of the asset `id`.", "", " - `id`: The identifier of the asset to have some amount transferred.", " - `source`: The account to be debited.", " - `dest`: The account to be credited.", " - `amount`: The amount by which the `source`'s balance of assets should be reduced and", " `dest`'s balance increased. The amount actually transferred may be slightly greater in", " the case that the transfer would otherwise take the `source` balance above zero but", " below the minimum balance. Must be greater than zero.", "", " Emits `Transferred` with the actual amount transferred. If this takes the source balance", " to below the minimum for the asset, then the amount transferred is increased to take it", " to zero.", "", " Weight: `O(1)`", " Modes: Pre-existence of `dest`; Post-existence of `source`; Account pre-existence of", " `dest`."}}, FunctionMetadataV4{Name: "freeze", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}, FunctionArgumentMetadata{Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Disallow further unprivileged transfers from an account.", "", " Origin must be Signed and the sender should be the Freezer of the asset `id`.", "", " - `id`: The identifier of the asset to be frozen.", " - `who`: The account to be frozen.", "", " Emits `Frozen`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "thaw", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}, FunctionArgumentMetadata{Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Allow unprivileged transfers from an account again.", "", " Origin must be Signed and the sender should be the Admin of the asset `id`.", "", " - `id`: The identifier of the asset to be frozen.", " - `who`: The account to be unfrozen.", "", " Emits `Thawed`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "freeze_asset", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}}, Documentation: []Text{" Disallow further unprivileged transfers for the asset class.", "", " Origin must be Signed and the sender should be the Freezer of the asset `id`.", "", " - `id`: The identifier of the asset to be frozen.", "", " Emits `Frozen`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "thaw_asset", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}}, Documentation: []Text{" Allow unprivileged transfers for the asset again.", "", " Origin must be Signed and the sender should be the Admin of the asset `id`.", "", " - `id`: The identifier of the asset to be thawed.", "", " Emits `Thawed`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "transfer_ownership", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}, FunctionArgumentMetadata{Name: "owner", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Change the Owner of an asset.", "", " Origin must be Signed and the sender should be the Owner of the asset `id`.", "", " - `id`: The identifier of the asset.", " - `owner`: The new Owner of this asset.", "", " Emits `OwnerChanged`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "set_team", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}, FunctionArgumentMetadata{Name: "issuer", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "admin", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "freezer", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Change the Issuer, Admin and Freezer of an asset.", "", " Origin must be Signed and the sender should be the Owner of the asset `id`.", "", " - `id`: The identifier of the asset to be frozen.", " - `issuer`: The new Issuer of this asset.", " - `admin`: The new Admin of this asset.", " - `freezer`: The new Freezer of this asset.", "", " Emits `TeamChanged`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "set_metadata", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}, FunctionArgumentMetadata{Name: "name", Type: "Vec<u8>"}, FunctionArgumentMetadata{Name: "symbol", Type: "Vec<u8>"}, FunctionArgumentMetadata{Name: "decimals", Type: "u8"}}, Documentation: []Text{" Set the metadata for an asset.", "", " Origin must be Signed and the sender should be the Owner of the asset `id`.", "", " Funds of sender are reserved according to the formula:", " `MetadataDepositBase + MetadataDepositPerByte * (name.len + symbol.len)` taking into", " account any already reserved funds.", "", " - `id`: The identifier of the asset to update.", " - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.", " - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.", " - `decimals`: The number of decimals this asset uses to represent one unit.", "", " Emits `MetadataSet`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "clear_metadata", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}}, Documentation: []Text{" Clear the metadata for an asset.", "", " Origin must be Signed and the sender should be the Owner of the asset `id`.", "", " Any deposit is freed for the asset owner.", "", " - `id`: The identifier of the asset to clear.", "", " Emits `MetadataCleared`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "force_set_metadata", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}, FunctionArgumentMetadata{Name: "name", Type: "Vec<u8>"}, FunctionArgumentMetadata{Name: "symbol", Type: "Vec<u8>"}, FunctionArgumentMetadata{Name: "decimals", Type: "u8"}, FunctionArgumentMetadata{Name: "is_frozen", Type: "bool"}}, Documentation: []Text{" Force the metadata for an asset to some value.", "", " Origin must be ForceOrigin.", "", " Any deposit is left alone.", "", " - `id`: The identifier of the asset to update.", " - `name`: The user friendly name of this asset. Limited in length by `StringLimit`.", " - `symbol`: The exchange symbol for this asset. Limited in length by `StringLimit`.", " - `decimals`: The number of decimals this asset uses to represent one unit.", "", " Emits `MetadataSet`.", "", " Weight: `O(N + S)` where N and S are the length of the name and symbol respectively."}}, FunctionMetadataV4{Name: "force_clear_metadata", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}}, Documentation: []Text{" Clear the metadata for an asset.", "", " Origin must be ForceOrigin.", "", " Any deposit is returned.", "", " - `id`: The identifier of the asset to clear.", "", " Emits `MetadataCleared`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "force_asset_status", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}, FunctionArgumentMetadata{Name: "owner", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "issuer", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "admin", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "freezer", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "min_balance", Type: "Compact<T::Balance>"}, FunctionArgumentMetadata{Name: "is_sufficient", Type: "bool"}, FunctionArgumentMetadata{Name: "is_frozen", Type: "bool"}}, Documentation: []Text{" Alter the attributes of a given asset.", "", " Origin must be `ForceOrigin`.", "", " - `id`: The identifier of the asset.", " - `owner`: The new Owner of this asset.", " - `issuer`: The new Issuer of this asset.", " - `admin`: The new Admin of this asset.", " - `freezer`: The new Freezer of this asset.", " - `min_balance`: The minimum balance of this new asset that any single account must", " have. If an account's balance is reduced below this, then it collapses to zero.", " - `is_sufficient`: Whether a non-zero balance of this asset is deposit of sufficient", " value to account for the state bloat associated with its balance storage. If set to", " `true`, then non-zero balances may be stored without a `consumer` reference (and thus", " an ED in the Balances pallet or whatever else is used to control user-account state", " growth).", " - `is_frozen`: Whether this asset class is frozen except for permissioned/admin", " instructions.", "", " Emits `AssetStatusChanged` with the identity of the asset.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "approve_transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}, FunctionArgumentMetadata{Name: "delegate", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "amount", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Approve an amount of asset for transfer by a delegated third-party account.", "", " Origin must be Signed.", "", " Ensures that `ApprovalDeposit` worth of `Currency` is reserved from signing account", " for the purpose of holding the approval. If some non-zero amount of assets is already", " approved from signing account to `delegate`, then it is topped up or unreserved to", " meet the right value.", "", " NOTE: The signing account does not need to own `amount` of assets at the point of", " making this call.", "", " - `id`: The identifier of the asset.", " - `delegate`: The account to delegate permission to transfer asset.", " - `amount`: The amount of asset that may be transferred by `delegate`. If there is", " already an approval in place, then this acts additively.", "", " Emits `ApprovedTransfer` on success.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "cancel_approval", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}, FunctionArgumentMetadata{Name: "delegate", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Cancel all of some asset approved for delegated transfer by a third-party account.", "", " Origin must be Signed and there must be an approval in place between signer and", " `delegate`.", "", " Unreserves any deposit previously reserved by `approve_transfer` for the approval.", "", " - `id`: The identifier of the asset.", " - `delegate`: The account delegated permission to transfer asset.", "", " Emits `ApprovalCancelled` on success.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "force_cancel_approval", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}, FunctionArgumentMetadata{Name: "owner", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "delegate", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Cancel all of some asset approved for delegated transfer by a third-party account.", "", " Origin must be either ForceOrigin or Signed origin with the signer being the Admin", " account of the asset `id`.", "", " Unreserves any deposit previously reserved by `approve_transfer` for the approval.", "", " - `id`: The identifier of the asset.", " - `delegate`: The account delegated permission to transfer asset.", "", " Emits `ApprovalCancelled` on success.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "transfer_approved", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Compact<T::AssetId>"}, FunctionArgumentMetadata{Name: "owner", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "destination", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "amount", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Transfer some asset balance from a previously delegated account to some third-party", " account.", "", " Origin must be Signed and there must be an approval in place by the `owner` to the", " signer.", "", " If the entire amount approved for transfer is transferred, then any deposit previously", " reserved by `approve_transfer` is unreserved.", "", " - `id`: The identifier of the asset.", " - `owner`: The account which previously approved for a transfer of at least `amount` and", " from which the asset balance will be withdrawn.", " - `destination`: The account to which the asset balance of `amount` will be transferred.", " - `amount`: The amount of assets to transfer.", "", " Emits `TransferredApproved` on success.", "", " Weight: `O(1)`"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Created", Args: []Type{"AssetId", "AccountId", "AccountId"}, Documentation: []Text{" Some asset class was created. \\[asset_id, creator, owner\\]"}}, EventMetadataV4{Name: "Issued", Args: []Type{"AssetId", "AccountId", "Balance"}, Documentation: []Text{" Some assets were issued. \\[asset_id, owner, total_supply\\]"}}, EventMetadataV4{Name: "Transferred", Args: []Type{"AssetId", "AccountId", "AccountId", "Balance"}, Documentation: []Text{" Some assets were transferred. \\[asset_id, from, to, amount\\]"}}, EventMetadataV4{Name: "Burned", Args: []Type{"AssetId", "AccountId", "Balance"}, Documentation: []Text{" Some assets were destroyed. \\[asset_id, owner, balance\\]"}}, EventMetadataV4{Name: "TeamChanged", Args: []Type{"AssetId", "AccountId", "AccountId", "AccountId"}, Documentation: []Text{" The management team changed \\[asset_id, issuer, admin, freezer\\]"}}, EventMetadataV4{Name: "OwnerChanged", Args: []Type{"AssetId", "AccountId"}, Documentation: []Text{" The owner changed \\[asset_id, owner\\]"}}, EventMetadataV4{Name: "Frozen", Args: []Type{"AssetId", "AccountId"}, Documentation: []Text{" Some account `who` was frozen. \\[asset_id, who\\]"}}, EventMetadataV4{Name: "Thawed", Args: []Type{"AssetId", "AccountId"}, Documentation: []Text{" Some account `who` was thawed. \\[asset_id, who\\]"}}, EventMetadataV4{Name: "AssetFrozen", Args: []Type{"AssetId"}, Documentation: []Text{" Some asset `asset_id` was frozen. \\[asset_id\\]"}}, EventMetadataV4{Name: "AssetThawed", Args: []Type{"AssetId"}, Documentation: []Text{" Some asset `asset_id` was thawed. \\[asset_id\\]"}}, EventMetadataV4{Name: "Destroyed", Args: []Type{"AssetId"}, Documentation: []Text{" An asset class was destroyed."}}, EventMetadataV4{Name: "ForceCreated", Args: []Type{"AssetId", "AccountId"}, Documentation: []Text{" Some asset class was force-created. \\[asset_id, owner\\]"}}, EventMetadataV4{Name: "MetadataSet", Args: []Type{"AssetId", "Vec<u8>", "Vec<u8>", "u8", "bool"}, Documentation: []Text{" New metadata has been set for an asset. \\[asset_id, name, symbol, decimals, is_frozen\\]"}}, EventMetadataV4{Name: "MetadataCleared", Args: []Type{"AssetId"}, Documentation: []Text{" Metadata has been cleared for an asset. \\[asset_id\\]"}}, EventMetadataV4{Name: "ApprovedTransfer", Args: []Type{"AssetId", "AccountId", "AccountId", "Balance"}, Documentation: []Text{" (Additional) funds have been approved for transfer to a destination account.", " \\[asset_id, source, delegate, amount\\]"}}, EventMetadataV4{Name: "ApprovalCancelled", Args: []Type{"AssetId", "AccountId", "AccountId"}, Documentation: []Text{" An approval for account `delegate` was cancelled by `owner`.", " \\[id, owner, delegate\\]"}}, EventMetadataV4{Name: "TransferredApproved", Args: []Type{"AssetId", "AccountId", "AccountId", "AccountId", "Balance"}, Documentation: []Text{" An `amount` was transferred in its entirety from `owner` to `destination` by", " the approved `delegate`.", " \\[id, owner, delegate, destination\\]"}}, EventMetadataV4{Name: "AssetStatusChanged", Args: []Type{"AssetId"}, Documentation: []Text{" An asset has had its attributes changed by the `Force` origin.", " \\[id\\]"}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "BalanceLow", Documentation: []Text{" Account balance must be greater than or equal to the transfer amount."}}, ErrorMetadataV8{Name: "BalanceZero", Documentation: []Text{" Balance should be non-zero."}}, ErrorMetadataV8{Name: "NoPermission", Documentation: []Text{" The signing account has no permission to do the operation."}}, ErrorMetadataV8{Name: "Unknown", Documentation: []Text{" The given asset ID is unknown."}}, ErrorMetadataV8{Name: "Frozen", Documentation: []Text{" The origin account is frozen."}}, ErrorMetadataV8{Name: "InUse", Documentation: []Text{" The asset ID is already taken."}}, ErrorMetadataV8{Name: "BadWitness", Documentation: []Text{" Invalid witness data given."}}, ErrorMetadataV8{Name: "MinBalanceZero", Documentation: []Text{" Minimum balance should be non-zero."}}, ErrorMetadataV8{Name: "NoProvider", Documentation: []Text{" No provider reference exists to allow a non-zero balance of a non-self-sufficient asset."}}, ErrorMetadataV8{Name: "BadMetadata", Documentation: []Text{" Invalid metadata given."}}, ErrorMetadataV8{Name: "Unapproved", Documentation: []Text{" No approval exists that would allow the transfer."}}, ErrorMetadataV8{Name: "WouldDie", Documentation: []Text{" The source account would not survive the transfer and it needs to stay alive."}}}, Index: 0x22}, ModuleMetadataV13{Name: "Mmr", HasStorage: true, Storage: StorageMetadataV13{Prefix: "MerkleMountainRange", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "RootHash", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "<T as Config<I>>::Hash", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Latest MMR Root hash."}}, StorageFunctionMetadataV13{Name: "NumberOfLeaves", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "u64", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current size of the MMR (number of leaves)."}}, StorageFunctionMetadataV13{Name: "Nodes", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "u64", Value: "<T as Config<I>>::Hash", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Hashes of the nodes in the MMR.", "", " Note this collection only contains MMR peaks, the inner nodes (and leaves)", " are pruned and only stored in the Offchain DB."}}}}, HasCalls: false, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil), Index: 0x23}, ModuleMetadataV13{Name: "Lottery", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Lottery", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "LotteryIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text(nil)}, StorageFunctionMetadataV13{Name: "Lottery", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "LotteryConfig<T::BlockNumber, BalanceOf<T>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The configuration for the current lottery."}}, StorageFunctionMetadataV13{Name: "Participants", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "(u32, Vec<CallIndex>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Users who have purchased a ticket. (Lottery Index, Tickets Purchased)"}}, StorageFunctionMetadataV13{Name: "TicketsCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Total number of tickets sold."}}, StorageFunctionMetadataV13{Name: "Tickets", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "u32", Value: "T::AccountId", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Each ticket's owner.", "", " May have residual storage from previous lotteries. Use `TicketsCount` to see which ones", " are actually valid ticket mappings."}}, StorageFunctionMetadataV13{Name: "CallIndices", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<CallIndex>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The calls stored in this pallet to be used in an active lottery if configured", " by `Config::ValidateCall`."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "buy_ticket", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Config>::Call>"}}, Documentation: []Text{" Buy a ticket to enter the lottery.", "", " This extrinsic acts as a passthrough function for `call`. In all", " situations where `call` alone would succeed, this extrinsic should", " succeed.", "", " If `call` is successful, then we will attempt to purchase a ticket,", " which may fail silently. To detect success of a ticket purchase, you", " should listen for the `TicketBought` event.", "", " This extrinsic must be called by a signed origin."}}, FunctionMetadataV4{Name: "set_calls", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "calls", Type: "Vec<<T as Config>::Call>"}}, Documentation: []Text{" Set calls in storage which can be used to purchase a lottery ticket.", "", " This function only matters if you use the `ValidateCall` implementation", " provided by this pallet, which uses storage to determine the valid calls.", "", " This extrinsic must be called by the Manager origin."}}, FunctionMetadataV4{Name: "start_lottery", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "price", Type: "BalanceOf<T>"}, FunctionArgumentMetadata{Name: "length", Type: "T::BlockNumber"}, FunctionArgumentMetadata{Name: "delay", Type: "T::BlockNumber"}, FunctionArgumentMetadata{Name: "repeat", Type: "bool"}}, Documentation: []Text{" Start a lottery using the provided configuration.", "", " This extrinsic must be called by the `ManagerOrigin`.", "", " Parameters:", "", " * `price`: The cost of a single ticket.", " * `length`: How long the lottery should run for starting at the current block.", " * `delay`: How long after the lottery end we should wait before picking a winner.", " * `repeat`: If the lottery should repeat when completed."}}, FunctionMetadataV4{Name: "stop_repeat", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" If a lottery is repeating, you can use this to stop the repeat.", " The lottery will continue to run to completion.", "", " This extrinsic must be called by the `ManagerOrigin`."}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "LotteryStarted", Args: []Type(nil), Documentation: []Text{" A lottery has been started!"}}, EventMetadataV4{Name: "CallsUpdated", Args: []Type(nil), Documentation: []Text{" A new set of calls have been set!"}}, EventMetadataV4{Name: "Winner", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" A winner has been chosen!"}}, EventMetadataV4{Name: "TicketBought", Args: []Type{"AccountId", "CallIndex"}, Documentation: []Text{" A ticket has been bought!"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "PalletId", Type: "PalletId", Value: Bytes{0x70, 0x79, 0x2f, 0x6c, 0x6f, 0x74, 0x74, 0x6f}, Documentation: []Text{" The Lottery's pallet id"}}, ModuleConstantMetadataV6{Name: "MaxCalls", Type: "u32", Value: Bytes{0xa, 0x0, 0x0, 0x0}, Documentation: []Text{" The max number of calls available in a single lottery."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "NotConfigured", Documentation: []Text{" A lottery has not been configured."}}, ErrorMetadataV8{Name: "InProgress", Documentation: []Text{" A lottery is already in progress."}}, ErrorMetadataV8{Name: "AlreadyEnded", Documentation: []Text{" A lottery has already ended."}}, ErrorMetadataV8{Name: "InvalidCall", Documentation: []Text{" The call is not valid for an open lottery."}}, ErrorMetadataV8{Name: "AlreadyParticipating", Documentation: []Text{" You are already participating in the lottery with this call."}}, ErrorMetadataV8{Name: "TooManyCalls", Documentation: []Text{" Too many calls for a single lottery."}}, ErrorMetadataV8{Name: "EncodingFailed", Documentation: []Text{" Failed to encode calls"}}}, Index: 0x24}, ModuleMetadataV13{Name: "Gilt", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Gilt", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "QueueTotals", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<(u32, BalanceOf<T>)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The totals of items and balances within each queue. Saves a lot of storage reads in the", " case of sparsely packed queues.", "", " The vector is indexed by duration in `Period`s, offset by one, so information on the queue", " whose duration is one `Period` would be storage `0`."}}, StorageFunctionMetadataV13{Name: "Queues", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "u32", Value: "Vec<GiltBid<BalanceOf<T>, T::AccountId>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The queues of bids ready to become gilts. Indexed by duration (in `Period`s)."}}, StorageFunctionMetadataV13{Name: "ActiveTotal", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "ActiveGiltsTotal<BalanceOf<T>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Information relating to the gilts currently active."}}, StorageFunctionMetadataV13{Name: "Active", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "ActiveIndex", Value: "ActiveGilt<BalanceOf<T>,<T as frame_system::Config>::AccountId,<\nT as frame_system::Config>::BlockNumber>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The currently active gilts, indexed according to the order of creation."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "place_bid", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "amount", Type: "Compact<BalanceOf<T>>"}, FunctionArgumentMetadata{Name: "duration", Type: "u32"}}, Documentation: []Text{" Place a bid for a gilt to be issued.", "", " Origin must be Signed, and account must have at least `amount` in free balance.", "", " - `amount`: The amount of the bid; these funds will be reserved. If the bid is", " successfully elevated into an issued gilt, then these funds will continue to be", " reserved until the gilt expires. Must be at least `MinFreeze`.", " - `duration`: The number of periods for which the funds will be locked if the gilt is", " issued. It will expire only after this period has elapsed after the point of issuance.", " Must be greater than 1 and no more than `QueueCount`.", "", " Complexities:", " - `Queues[duration].len()` (just take max)."}}, FunctionMetadataV4{Name: "retract_bid", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "amount", Type: "Compact<BalanceOf<T>>"}, FunctionArgumentMetadata{Name: "duration", Type: "u32"}}, Documentation: []Text{" Retract a previously placed bid.", "", " Origin must be Signed, and the account should have previously issued a still-active bid", " of `amount` for `duration`.", "", " - `amount`: The amount of the previous bid.", " - `duration`: The duration of the previous bid."}}, FunctionMetadataV4{Name: "set_target", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "target", Type: "Compact<Perquintill>"}}, Documentation: []Text{" Set target proportion of gilt-funds.", "", " Origin must be `AdminOrigin`.", "", " - `target`: The target proportion of effective issued funds that should be under gilts", " at any one time."}}, FunctionMetadataV4{Name: "thaw", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "Compact<ActiveIndex>"}}, Documentation: []Text{" Remove an active but expired gilt. Reserved funds under gilt are freed and balance is", " adjusted to ensure that the funds grow or shrink to maintain the equivalent proportion", " of effective total issued funds.", "", " Origin must be Signed and the account must be the owner of the gilt of the given index.", "", " - `index`: The index of the gilt to be thawed."}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "BidPlaced", Args: []Type{"AccountId", "BalanceOf<T>", "u32"}, Documentation: []Text{" A bid was successfully placed.", " \\[ who, amount, duration \\]"}}, EventMetadataV4{Name: "BidRetracted", Args: []Type{"AccountId", "BalanceOf<T>", "u32"}, Documentation: []Text{" A bid was successfully removed (before being accepted as a gilt).", " \\[ who, amount, duration \\]"}}, EventMetadataV4{Name: "GiltIssued", Args: []Type{"ActiveIndex", "T::BlockNumber", "AccountId", "BalanceOf<T>"}, Documentation: []Text{" A bid was accepted as a gilt. The balance may not be released until expiry.", " \\[ index, expiry, who, amount \\]"}}, EventMetadataV4{Name: "GiltThawed", Args: []Type{"ActiveIndex", "AccountId", "BalanceOf<T>", "BalanceOf<T>"}, Documentation: []Text{" An expired gilt has been thawed.", " \\[ index, who, original_amount, additional_amount \\]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "QueueCount", Type: "u32", Value: Bytes{0x2c, 0x1, 0x0, 0x0}, Documentation: []Text{" Number of duration queues in total. This sets the maximum duration supported, which is", " this value multiplied by `Period`."}}, ModuleConstantMetadataV6{Name: "MaxQueueLen", Type: "u32", Value: Bytes{0xe8, 0x3, 0x0, 0x0}, Documentation: []Text{" Maximum number of items that may be in each duration queue."}}, ModuleConstantMetadataV6{Name: "FifoQueueLen", Type: "u32", Value: Bytes{0xf4, 0x1, 0x0, 0x0}, Documentation: []Text{" Portion of the queue which is free from ordering and just a FIFO.", "", " Must be no greater than `MaxQueueLen`."}}, ModuleConstantMetadataV6{Name: "Period", Type: "T::BlockNumber", Value: Bytes{0x0, 0x2f, 0xd, 0x0}, Documentation: []Text{" The base period for the duration queues. This is the common multiple across all", " supported freezing durations that can be bid upon."}}, ModuleConstantMetadataV6{Name: "MinFreeze", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x0, 0xc1, 0x6f, 0xf2, 0x86, 0x23, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount of funds that may be offered to freeze for a gilt. Note that this", " does not actually limit the amount which may be frozen in a gilt since gilts may be", " split up in order to satisfy the desired amount of funds under gilts.", "", " It should be at least big enough to ensure that there is no possible storage spam attack", " or queue-filling attack."}}, ModuleConstantMetadataV6{Name: "IntakePeriod", Type: "T::BlockNumber", Value: Bytes{0xa, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of blocks between consecutive attempts to issue more gilts in an effort to", " get to the target amount to be frozen.", "", " A larger value results in fewer storage hits each block, but a slower period to get to", " the target."}}, ModuleConstantMetadataV6{Name: "MaxIntakeBids", Type: "u32", Value: Bytes{0xa, 0x0, 0x0, 0x0}, Documentation: []Text{" The maximum amount of bids that can be turned into issued gilts each block. A larger", " value here means less of the block available for transactions should there be a glut of", " bids to make into gilts to reach the target."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "DurationTooSmall", Documentation: []Text{" The duration of the bid is less than one."}}, ErrorMetadataV8{Name: "DurationTooBig", Documentation: []Text{" The duration is the bid is greater than the number of queues."}}, ErrorMetadataV8{Name: "AmountTooSmall", Documentation: []Text{" The amount of the bid is less than the minimum allowed."}}, ErrorMetadataV8{Name: "BidTooLow", Documentation: []Text{" The queue for the bid's duration is full and the amount bid is too low to get in through", " replacing an existing bid."}}, ErrorMetadataV8{Name: "Unknown", Documentation: []Text{" Gilt index is unknown."}}, ErrorMetadataV8{Name: "NotOwner", Documentation: []Text{" Not the owner of the gilt."}}, ErrorMetadataV8{Name: "NotExpired", Documentation: []Text{" Gilt not yet at expiry date."}}, ErrorMetadataV8{Name: "NotFound", Documentation: []Text{" The given bid for retraction is not found."}}}, Index: 0x25}, ModuleMetadataV13{Name: "Uniques", HasStorage: true, Storage: StorageMetadataV13{Prefix: "Uniques", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Class", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::ClassId", Value: "ClassDetails<T::AccountId, DepositBalanceOf<T, I>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Details of an asset class."}}, StorageFunctionMetadataV13{Name: "Account", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: true, AsNMap: NMapTypeV13{Keys: []Type{"T::AccountId", "T::ClassId", "T::InstanceId"}, Hashers: []StorageHasherV10{StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, Value: "()"}}, Fallback: Bytes{0x0}, Documentation: []Text{" The assets held by any given account; set out this way so that assets owned by a single", " account can be enumerated."}}, StorageFunctionMetadataV13{Name: "Asset", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "T::ClassId", Key2: "T::InstanceId", Value: "InstanceDetails<T::AccountId, DepositBalanceOf<T, I>>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" The assets in existence and their ownership details."}}, StorageFunctionMetadataV13{Name: "ClassMetadataOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::ClassId", Value: "ClassMetadata<DepositBalanceOf<T, I>, T::StringLimit>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Metadata of an asset class."}}, StorageFunctionMetadataV13{Name: "InstanceMetadataOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "T::ClassId", Key2: "T::InstanceId", Value: "InstanceMetadata<DepositBalanceOf<T, I>, T::StringLimit>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Metadata of an asset instance."}}, StorageFunctionMetadataV13{Name: "Attribute", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: true, AsNMap: NMapTypeV13{Keys: []Type{"T::ClassId", "Option<T::InstanceId>", "BoundedVec<u8, T::KeyLimit>"}, Hashers: []StorageHasherV10{StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, Value: "(BoundedVec<u8, T::ValueLimit>, DepositBalanceOf<T, I>)"}}, Fallback: Bytes{0x0}, Documentation: []Text{" Metadata of an asset class."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "create", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}, FunctionArgumentMetadata{Name: "admin", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Issue a new class of non-fungible assets from a public origin.", "", " This new asset class has no assets initially and its owner is the origin.", "", " The origin must be Signed and the sender must have sufficient funds free.", "", " `AssetDeposit` funds of sender are reserved.", "", " Parameters:", " - `class`: The identifier of the new asset class. This must not be currently in use.", " - `admin`: The admin of this class of assets. The admin is the initial address of each", " member of the asset class's admin team.", "", " Emits `Created` event when successful.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "force_create", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}, FunctionArgumentMetadata{Name: "owner", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "free_holding", Type: "bool"}}, Documentation: []Text{" Issue a new class of non-fungible assets from a privileged origin.", "", " This new asset class has no assets initially.", "", " The origin must conform to `ForceOrigin`.", "", " Unlike `create`, no funds are reserved.", "", " - `class`: The identifier of the new asset. This must not be currently in use.", " - `owner`: The owner of this class of assets. The owner has full superuser permissions", " over this asset, but may later change and configure the permissions using", " `transfer_ownership` and `set_team`.", "", " Emits `ForceCreated` event when successful.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "destroy", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}, FunctionArgumentMetadata{Name: "witness", Type: "DestroyWitness"}}, Documentation: []Text{" Destroy a class of fungible assets.", "", " The origin must conform to `ForceOrigin` or must be `Signed` and the sender must be the", " owner of the asset `class`.", "", " - `class`: The identifier of the asset class to be destroyed.", " - `witness`: Information on the instances minted in the asset class. This must be", " correct.", "", " Emits `Destroyed` event when successful.", "", " Weight: `O(n + m)` where:", " - `n = witness.instances`", " - `m = witness.instance_metdadatas`", " - `a = witness.attributes`"}}, FunctionMetadataV4{Name: "mint", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}, FunctionArgumentMetadata{Name: "instance", Type: "Compact<T::InstanceId>"}, FunctionArgumentMetadata{Name: "owner", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Mint an asset instance of a particular class.", "", " The origin must be Signed and the sender must be the Issuer of the asset `class`.", "", " - `class`: The class of the asset to be minted.", " - `instance`: The instance value of the asset to be minted.", " - `beneficiary`: The initial owner of the minted asset.", "", " Emits `Issued` event when successful.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "burn", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}, FunctionArgumentMetadata{Name: "instance", Type: "Compact<T::InstanceId>"}, FunctionArgumentMetadata{Name: "check_owner", Type: "Option<<T::Lookup as StaticLookup>::Source>"}}, Documentation: []Text{" Destroy a single asset instance.", "", " Origin must be Signed and the sender should be the Admin of the asset `class`.", "", " - `class`: The class of the asset to be burned.", " - `instance`: The instance of the asset to be burned.", " - `check_owner`: If `Some` then the operation will fail with `WrongOwner` unless the", "   asset is owned by this value.", "", " Emits `Burned` with the actual amount burned.", "", " Weight: `O(1)`", " Modes: `check_owner.is_some()`."}}, FunctionMetadataV4{Name: "transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}, FunctionArgumentMetadata{Name: "instance", Type: "Compact<T::InstanceId>"}, FunctionArgumentMetadata{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Move an asset from the sender account to another.", "", " Origin must be Signed and the signing account must be either:", " - the Admin of the asset `class`;", " - the Owner of the asset `instance`;", " - the approved delegate for the asset `instance` (in this case, the approval is reset).", "", " Arguments:", " - `class`: The class of the asset to be transferred.", " - `instance`: The instance of the asset to be transferred.", " - `dest`: The account to receive ownership of the asset.", "", " Emits `Transferred`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "redeposit", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}, FunctionArgumentMetadata{Name: "instances", Type: "Vec<T::InstanceId>"}}, Documentation: []Text{" Reevaluate the deposits on some assets.", "", " Origin must be Signed and the sender should be the Owner of the asset `class`.", "", " - `class`: The class of the asset to be frozen.", " - `instances`: The instances of the asset class whose deposits will be reevaluated.", "", " NOTE: This exists as a best-effort function. Any asset instances which are unknown or", " in the case that the owner account does not have reservable funds to pay for a", " deposit increase are ignored. Generally the owner isn't going to call this on instances", " whose existing deposit is less than the refreshed deposit as it would only cost them,", " so it's of little consequence.", "", " It will still return an error in the case that the class is unknown of the signer is", " not permitted to call it.", "", " Weight: `O(instances.len())`"}}, FunctionMetadataV4{Name: "freeze", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}, FunctionArgumentMetadata{Name: "instance", Type: "Compact<T::InstanceId>"}}, Documentation: []Text{" Disallow further unprivileged transfer of an asset instance.", "", " Origin must be Signed and the sender should be the Freezer of the asset `class`.", "", " - `class`: The class of the asset to be frozen.", " - `instance`: The instance of the asset to be frozen.", "", " Emits `Frozen`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "thaw", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}, FunctionArgumentMetadata{Name: "instance", Type: "Compact<T::InstanceId>"}}, Documentation: []Text{" Re-allow unprivileged transfer of an asset instance.", "", " Origin must be Signed and the sender should be the Freezer of the asset `class`.", "", " - `class`: The class of the asset to be thawed.", " - `instance`: The instance of the asset to be thawed.", "", " Emits `Thawed`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "freeze_class", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}}, Documentation: []Text{" Disallow further unprivileged transfers for a whole asset class.", "", " Origin must be Signed and the sender should be the Freezer of the asset `class`.", "", " - `class`: The asset class to be frozen.", "", " Emits `ClassFrozen`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "thaw_class", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}}, Documentation: []Text{" Re-allow unprivileged transfers for a whole asset class.", "", " Origin must be Signed and the sender should be the Admin of the asset `class`.", "", " - `class`: The class to be thawed.", "", " Emits `ClassThawed`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "transfer_ownership", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}, FunctionArgumentMetadata{Name: "owner", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Change the Owner of an asset class.", "", " Origin must be Signed and the sender should be the Owner of the asset `class`.", "", " - `class`: The asset class whose owner should be changed.", " - `owner`: The new Owner of this asset class.", "", " Emits `OwnerChanged`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "set_team", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}, FunctionArgumentMetadata{Name: "issuer", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "admin", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "freezer", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Change the Issuer, Admin and Freezer of an asset class.", "", " Origin must be Signed and the sender should be the Owner of the asset `class`.", "", " - `class`: The asset class whose team should be changed.", " - `issuer`: The new Issuer of this asset class.", " - `admin`: The new Admin of this asset class.", " - `freezer`: The new Freezer of this asset class.", "", " Emits `TeamChanged`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "approve_transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}, FunctionArgumentMetadata{Name: "instance", Type: "Compact<T::InstanceId>"}, FunctionArgumentMetadata{Name: "delegate", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Approve an instance to be transferred by a delegated third-party account.", "", " Origin must be Signed and must be the owner of the asset `instance`.", "", " - `class`: The class of the asset to be approved for delegated transfer.", " - `instance`: The instance of the asset to be approved for delegated transfer.", " - `delegate`: The account to delegate permission to transfer the asset.", "", " Emits `ApprovedTransfer` on success.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "cancel_approval", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}, FunctionArgumentMetadata{Name: "instance", Type: "Compact<T::InstanceId>"}, FunctionArgumentMetadata{Name: "maybe_check_delegate", Type: "Option<<T::Lookup as StaticLookup>::Source>"}}, Documentation: []Text{" Cancel the prior approval for the transfer of an asset by a delegate.", "", " Origin must be either:", " - the `Force` origin;", " - `Signed` with the signer being the Admin of the asset `class`;", " - `Signed` with the signer being the Owner of the asset `instance`;", "", " Arguments:", " - `class`: The class of the asset of whose approval will be cancelled.", " - `instance`: The instance of the asset of whose approval will be cancelled.", " - `maybe_check_delegate`: If `Some` will ensure that the given account is the one to", "   which permission of transfer is delegated.", "", " Emits `ApprovalCancelled` on success.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "force_asset_status", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}, FunctionArgumentMetadata{Name: "owner", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "issuer", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "admin", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "freezer", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "free_holding", Type: "bool"}, FunctionArgumentMetadata{Name: "is_frozen", Type: "bool"}}, Documentation: []Text{" Alter the attributes of a given asset.", "", " Origin must be `ForceOrigin`.", "", " - `class`: The identifier of the asset.", " - `owner`: The new Owner of this asset.", " - `issuer`: The new Issuer of this asset.", " - `admin`: The new Admin of this asset.", " - `freezer`: The new Freezer of this asset.", " - `free_holding`: Whether a deposit is taken for holding an instance of this asset", "   class.", " - `is_frozen`: Whether this asset class is frozen except for permissioned/admin", " instructions.", "", " Emits `AssetStatusChanged` with the identity of the asset.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "set_attribute", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}, FunctionArgumentMetadata{Name: "maybe_instance", Type: "Option<T::InstanceId>"}, FunctionArgumentMetadata{Name: "key", Type: "BoundedVec<u8, T::KeyLimit>"}, FunctionArgumentMetadata{Name: "value", Type: "BoundedVec<u8, T::ValueLimit>"}}, Documentation: []Text{" Set an attribute for an asset class or instance.", "", " Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the", " asset `class`.", "", " If the origin is Signed, then funds of signer are reserved according to the formula:", " `MetadataDepositBase + DepositPerByte * (key.len + value.len)` taking into", " account any already reserved funds.", "", " - `class`: The identifier of the asset class whose instance's metadata to set.", " - `maybe_instance`: The identifier of the asset instance whose metadata to set.", " - `key`: The key of the attribute.", " - `value`: The value to which to set the attribute.", "", " Emits `AttributeSet`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "clear_attribute", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}, FunctionArgumentMetadata{Name: "maybe_instance", Type: "Option<T::InstanceId>"}, FunctionArgumentMetadata{Name: "key", Type: "BoundedVec<u8, T::KeyLimit>"}}, Documentation: []Text{" Set an attribute for an asset class or instance.", "", " Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the", " asset `class`.", "", " If the origin is Signed, then funds of signer are reserved according to the formula:", " `MetadataDepositBase + DepositPerByte * (key.len + value.len)` taking into", " account any already reserved funds.", "", " - `class`: The identifier of the asset class whose instance's metadata to set.", " - `instance`: The identifier of the asset instance whose metadata to set.", " - `key`: The key of the attribute.", " - `value`: The value to which to set the attribute.", "", " Emits `AttributeSet`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "set_metadata", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}, FunctionArgumentMetadata{Name: "instance", Type: "Compact<T::InstanceId>"}, FunctionArgumentMetadata{Name: "data", Type: "BoundedVec<u8, T::StringLimit>"}, FunctionArgumentMetadata{Name: "is_frozen", Type: "bool"}}, Documentation: []Text{" Set the metadata for an asset instance.", "", " Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the", " asset `class`.", "", " If the origin is Signed, then funds of signer are reserved according to the formula:", " `MetadataDepositBase + DepositPerByte * data.len` taking into", " account any already reserved funds.", "", " - `class`: The identifier of the asset class whose instance's metadata to set.", " - `instance`: The identifier of the asset instance whose metadata to set.", " - `data`: The general information of this asset. Limited in length by `StringLimit`.", " - `is_frozen`: Whether the metadata should be frozen against further changes.", "", " Emits `MetadataSet`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "clear_metadata", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}, FunctionArgumentMetadata{Name: "instance", Type: "Compact<T::InstanceId>"}}, Documentation: []Text{" Clear the metadata for an asset instance.", "", " Origin must be either `ForceOrigin` or Signed and the sender should be the Owner of the", " asset `instance`.", "", " Any deposit is freed for the asset class owner.", "", " - `class`: The identifier of the asset class whose instance's metadata to clear.", " - `instance`: The identifier of the asset instance whose metadata to clear.", "", " Emits `MetadataCleared`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "set_class_metadata", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}, FunctionArgumentMetadata{Name: "data", Type: "BoundedVec<u8, T::StringLimit>"}, FunctionArgumentMetadata{Name: "is_frozen", Type: "bool"}}, Documentation: []Text{" Set the metadata for an asset class.", "", " Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of", " the asset `class`.", "", " If the origin is `Signed`, then funds of signer are reserved according to the formula:", " `MetadataDepositBase + DepositPerByte * data.len` taking into", " account any already reserved funds.", "", " - `class`: The identifier of the asset whose metadata to update.", " - `data`: The general information of this asset. Limited in length by `StringLimit`.", " - `is_frozen`: Whether the metadata should be frozen against further changes.", "", " Emits `ClassMetadataSet`.", "", " Weight: `O(1)`"}}, FunctionMetadataV4{Name: "clear_class_metadata", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "class", Type: "Compact<T::ClassId>"}}, Documentation: []Text{" Clear the metadata for an asset class.", "", " Origin must be either `ForceOrigin` or `Signed` and the sender should be the Owner of", " the asset `class`.", "", " Any deposit is freed for the asset class owner.", "", " - `class`: The identifier of the asset class whose metadata to clear.", "", " Emits `ClassMetadataCleared`.", "", " Weight: `O(1)`"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Created", Args: []Type{"ClassId", "AccountId", "AccountId"}, Documentation: []Text{" An asset class was created. \\[ class, creator, owner \\]"}}, EventMetadataV4{Name: "ForceCreated", Args: []Type{"ClassId", "AccountId"}, Documentation: []Text{" An asset class was force-created. \\[ class, owner \\]"}}, EventMetadataV4{Name: "Destroyed", Args: []Type{"ClassId"}, Documentation: []Text{" An asset `class` was destroyed. \\[ class \\]"}}, EventMetadataV4{Name: "Issued", Args: []Type{"ClassId", "InstanceId", "AccountId"}, Documentation: []Text{" An asset `instace` was issued. \\[ class, instance, owner \\]"}}, EventMetadataV4{Name: "Transferred", Args: []Type{"ClassId", "InstanceId", "AccountId", "AccountId"}, Documentation: []Text{" An asset `instace` was transferred. \\[ class, instance, from, to \\]"}}, EventMetadataV4{Name: "Burned", Args: []Type{"ClassId", "InstanceId", "AccountId"}, Documentation: []Text{" An asset `instance` was destroyed. \\[ class, instance, owner \\]"}}, EventMetadataV4{Name: "Frozen", Args: []Type{"ClassId", "InstanceId"}, Documentation: []Text{" Some asset `instance` was frozen. \\[ class, instance \\]"}}, EventMetadataV4{Name: "Thawed", Args: []Type{"ClassId", "InstanceId"}, Documentation: []Text{" Some asset `instance` was thawed. \\[ class, instance \\]"}}, EventMetadataV4{Name: "ClassFrozen", Args: []Type{"ClassId"}, Documentation: []Text{" Some asset `class` was frozen. \\[ class \\]"}}, EventMetadataV4{Name: "ClassThawed", Args: []Type{"ClassId"}, Documentation: []Text{" Some asset `class` was thawed. \\[ class \\]"}}, EventMetadataV4{Name: "OwnerChanged", Args: []Type{"ClassId", "AccountId"}, Documentation: []Text{" The owner changed \\[ class, new_owner \\]"}}, EventMetadataV4{Name: "TeamChanged", Args: []Type{"ClassId", "AccountId", "AccountId", "AccountId"}, Documentation: []Text{" The management team changed \\[ class, issuer, admin, freezer \\]"}}, EventMetadataV4{Name: "ApprovedTransfer", Args: []Type{"ClassId", "InstanceId", "AccountId", "AccountId"}, Documentation: []Text{" An `instance` of an asset `class` has been approved by the `owner` for transfer by a", " `delegate`.", " \\[ class, instance, owner, delegate \\]"}}, EventMetadataV4{Name: "ApprovalCancelled", Args: []Type{"ClassId", "InstanceId", "AccountId", "AccountId"}, Documentation: []Text{" An approval for a `delegate` account to transfer the `instance` of an asset `class` was", " cancelled by its `owner`.", " \\[ class, instance, owner, delegate \\]"}}, EventMetadataV4{Name: "AssetStatusChanged", Args: []Type{"ClassId"}, Documentation: []Text{" An asset `class` has had its attributes changed by the `Force` origin.", " \\[ class \\]"}}, EventMetadataV4{Name: "ClassMetadataSet", Args: []Type{"ClassId", "BoundedVec<u8, T::StringLimit>", "bool"}, Documentation: []Text{" New metadata has been set for an asset class. \\[ class, data, is_frozen \\]"}}, EventMetadataV4{Name: "ClassMetadataCleared", Args: []Type{"ClassId"}, Documentation: []Text{" Metadata has been cleared for an asset class. \\[ class \\]"}}, EventMetadataV4{Name: "MetadataSet", Args: []Type{"ClassId", "InstanceId", "BoundedVec<u8, T::StringLimit>", "bool"}, Documentation: []Text{" New metadata has been set for an asset instance.", " \\[ class, instance, data, is_frozen \\]"}}, EventMetadataV4{Name: "MetadataCleared", Args: []Type{"ClassId", "InstanceId"}, Documentation: []Text{" Metadata has been cleared for an asset instance. \\[ class, instance \\]"}}, EventMetadataV4{Name: "Redeposited", Args: []Type{"ClassId", "Vec<T::InstanceId>"}, Documentation: []Text{" Metadata has been cleared for an asset instance. \\[ class, successful_instances \\]"}}, EventMetadataV4{Name: "AttributeSet", Args: []Type{"ClassId", "Option<T::InstanceId>", "BoundedVec<u8, T::KeyLimit>", "BoundedVec<u8, T::ValueLimit>"}, Documentation: []Text{" New attribute metadata has been set for an asset class or instance.", " \\[ class, maybe_instance, key, value \\]"}}, EventMetadataV4{Name: "AttributeCleared", Args: []Type{"ClassId", "Option<T::InstanceId>", "BoundedVec<u8, T::KeyLimit>"}, Documentation: []Text{" Attribute metadata has been cleared for an asset class or instance.", " \\[ class, maybe_instance, key, maybe_value \\]"}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "NoPermission", Documentation: []Text{" The signing account has no permission to do the operation."}}, ErrorMetadataV8{Name: "Unknown", Documentation: []Text{" The given asset ID is unknown."}}, ErrorMetadataV8{Name: "AlreadyExists", Documentation: []Text{" The asset instance ID has already been used for an asset."}}, ErrorMetadataV8{Name: "WrongOwner", Documentation: []Text{" The owner turned out to be different to what was expected."}}, ErrorMetadataV8{Name: "BadWitness", Documentation: []Text{" Invalid witness data given."}}, ErrorMetadataV8{Name: "InUse", Documentation: []Text{" The asset ID is already taken."}}, ErrorMetadataV8{Name: "Frozen", Documentation: []Text{" The asset instance or class is frozen."}}, ErrorMetadataV8{Name: "WrongDelegate", Documentation: []Text{" The delegate turned out to be different to what was expected."}}, ErrorMetadataV8{Name: "NoDelegate", Documentation: []Text{" There is no delegate approved."}}, ErrorMetadataV8{Name: "Unapproved", Documentation: []Text{" No approval exists that would allow the transfer."}}}, Index: 0x26}, ModuleMetadataV13{Name: "TransactionStorage", HasStorage: true, Storage: StorageMetadataV13{Prefix: "TransactionStorage", Items: []StorageFunctionMetadataV13{StorageFunctionMetadataV13{Name: "Transactions", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::BlockNumber", Value: "Vec<TransactionInfo>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Collection of transaction metadata by block number."}}, StorageFunctionMetadataV13{Name: "ChunkCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::BlockNumber", Value: "u32", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Count indexed chunks for each block."}}, StorageFunctionMetadataV13{Name: "ByteFee", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "BalanceOf<T>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Storage fee per byte."}}, StorageFunctionMetadataV13{Name: "EntryFee", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "BalanceOf<T>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Storage fee per transaction."}}, StorageFunctionMetadataV13{Name: "MaxTransactionSize", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Maximum data set in a single transaction in bytes."}}, StorageFunctionMetadataV13{Name: "MaxBlockTransactions", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Maximum number of indexed transactions in the block."}}, StorageFunctionMetadataV13{Name: "StoragePeriod", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Storage period for data in blocks. Should match `sp_storage_proof::DEFAULT_STORAGE_PERIOD`", " for block authoring."}}, StorageFunctionMetadataV13{Name: "BlockTransactions", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "Vec<TransactionInfo>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text(nil)}, StorageFunctionMetadataV13{Name: "ProofChecked", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV13{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}, IsNMap: false, AsNMap: NMapTypeV13{Keys: []Type(nil), Hashers: []StorageHasherV10(nil), Value: ""}}, Fallback: Bytes{0x0}, Documentation: []Text{" Was the proof checked in this block?"}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "store", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "data", Type: "Vec<u8>"}}, Documentation: []Text{" Index and store data on chain. Minimum data size is 1 bytes, maximum is `MaxTransactionSize`.", " Data will be removed after `STORAGE_PERIOD` blocks, unless `renew` is called.", " # <weight>", " - n*log(n) of data size, as all data is pushed to an in-memory trie.", " Additionally contains a DB write.", " # </weight>"}}, FunctionMetadataV4{Name: "renew", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "block", Type: "T::BlockNumber"}, FunctionArgumentMetadata{Name: "index", Type: "u32"}}, Documentation: []Text{" Renew previously stored data. Parameters are the block number that contains", " previous `store` or `renew` call and transaction index within that block.", " Transaction index is emitted in the `Stored` or `Renewed` event.", " Applies same fees as `store`.", " # <weight>", " - Constant.", " # </weight>"}}, FunctionMetadataV4{Name: "check_proof", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proof", Type: "TransactionStorageProof"}}, Documentation: []Text{" Check storage proof for block number `block_number() - StoragePeriod`.", " If such block does not exist the proof is expected to be `None`.", " # <weight>", " - Linear w.r.t the number of indexed transactions in the proved block for random probing.", " There's a DB read for each transaction.", " Here we assume a maximum of 100 probed transactions.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Stored", Args: []Type{"u32"}, Documentation: []Text{" Stored data under specified index."}}, EventMetadataV4{Name: "Renewed", Args: []Type{"u32"}, Documentation: []Text{" Renewed data under specified index."}}, EventMetadataV4{Name: "ProofChecked", Args: []Type(nil), Documentation: []Text{" Storage proof was successfully checked."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InsufficientFunds", Documentation: []Text{" Insufficient account balance."}}, ErrorMetadataV8{Name: "NotConfigured", Documentation: []Text{" Invalid configuration."}}, ErrorMetadataV8{Name: "RenewedNotFound", Documentation: []Text{" Renewed extrinsic is not found."}}, ErrorMetadataV8{Name: "EmptyTransaction", Documentation: []Text{" Attempting to store empty transaction"}}, ErrorMetadataV8{Name: "UnexpectedProof", Documentation: []Text{" Proof was not expected in this block."}}, ErrorMetadataV8{Name: "InvalidProof", Documentation: []Text{" Proof failed verification."}}, ErrorMetadataV8{Name: "MissingProof", Documentation: []Text{" Missing storage proof."}}, ErrorMetadataV8{Name: "MissingStateData", Documentation: []Text{" Unable to verify proof becasue state data is missing."}}, ErrorMetadataV8{Name: "DoubleCheck", Documentation: []Text{" Double proof check in the block."}}, ErrorMetadataV8{Name: "ProofNotChecked", Documentation: []Text{" Storage proof was not checked in the block."}}, ErrorMetadataV8{Name: "TransactionTooLarge", Documentation: []Text{" Transaction is too large."}}, ErrorMetadataV8{Name: "TooManyTransactions", Documentation: []Text{" Too many transactions in the block."}}, ErrorMetadataV8{Name: "BadContext", Documentation: []Text{" Attempted to call `store` outside of block execution."}}}, Index: 0x27}}, Extrinsic: ExtrinsicV11{Version: 0x4, SignedExtensions: []string{"CheckSpecVersion", "CheckTxVersion", "CheckGenesis", "CheckMortality", "CheckNonce", "CheckWeight", "ChargeTransactionPayment"}}}}
