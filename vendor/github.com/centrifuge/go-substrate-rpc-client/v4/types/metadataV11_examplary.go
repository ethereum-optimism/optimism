// Go Substrate RPC Client (GSRPC) provides APIs and types around Polkadot and any Substrate-based chain RPC calls
//
// Copyright 2019 Centrifuge GmbH
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package types

//Parsed from ExamplaryMetadataV11SubstrateString
var ExamplaryMetadataV11Substrate = &Metadata{MagicNumber: 0x6174656d, Version: 0xb, AsMetadataV4: MetadataV4{Modules: []ModuleMetadataV4(nil)}, AsMetadataV7: MetadataV7{Modules: []ModuleMetadataV7(nil)}, AsMetadataV8: MetadataV8{Modules: []ModuleMetadataV8(nil)}, AsMetadataV9: MetadataV9{Modules: []ModuleMetadataV8(nil)}, AsMetadataV10: MetadataV10{Modules: []ModuleMetadataV10(nil)}, AsMetadataV11: MetadataV11{MetadataV10: MetadataV10{Modules: []ModuleMetadataV10{ModuleMetadataV10{Name: "System", HasStorage: true, Storage: StorageMetadataV10{Prefix: "System", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Account", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::AccountId", Value: "AccountInfo<T::Index, T::AccountData>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The full account information for a particular account ID."}}, StorageFunctionMetadataV10{Name: "ExtrinsicCount", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Total extrinsics count for the current block."}}, StorageFunctionMetadataV10{Name: "BlockWeight", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "weights::ExtrinsicsWeight", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The current weight for the block."}}, StorageFunctionMetadataV10{Name: "AllExtrinsicsLen", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Total length (in bytes) for all extrinsics put together, for the current block."}}, StorageFunctionMetadataV10{Name: "BlockHash", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::BlockNumber", Value: "T::Hash", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Map of block numbers to block hashes."}}, StorageFunctionMetadataV10{Name: "ExtrinsicData", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "u32", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Extrinsics data for the current block (maps an extrinsic's index to its data)."}}, StorageFunctionMetadataV10{Name: "Number", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The current block number being processed. Set by `execute_block`."}}, StorageFunctionMetadataV10{Name: "ParentHash", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::Hash", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Hash of the previous block."}}, StorageFunctionMetadataV10{Name: "ExtrinsicsRoot", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::Hash", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Extrinsics root of the current block, also part of the block header."}}, StorageFunctionMetadataV10{Name: "Digest", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "DigestOf<T>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Digest of the current block, also part of the block header."}}, StorageFunctionMetadataV10{Name: "Events", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<EventRecord<T::Event, T::Hash>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Events deposited for the current block."}}, StorageFunctionMetadataV10{Name: "EventCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "EventIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of events in the `Events<T>` list."}}, StorageFunctionMetadataV10{Name: "EventTopics", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::Hash", Value: "Vec<(T::BlockNumber, EventIndex)>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Mapping between a topic (represented by T::Hash) and a vector of indexes", " of events in the `<Events<T>>` list.", "", " All topic vectors have deterministic storage locations depending on the topic. This", " allows light-clients to leverage the changes trie storage tracking mechanism and", " in case of changes fetch the list of events of interest.", "", " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just", " the `EventIndex` then in case if the topic has the same contents on the next block", " no notification will be triggered thus the event might be lost."}}, StorageFunctionMetadataV10{Name: "LastRuntimeUpgrade", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "LastRuntimeUpgradeInfo", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."}}, StorageFunctionMetadataV10{Name: "ExecutionPhase", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Phase", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The execution phase of the block."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "fill_block", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "_ratio", Type: "Perbill"}}, Documentation: []Text{" A dispatch that will fill the block weight up to the given ratio."}}, FunctionMetadataV4{Name: "remark", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "_remark", Type: "Vec<u8>"}}, Documentation: []Text{" Make some on-chain remark.", "", " # <weight>", " - `O(1)`", " - Base Weight: 0.665 µs, independent of remark length.", " - No DB operations.", " # </weight>"}}, FunctionMetadataV4{Name: "set_heap_pages", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "pages", Type: "u64"}}, Documentation: []Text{" Set the number of pages in the WebAssembly environment's heap.", "", " # <weight>", " - `O(1)`", " - 1 storage write.", " - Base Weight: 1.405 µs", " - 1 write to HEAP_PAGES", " # </weight>"}}, FunctionMetadataV4{Name: "set_code", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "code", Type: "Vec<u8>"}}, Documentation: []Text{" Set the new runtime code.", "", " # <weight>", " - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`", " - 1 storage write (codec `O(C)`).", " - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is expensive).", " - 1 event.", " The weight of this function is dependent on the runtime, but generally this is very expensive.", " We will treat this as a full block.", " # </weight>"}}, FunctionMetadataV4{Name: "set_code_without_checks", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "code", Type: "Vec<u8>"}}, Documentation: []Text{" Set the new runtime code without doing any checks of the given `code`.", "", " # <weight>", " - `O(C)` where `C` length of `code`", " - 1 storage write (codec `O(C)`).", " - 1 event.", " The weight of this function is dependent on the runtime. We will treat this as a full block.", " # </weight>"}}, FunctionMetadataV4{Name: "set_changes_trie_config", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "changes_trie_config", Type: "Option<ChangesTrieConfiguration>"}}, Documentation: []Text{" Set the new changes trie configuration.", "", " # <weight>", " - `O(1)`", " - 1 storage write or delete (codec `O(1)`).", " - 1 call to `deposit_log`: Uses `append` API, so O(1)", " - Base Weight: 7.218 µs", " - DB Weight:", "     - Writes: Changes Trie, System Digest", " # </weight>"}}, FunctionMetadataV4{Name: "set_storage", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "items", Type: "Vec<KeyValue>"}}, Documentation: []Text{" Set some items of storage.", "", " # <weight>", " - `O(I)` where `I` length of `items`", " - `I` storage writes (`O(1)`).", " - Base Weight: 0.568 * i µs", " - Writes: Number of items", " # </weight>"}}, FunctionMetadataV4{Name: "kill_storage", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "keys", Type: "Vec<Key>"}}, Documentation: []Text{" Kill some items from storage.", "", " # <weight>", " - `O(IK)` where `I` length of `keys` and `K` length of one key", " - `I` storage deletions.", " - Base Weight: .378 * i µs", " - Writes: Number of items", " # </weight>"}}, FunctionMetadataV4{Name: "kill_prefix", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "prefix", Type: "Key"}, FunctionArgumentMetadata{Name: "_subkeys", Type: "u32"}}, Documentation: []Text{" Kill all storage items with a key that starts with the given prefix.", "", " **NOTE:** We rely on the Root origin to provide us the number of subkeys under", " the prefix we are removing to accurately calculate the weight of this function.", "", " # <weight>", " - `O(P)` where `P` amount of keys with prefix `prefix`", " - `P` storage deletions.", " - Base Weight: 0.834 * P µs", " - Writes: Number of subkeys + 1", " # </weight>"}}, FunctionMetadataV4{Name: "suicide", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Kill the sending account, assuming there are no references outstanding and the composite", " data is equal to its default value.", "", " # <weight>", " - `O(1)`", " - 1 storage read and deletion.", " --------------------", " Base Weight: 8.626 µs", " No DB Read or Write operations because caller is already in overlay", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "ExtrinsicSuccess", Args: []Type{"DispatchInfo"}, Documentation: []Text{" An extrinsic completed successfully. [info]"}}, EventMetadataV4{Name: "ExtrinsicFailed", Args: []Type{"DispatchError", "DispatchInfo"}, Documentation: []Text{" An extrinsic failed. [error, info]"}}, EventMetadataV4{Name: "CodeUpdated", Args: []Type(nil), Documentation: []Text{" `:code` was updated."}}, EventMetadataV4{Name: "NewAccount", Args: []Type{"AccountId"}, Documentation: []Text{" A new [account] was created."}}, EventMetadataV4{Name: "KilledAccount", Args: []Type{"AccountId"}, Documentation: []Text{" An [account] was reaped."}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "BlockHashCount", Type: "T::BlockNumber", Value: Bytes{0x60, 0x9, 0x0, 0x0}, Documentation: []Text{" The maximum number of blocks to allow in mortal eras."}}, ModuleConstantMetadataV6{Name: "MaximumBlockWeight", Type: "Weight", Value: Bytes{0x0, 0x20, 0x4a, 0xa9, 0xd1, 0x1, 0x0, 0x0}, Documentation: []Text{" The maximum weight of a block."}}, ModuleConstantMetadataV6{Name: "DbWeight", Type: "RuntimeDbWeight", Value: Bytes{0x40, 0x78, 0x7d, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe1, 0xf5, 0x5, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The weight of runtime database operations the runtime can invoke."}}, ModuleConstantMetadataV6{Name: "BlockExecutionWeight", Type: "Weight", Value: Bytes{0x0, 0xf2, 0x5, 0x2a, 0x1, 0x0, 0x0, 0x0}, Documentation: []Text{" The base weight of executing a block, independent of the transactions in the block."}}, ModuleConstantMetadataV6{Name: "ExtrinsicBaseWeight", Type: "Weight", Value: Bytes{0x40, 0x59, 0x73, 0x7, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The base weight of an Extrinsic in the block, independent of the of extrinsic being executed."}}, ModuleConstantMetadataV6{Name: "MaximumBlockLength", Type: "u32", Value: Bytes{0x0, 0x0, 0x50, 0x0}, Documentation: []Text{" The maximum length of a block (in bytes)."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InvalidSpecName", Documentation: []Text{" The name of specification does not match between the current runtime", " and the new runtime."}}, ErrorMetadataV8{Name: "SpecVersionNeedsToIncrease", Documentation: []Text{" The specification version is not allowed to decrease between the current runtime", " and the new runtime."}}, ErrorMetadataV8{Name: "FailedToExtractRuntimeVersion", Documentation: []Text{" Failed to extract the runtime version from the new runtime.", "", " Either calling `Core_version` or decoding `RuntimeVersion` failed."}}, ErrorMetadataV8{Name: "NonDefaultComposite", Documentation: []Text{" Suicide called when the account has non-default composite data."}}, ErrorMetadataV8{Name: "NonZeroRefCount", Documentation: []Text{" There is a non-zero reference count preventing the account from being purged."}}}}, ModuleMetadataV10{Name: "Utility", HasStorage: false, Storage: StorageMetadataV10{Prefix: "", Items: []StorageFunctionMetadataV10(nil)}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "batch", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "calls", Type: "Vec<<T as Trait>::Call>"}}, Documentation: []Text{" Send a batch of dispatch calls.", "", " May be called from any origin.", "", " - `calls`: The calls to be dispatched from the same origin.", "", " If origin is root then call are dispatch without checking origin filter. (This includes", " bypassing `frame_system::Trait::BaseCallFilter`).", "", " # <weight>", " - Base weight: 14.39 + .987 * c µs", " - Plus the sum of the weights of the `calls`.", " - Plus one additional event. (repeat read/write)", " # </weight>", "", " This will return `Ok` in all circumstances. To determine the success of the batch, an", " event is deposited. If a call failed and the batch was interrupted, then the", " `BatchInterrupted` event is deposited, along with the number of successful calls made", " and the error of the failed call. If all were successful, then the `BatchCompleted`", " event is deposited."}}, FunctionMetadataV4{Name: "as_derivative", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "u16"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Trait>::Call>"}}, Documentation: []Text{" Send a call through an indexed pseudonym of the sender.", "", " Filter from origin are passed along. The call will be dispatched with an origin which", " use the same filter as the origin of this call.", "", " NOTE: If you need to ensure that any account-based filtering is not honored (i.e.", " because you expect `proxy` to have been used prior in the call stack and you do not want", " the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`", " in the Multisig pallet instead.", "", " NOTE: Prior to version *12, this was called `as_limited_sub`.", "", " The dispatch origin for this call must be _Signed_."}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "BatchInterrupted", Args: []Type{"u32", "DispatchError"}, Documentation: []Text{" Batch of dispatches did not complete fully. Index of first failing dispatch given, as", " well as the error. [index, error]"}}, EventMetadataV4{Name: "BatchCompleted", Args: []Type(nil), Documentation: []Text{" Batch of dispatches completed fully with no error."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, ModuleMetadataV10{Name: "Babe", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Babe", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "EpochIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u64", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current epoch index."}}, StorageFunctionMetadataV10{Name: "Authorities", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<(AuthorityId, BabeAuthorityWeight)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Current epoch authorities."}}, StorageFunctionMetadataV10{Name: "GenesisSlot", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u64", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The slot at which the first epoch actually started. This is 0", " until the first block of the chain."}}, StorageFunctionMetadataV10{Name: "CurrentSlot", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u64", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current slot number."}}, StorageFunctionMetadataV10{Name: "Randomness", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "schnorrkel::Randomness", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The epoch randomness for the *current* epoch.", "", " # Security", "", " This MUST NOT be used for gambling, as it can be influenced by a", " malicious validator in the short term. It MAY be used in many", " cryptographic protocols, however, so long as one remembers that this", " (like everything else on-chain) it is public. For example, it can be", " used where a number is needed that cannot have been chosen by an", " adversary, for purposes such as public-coin zero-knowledge proofs."}}, StorageFunctionMetadataV10{Name: "NextEpochConfig", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "NextConfigDescriptor", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Next epoch configuration, if changed."}}, StorageFunctionMetadataV10{Name: "NextRandomness", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "schnorrkel::Randomness", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Next epoch randomness."}}, StorageFunctionMetadataV10{Name: "SegmentIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Randomness under construction.", "", " We make a tradeoff between storage accesses and list length.", " We store the under-construction randomness in segments of up to", " `UNDER_CONSTRUCTION_SEGMENT_LENGTH`.", "", " Once a segment reaches this length, we begin the next one.", " We reset all segments and return to `0` at the beginning of every", " epoch."}}, StorageFunctionMetadataV10{Name: "UnderConstruction", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "u32", Value: "Vec<schnorrkel::Randomness>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" TWOX-NOTE: `SegmentIndex` is an increasing integer, so this is okay."}}, StorageFunctionMetadataV10{Name: "Initialized", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "MaybeRandomness", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Temporary value (cleared at block finalization) which is `Some`", " if per-block initialization has already been called for current block."}}, StorageFunctionMetadataV10{Name: "Lateness", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" How late the current block is compared to its parent.", "", " This entry is populated as part of block execution and is cleaned up", " on block finalization. Querying this storage entry outside of block", " execution context should always yield zero."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "report_equivocation", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "equivocation_proof", Type: "EquivocationProof<T::Header>"}, FunctionArgumentMetadata{Name: "key_owner_proof", Type: "T::KeyOwnerProof"}}, Documentation: []Text{" Report authority equivocation/misbehavior. This method will verify", " the equivocation proof and validate the given key ownership proof", " against the extracted offender. If both are valid, the offence will", " be reported."}}, FunctionMetadataV4{Name: "report_equivocation_unsigned", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "equivocation_proof", Type: "EquivocationProof<T::Header>"}, FunctionArgumentMetadata{Name: "key_owner_proof", Type: "T::KeyOwnerProof"}}, Documentation: []Text{" Report authority equivocation/misbehavior. This method will verify", " the equivocation proof and validate the given key ownership proof", " against the extracted offender. If both are valid, the offence will", " be reported.", " This extrinsic must be called unsigned and it is expected that only", " block authors will call it (validated in `ValidateUnsigned`), as such", " if the block author is defined it will be defined as the equivocation", " reporter."}}}, HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "EpochDuration", Type: "u64", Value: Bytes{0xc8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of **slots** that an epoch takes. We couple sessions to", " epochs, i.e. we start a new session once the new epoch begins."}}, ModuleConstantMetadataV6{Name: "ExpectedBlockTime", Type: "T::Moment", Value: Bytes{0xb8, 0xb, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The expected average block time at which BABE should be creating", " blocks. Since BABE is probabilistic it is not trivial to figure out", " what the expected average block time should be based on the slot", " duration and the security parameter `c` (where `1 - c` represents", " the probability of a slot being empty)."}}}, Errors: []ErrorMetadataV8(nil)}, ModuleMetadataV10{Name: "Timestamp", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Timestamp", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Now", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::Moment", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current time for the current block."}}, StorageFunctionMetadataV10{Name: "DidUpdate", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Did the timestamp get updated in this block?"}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "set", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "now", Type: "Compact<T::Moment>"}}, Documentation: []Text{" Set the current time.", "", " This call should be invoked exactly once per block. It will panic at the finalization", " phase, if this call hasn't been invoked by that time.", "", " The timestamp should be greater than the previous one by the amount specified by", " `MinimumPeriod`.", "", " The dispatch origin for this call must be `Inherent`.", "", " # <weight>", " - `O(T)` where `T` complexity of `on_timestamp_set`", " - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in `on_finalize`)", " - 1 event handler `on_timestamp_set` `O(T)`.", " # </weight>"}}}, HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "MinimumPeriod", Type: "T::Moment", Value: Bytes{0xdc, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum period between blocks. Beware that this is different to the *expected* period", " that the block production apparatus provides. Your chosen consensus system will generally", " work with this to determine a sensible block time. e.g. For Aura, it will be double this", " period on default settings."}}}, Errors: []ErrorMetadataV8(nil)}, ModuleMetadataV10{Name: "Authorship", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Authorship", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Uncles", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<UncleEntryItem<T::BlockNumber, T::Hash, T::AccountId>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Uncles"}}, StorageFunctionMetadataV10{Name: "Author", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Author of current block."}}, StorageFunctionMetadataV10{Name: "DidSetUncles", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Whether uncles were already set in this block."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "set_uncles", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new_uncles", Type: "Vec<T::Header>"}}, Documentation: []Text{" Provide a set of uncles."}}}, HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InvalidUncleParent", Documentation: []Text{" The uncle parent not in the chain."}}, ErrorMetadataV8{Name: "UnclesAlreadySet", Documentation: []Text{" Uncles already set in the block."}}, ErrorMetadataV8{Name: "TooManyUncles", Documentation: []Text{" Too many uncles."}}, ErrorMetadataV8{Name: "GenesisUncle", Documentation: []Text{" The uncle is genesis."}}, ErrorMetadataV8{Name: "TooHighUncle", Documentation: []Text{" The uncle is too high in chain."}}, ErrorMetadataV8{Name: "UncleAlreadyIncluded", Documentation: []Text{" The uncle is already included."}}, ErrorMetadataV8{Name: "OldUncle", Documentation: []Text{" The uncle isn't recent enough to be included."}}}}, ModuleMetadataV10{Name: "Indices", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Indices", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Accounts", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::AccountIndex", Value: "(T::AccountId, BalanceOf<T>, bool)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The lookup from index to account."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "claim", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "T::AccountIndex"}}, Documentation: []Text{" Assign an previously unassigned index.", "", " Payment: `Deposit` is reserved from the sender account.", "", " The dispatch origin for this call must be _Signed_.", "", " - `index`: the index to be claimed. This must not be in use.", "", " Emits `IndexAssigned` if successful.", "", " # <weight>", " - `O(1)`.", " - One storage mutation (codec `O(1)`).", " - One reserve operation.", " - One event.", " -------------------", " - Base Weight: 28.69 µs", " - DB Weight: 1 Read/Write (Accounts)", " # </weight>"}}, FunctionMetadataV4{Name: "transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "index", Type: "T::AccountIndex"}}, Documentation: []Text{" Assign an index already owned by the sender to another account. The balance reservation", " is effectively transferred to the new account.", "", " The dispatch origin for this call must be _Signed_.", "", " - `index`: the index to be re-assigned. This must be owned by the sender.", " - `new`: the new owner of the index. This function is a no-op if it is equal to sender.", "", " Emits `IndexAssigned` if successful.", "", " # <weight>", " - `O(1)`.", " - One storage mutation (codec `O(1)`).", " - One transfer operation.", " - One event.", " -------------------", " - Base Weight: 33.74 µs", " - DB Weight:", "    - Reads: Indices Accounts, System Account (recipient)", "    - Writes: Indices Accounts, System Account (recipient)", " # </weight>"}}, FunctionMetadataV4{Name: "free", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "T::AccountIndex"}}, Documentation: []Text{" Free up an index owned by the sender.", "", " Payment: Any previous deposit placed for the index is unreserved in the sender account.", "", " The dispatch origin for this call must be _Signed_ and the sender must own the index.", "", " - `index`: the index to be freed. This must be owned by the sender.", "", " Emits `IndexFreed` if successful.", "", " # <weight>", " - `O(1)`.", " - One storage mutation (codec `O(1)`).", " - One reserve operation.", " - One event.", " -------------------", " - Base Weight: 25.53 µs", " - DB Weight: 1 Read/Write (Accounts)", " # </weight>"}}, FunctionMetadataV4{Name: "force_transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "index", Type: "T::AccountIndex"}, FunctionArgumentMetadata{Name: "freeze", Type: "bool"}}, Documentation: []Text{" Force an index to an account. This doesn't require a deposit. If the index is already", " held, then any deposit is reimbursed to its current owner.", "", " The dispatch origin for this call must be _Root_.", "", " - `index`: the index to be (re-)assigned.", " - `new`: the new owner of the index. This function is a no-op if it is equal to sender.", " - `freeze`: if set to `true`, will freeze the index so it cannot be transferred.", "", " Emits `IndexAssigned` if successful.", "", " # <weight>", " - `O(1)`.", " - One storage mutation (codec `O(1)`).", " - Up to one reserve operation.", " - One event.", " -------------------", " - Base Weight: 26.83 µs", " - DB Weight:", "    - Reads: Indices Accounts, System Account (original owner)", "    - Writes: Indices Accounts, System Account (original owner)", " # </weight>"}}, FunctionMetadataV4{Name: "freeze", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "T::AccountIndex"}}, Documentation: []Text{" Freeze an index so it will always point to the sender account. This consumes the deposit.", "", " The dispatch origin for this call must be _Signed_ and the signing account must have a", " non-frozen account `index`.", "", " - `index`: the index to be frozen in place.", "", " Emits `IndexFrozen` if successful.", "", " # <weight>", " - `O(1)`.", " - One storage mutation (codec `O(1)`).", " - Up to one slash operation.", " - One event.", " -------------------", " - Base Weight: 30.86 µs", " - DB Weight: 1 Read/Write (Accounts)", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "IndexAssigned", Args: []Type{"AccountId", "AccountIndex"}, Documentation: []Text{" A account index was assigned. [who, index]"}}, EventMetadataV4{Name: "IndexFreed", Args: []Type{"AccountIndex"}, Documentation: []Text{" A account index has been freed up (unassigned). [index]"}}, EventMetadataV4{Name: "IndexFrozen", Args: []Type{"AccountIndex", "AccountId"}, Documentation: []Text{" A account index has been frozen to its current account ID. [who, index]"}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, ModuleMetadataV10{Name: "Balances", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Balances", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "TotalIssuance", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::Balance", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The total units issued in the system."}}, StorageFunctionMetadataV10{Name: "Account", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::AccountId", Value: "AccountData<T::Balance>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The balance of an account.", "", " NOTE: This is only used in the case that this module is used to store balances."}}, StorageFunctionMetadataV10{Name: "Locks", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::AccountId", Value: "Vec<BalanceLock<T::Balance>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Any liquidity locks on some account balances.", " NOTE: Should only be accessed when setting, changing and freeing a lock."}}, StorageFunctionMetadataV10{Name: "StorageVersion", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Releases", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Storage version of the pallet.", "", " This is set to v2.0.0 for new networks."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Transfer some liquid free balance to another account.", "", " `transfer` will set the `FreeBalance` of the sender and receiver.", " It will decrease the total issuance of the system by the `TransferFee`.", " If the sender's account is below the existential deposit as a result", " of the transfer, the account will be reaped.", "", " The dispatch origin for this call must be `Signed` by the transactor.", "", " # <weight>", " - Dependent on arguments but not critical, given proper implementations for", "   input config  See related functions below.", " - It contains a limited number of reads and writes internally and no complex computation.", "", " Related functions:", "", "   - `ensure_can_withdraw` is always called internally but has a bounded complexity.", "   - Transferring balances to accounts that did not exist before will cause", "      `T::OnNewAccount::on_new_account` to be called.", "   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.", "   - `transfer_keep_alive` works the same way as `transfer`, but has an additional", "     check that the transfer will not kill the origin account.", " ---------------------------------", " - Base Weight: 73.64 µs, worst case scenario (account created, account removed)", " - DB Weight: 1 Read and 1 Write to destination account", " - Origin account is already in memory, so no DB operations for them.", " # </weight>"}}, FunctionMetadataV4{Name: "set_balance", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "new_free", Type: "Compact<T::Balance>"}, FunctionArgumentMetadata{Name: "new_reserved", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Set the balances of a given account.", "", " This will alter `FreeBalance` and `ReservedBalance` in storage. it will", " also decrease the total issuance of the system (`TotalIssuance`).", " If the new free or reserved balance is below the existential deposit,", " it will reset the account nonce (`frame_system::AccountNonce`).", "", " The dispatch origin for this call is `root`.", "", " # <weight>", " - Independent of the arguments.", " - Contains a limited number of reads and writes.", " ---------------------", " - Base Weight:", "     - Creating: 27.56 µs", "     - Killing: 35.11 µs", " - DB Weight: 1 Read, 1 Write to `who`", " # </weight>"}}, FunctionMetadataV4{Name: "force_transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "source", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Exactly as `transfer`, except the origin must be root and the source account may be", " specified.", " # <weight>", " - Same as transfer, but additional read and write because the source account is", "   not assumed to be in the overlay.", " # </weight>"}}, FunctionMetadataV4{Name: "transfer_keep_alive", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<T::Balance>"}}, Documentation: []Text{" Same as the [`transfer`] call, but with a check that the transfer will not kill the", " origin account.", "", " 99% of the time you want [`transfer`] instead.", "", " [`transfer`]: struct.Module.html#method.transfer", " # <weight>", " - Cheaper than transfer because account cannot be killed.", " - Base Weight: 51.4 µs", " - DB Weight: 1 Read and 1 Write to dest (sender is in overlay already)", " #</weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Endowed", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" An account was created with some free balance. [account, free_balance]"}}, EventMetadataV4{Name: "DustLost", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" An account was removed whose balance was non-zero but below ExistentialDeposit,", " resulting in an outright loss. [account, balance]"}}, EventMetadataV4{Name: "Transfer", Args: []Type{"AccountId", "AccountId", "Balance"}, Documentation: []Text{" Transfer succeeded. [from, to, value]"}}, EventMetadataV4{Name: "BalanceSet", Args: []Type{"AccountId", "Balance", "Balance"}, Documentation: []Text{" A balance was set by root. [who, free, reserved]"}}, EventMetadataV4{Name: "Deposit", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" Some amount was deposited (e.g. for transaction fees). [who, deposit]"}}, EventMetadataV4{Name: "Reserved", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" Some balance was reserved (moved from free to reserved). [who, value]"}}, EventMetadataV4{Name: "Unreserved", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" Some balance was unreserved (moved from reserved to free). [who, value]"}}, EventMetadataV4{Name: "ReserveRepatriated", Args: []Type{"AccountId", "AccountId", "Balance", "Status"}, Documentation: []Text{" Some balance was moved from the reserve of the first account to the second account.", " Final argument indicates the destination balance type.", " [from, to, balance, destination_status]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "ExistentialDeposit", Type: "T::Balance", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount required to keep an account open."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "VestingBalance", Documentation: []Text{" Vesting balance too high to send value"}}, ErrorMetadataV8{Name: "LiquidityRestrictions", Documentation: []Text{" Account liquidity restrictions prevent withdrawal"}}, ErrorMetadataV8{Name: "Overflow", Documentation: []Text{" Got an overflow after adding"}}, ErrorMetadataV8{Name: "InsufficientBalance", Documentation: []Text{" Balance too low to send value"}}, ErrorMetadataV8{Name: "ExistentialDeposit", Documentation: []Text{" Value too low to create account due to existential deposit"}}, ErrorMetadataV8{Name: "KeepAlive", Documentation: []Text{" Transfer/payment would kill account"}}, ErrorMetadataV8{Name: "ExistingVestingSchedule", Documentation: []Text{" A vesting schedule already exists for this account"}}, ErrorMetadataV8{Name: "DeadAccount", Documentation: []Text{" Beneficiary account must pre-exist"}}}}, ModuleMetadataV10{Name: "TransactionPayment", HasStorage: true, Storage: StorageMetadataV10{Prefix: "TransactionPayment", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "NextFeeMultiplier", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Multiplier", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x64, 0xa7, 0xb3, 0xb6, 0xe0, 0xd, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text(nil)}, StorageFunctionMetadataV10{Name: "StorageVersion", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Releases", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text(nil)}}}, HasCalls: false, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "TransactionByteFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0xe4, 0xb, 0x54, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The fee to be paid for making a transaction; the per-byte portion."}}, ModuleConstantMetadataV6{Name: "WeightToFee", Type: "Vec<WeightToFeeCoefficient<BalanceOf<T>>>", Value: Bytes{0x4, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1}, Documentation: []Text{" The polynomial that is applied in order to derive fee from weight."}}}, Errors: []ErrorMetadataV8(nil)}, ModuleMetadataV10{Name: "Staking", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Staking", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "HistoryDepth", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x54, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of eras to keep in history.", "", " Information is kept for eras in `[current_era - history_depth; current_era]`.", "", " Must be more than the number of eras delayed by session otherwise. I.e. active era must", " always be in history. I.e. `active_era > current_era - history_depth` must be", " guaranteed."}}, StorageFunctionMetadataV10{Name: "ValidatorCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The ideal number of staking participants."}}, StorageFunctionMetadataV10{Name: "MinimumValidatorCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Minimum number of staking participants before emergency conditions are imposed."}}, StorageFunctionMetadataV10{Name: "Invulnerables", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Any validators that may never be slashed or forcibly kicked. It's a Vec since they're", " easy to initialize and the performance hit is minimal (we expect no more than four", " invulnerables) and restricted to testnets."}}, StorageFunctionMetadataV10{Name: "Bonded", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "T::AccountId", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Map from all locked \"stash\" accounts to the controller account."}}, StorageFunctionMetadataV10{Name: "Ledger", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::AccountId", Value: "StakingLedger<T::AccountId, BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Map from all (unlocked) \"controller\" accounts to the info regarding the staking."}}, StorageFunctionMetadataV10{Name: "Payee", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "RewardDestination", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Where the reward payment should be made. Keyed by stash."}}, StorageFunctionMetadataV10{Name: "Validators", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "ValidatorPrefs", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The map from (wannabe) validator stash key to the preferences of that validator."}}, StorageFunctionMetadataV10{Name: "Nominators", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "Nominations<T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The map from nominator stash key to the set of stash keys of all validators to nominate."}}, StorageFunctionMetadataV10{Name: "CurrentEra", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "EraIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current era index.", "", " This is the latest planned era, depending on how the Session pallet queues the validator", " set, it might be active or not."}}, StorageFunctionMetadataV10{Name: "ActiveEra", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "ActiveEraInfo", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The active era information, it holds index and start.", "", " The active era is the era currently rewarded.", " Validator set of this era must be equal to `SessionInterface::validators`."}}, StorageFunctionMetadataV10{Name: "ErasStartSessionIndex", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "EraIndex", Value: "SessionIndex", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The session index at which the era start for the last `HISTORY_DEPTH` eras."}}, StorageFunctionMetadataV10{Name: "ErasStakers", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "EraIndex", Key2: "T::AccountId", Value: "Exposure<T::AccountId, BalanceOf<T>>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0}, Documentation: []Text{" Exposure of validator at era.", "", " This is keyed first by the era index to allow bulk deletion and then the stash account.", "", " Is it removed after `HISTORY_DEPTH` eras.", " If stakers hasn't been set or has been removed then empty exposure is returned."}}, StorageFunctionMetadataV10{Name: "ErasStakersClipped", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "EraIndex", Key2: "T::AccountId", Value: "Exposure<T::AccountId, BalanceOf<T>>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0}, Documentation: []Text{" Clipped Exposure of validator at era.", "", " This is similar to [`ErasStakers`] but number of nominators exposed is reduced to the", " `T::MaxNominatorRewardedPerValidator` biggest stakers.", " (Note: the field `total` and `own` of the exposure remains unchanged).", " This is used to limit the i/o cost for the nominator payout.", "", " This is keyed fist by the era index to allow bulk deletion and then the stash account.", "", " Is it removed after `HISTORY_DEPTH` eras.", " If stakers hasn't been set or has been removed then empty exposure is returned."}}, StorageFunctionMetadataV10{Name: "ErasValidatorPrefs", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "EraIndex", Key2: "T::AccountId", Value: "ValidatorPrefs", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Similar to `ErasStakers`, this holds the preferences of validators.", "", " This is keyed first by the era index to allow bulk deletion and then the stash account.", "", " Is it removed after `HISTORY_DEPTH` eras."}}, StorageFunctionMetadataV10{Name: "ErasValidatorReward", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "EraIndex", Value: "BalanceOf<T>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The total validator era payout for the last `HISTORY_DEPTH` eras.", "", " Eras that haven't finished yet or has been removed doesn't have reward."}}, StorageFunctionMetadataV10{Name: "ErasRewardPoints", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "EraIndex", Value: "EraRewardPoints<T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Rewards for the last `HISTORY_DEPTH` eras.", " If reward hasn't been set or has been removed then 0 reward is returned."}}, StorageFunctionMetadataV10{Name: "ErasTotalStake", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "EraIndex", Value: "BalanceOf<T>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The total amount staked for the last `HISTORY_DEPTH` eras.", " If total hasn't been set or has been removed then 0 stake is returned."}}, StorageFunctionMetadataV10{Name: "ForceEra", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Forcing", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Mode of era forcing."}}, StorageFunctionMetadataV10{Name: "SlashRewardFraction", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Perbill", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The percentage of the slash that is distributed to reporters.", "", " The rest of the slashed value is handled by the `Slash`."}}, StorageFunctionMetadataV10{Name: "CanceledSlashPayout", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "BalanceOf<T>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of currency given to reporters of a slash event which was", " canceled by extraordinary circumstances (e.g. governance)."}}, StorageFunctionMetadataV10{Name: "UnappliedSlashes", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "EraIndex", Value: "Vec<UnappliedSlash<T::AccountId, BalanceOf<T>>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" All unapplied slashes that are queued for later."}}, StorageFunctionMetadataV10{Name: "BondedEras", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<(EraIndex, SessionIndex)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping from still-bonded eras to the first session index of that era.", "", " Must contains information for eras for the range:", " `[active_era - bounding_duration; active_era]`"}}, StorageFunctionMetadataV10{Name: "ValidatorSlashInEra", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "EraIndex", Key2: "T::AccountId", Value: "(Perbill, BalanceOf<T>)", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" All slashing events on validators, mapped by era to the highest slash proportion", " and slash value of the era."}}, StorageFunctionMetadataV10{Name: "NominatorSlashInEra", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "EraIndex", Key2: "T::AccountId", Value: "BalanceOf<T>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" All slashing events on nominators, mapped by era to the highest slash value of the era."}}, StorageFunctionMetadataV10{Name: "SlashingSpans", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "slashing::SlashingSpans", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Slashing spans for stash accounts."}}, StorageFunctionMetadataV10{Name: "SpanSlash", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "(T::AccountId, slashing::SpanIndex)", Value: "slashing::SpanRecord<BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Records information about the maximum slash of a stash within a slashing span,", " as well as how much reward has been paid out."}}, StorageFunctionMetadataV10{Name: "EarliestUnappliedSlash", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "EraIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The earliest era for which we have a pending, unapplied slash."}}, StorageFunctionMetadataV10{Name: "SnapshotValidators", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Snapshot of validators at the beginning of the current election window. This should only", " have a value when [`EraElectionStatus`] == `ElectionStatus::Open(_)`."}}, StorageFunctionMetadataV10{Name: "SnapshotNominators", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Snapshot of nominators at the beginning of the current election window. This should only", " have a value when [`EraElectionStatus`] == `ElectionStatus::Open(_)`."}}, StorageFunctionMetadataV10{Name: "QueuedElected", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "ElectionResult<T::AccountId, BalanceOf<T>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The next validator set. At the end of an era, if this is available (potentially from the", " result of an offchain worker), it is immediately used. Otherwise, the on-chain election", " is executed."}}, StorageFunctionMetadataV10{Name: "QueuedScore", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "ElectionScore", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The score of the current [`QueuedElected`]."}}, StorageFunctionMetadataV10{Name: "EraElectionStatus", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "ElectionStatus<T::BlockNumber>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Flag to control the execution of the offchain election. When `Open(_)`, we accept", " solutions to be submitted."}}, StorageFunctionMetadataV10{Name: "IsCurrentSessionFinal", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" True if the current **planned** session is final. Note that this does not take era", " forcing into account."}}, StorageFunctionMetadataV10{Name: "StorageVersion", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Releases", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x3}, Documentation: []Text{" True if network has been upgraded to this version.", " Storage version of the pallet.", "", " This is set to v3.0.0 for new networks."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "bond", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "controller", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}, FunctionArgumentMetadata{Name: "payee", Type: "RewardDestination"}}, Documentation: []Text{" Take the origin account as a stash and lock up `value` of its balance. `controller` will", " be the account that controls it.", "", " `value` must be more than the `minimum_balance` specified by `T::Currency`.", "", " The dispatch origin for this call must be _Signed_ by the stash account.", "", " Emits `Bonded`.", "", " # <weight>", " - Independent of the arguments. Moderate complexity.", " - O(1).", " - Three extra DB entries.", "", " NOTE: Two of the storage writes (`Self::bonded`, `Self::payee`) are _never_ cleaned", " unless the `origin` falls below _existential deposit_ and gets removed as dust.", " ------------------", " Base Weight: 67.87 µs", " DB Weight:", " - Read: Bonded, Ledger, [Origin Account], Current Era, History Depth, Locks", " - Write: Bonded, Payee, [Origin Account], Locks, Ledger", " # </weight>"}}, FunctionMetadataV4{Name: "bond_extra", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "max_additional", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Add some extra amount that have appeared in the stash `free_balance` into the balance up", " for staking.", "", " Use this if there are additional funds in your stash account that you wish to bond.", " Unlike [`bond`] or [`unbond`] this function does not impose any limitation on the amount", " that can be added.", "", " The dispatch origin for this call must be _Signed_ by the stash, not the controller and", " it can be only called when [`EraElectionStatus`] is `Closed`.", "", " Emits `Bonded`.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - O(1).", " - One DB entry.", " ------------", " Base Weight: 54.88 µs", " DB Weight:", " - Read: Era Election Status, Bonded, Ledger, [Origin Account], Locks", " - Write: [Origin Account], Locks, Ledger", " # </weight>"}}, FunctionMetadataV4{Name: "unbond", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Schedule a portion of the stash to be unlocked ready for transfer out after the bond", " period ends. If this leaves an amount actively bonded less than", " T::Currency::minimum_balance(), then it is increased to the full amount.", "", " Once the unlock period is done, you can call `withdraw_unbonded` to actually move", " the funds out of management ready for transfer.", "", " No more than a limited number of unlocking chunks (see `MAX_UNLOCKING_CHUNKS`)", " can co-exists at the same time. In that case, [`Call::withdraw_unbonded`] need", " to be called first to remove some of the chunks (if possible).", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", " And, it can be only called when [`EraElectionStatus`] is `Closed`.", "", " Emits `Unbonded`.", "", " See also [`Call::withdraw_unbonded`].", "", " # <weight>", " - Independent of the arguments. Limited but potentially exploitable complexity.", " - Contains a limited number of reads.", " - Each call (requires the remainder of the bonded balance to be above `minimum_balance`)", "   will cause a new entry to be inserted into a vector (`Ledger.unlocking`) kept in storage.", "   The only way to clean the aforementioned storage item is also user-controlled via", "   `withdraw_unbonded`.", " - One DB entry.", " ----------", " Base Weight: 50.34 µs", " DB Weight:", " - Read: Era Election Status, Ledger, Current Era, Locks, [Origin Account]", " - Write: [Origin Account], Locks, Ledger", " </weight>"}}, FunctionMetadataV4{Name: "withdraw_unbonded", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "num_slashing_spans", Type: "u32"}}, Documentation: []Text{" Remove any unlocked chunks from the `unlocking` queue from our management.", "", " This essentially frees up that balance to be used by the stash account to do", " whatever it wants.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", " And, it can be only called when [`EraElectionStatus`] is `Closed`.", "", " Emits `Withdrawn`.", "", " See also [`Call::unbond`].", "", " # <weight>", " - Could be dependent on the `origin` argument and how much `unlocking` chunks exist.", "  It implies `consolidate_unlocked` which loops over `Ledger.unlocking`, which is", "  indirectly user-controlled. See [`unbond`] for more detail.", " - Contains a limited number of reads, yet the size of which could be large based on `ledger`.", " - Writes are limited to the `origin` account key.", " ---------------", " Complexity O(S) where S is the number of slashing spans to remove", " Base Weight:", " Update: 50.52 + .028 * S µs", " - Reads: EraElectionStatus, Ledger, Current Era, Locks, [Origin Account]", " - Writes: [Origin Account], Locks, Ledger", " Kill: 79.41 + 2.366 * S µs", " - Reads: EraElectionStatus, Ledger, Current Era, Bonded, Slashing Spans, [Origin Account], Locks", " - Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, [Origin Account], Locks", " - Writes Each: SpanSlash * S", " NOTE: Weight annotation is the kill scenario, we refund otherwise.", " # </weight>"}}, FunctionMetadataV4{Name: "validate", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "prefs", Type: "ValidatorPrefs"}}, Documentation: []Text{" Declare the desire to validate for the origin controller.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", " And, it can be only called when [`EraElectionStatus`] is `Closed`.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains a limited number of reads.", " - Writes are limited to the `origin` account key.", " -----------", " Base Weight: 17.13 µs", " DB Weight:", " - Read: Era Election Status, Ledger", " - Write: Nominators, Validators", " # </weight>"}}, FunctionMetadataV4{Name: "nominate", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "targets", Type: "Vec<<T::Lookup as StaticLookup>::Source>"}}, Documentation: []Text{" Declare the desire to nominate `targets` for the origin controller.", "", " Effects will be felt at the beginning of the next era. This can only be called when", " [`EraElectionStatus`] is `Closed`.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", " And, it can be only called when [`EraElectionStatus`] is `Closed`.", "", " # <weight>", " - The transaction's complexity is proportional to the size of `targets` (N)", " which is capped at CompactAssignments::LIMIT (MAX_NOMINATIONS).", " - Both the reads and writes follow a similar pattern.", " ---------", " Base Weight: 22.34 + .36 * N µs", " where N is the number of targets", " DB Weight:", " - Reads: Era Election Status, Ledger, Current Era", " - Writes: Validators, Nominators", " # </weight>"}}, FunctionMetadataV4{Name: "chill", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Declare no desire to either validate or nominate.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", " And, it can be only called when [`EraElectionStatus`] is `Closed`.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains one read.", " - Writes are limited to the `origin` account key.", " --------", " Base Weight: 16.53 µs", " DB Weight:", " - Read: EraElectionStatus, Ledger", " - Write: Validators, Nominators", " # </weight>"}}, FunctionMetadataV4{Name: "set_payee", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "payee", Type: "RewardDestination"}}, Documentation: []Text{" (Re-)set the payment target for a controller.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the controller, not the stash.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains a limited number of reads.", " - Writes are limited to the `origin` account key.", " ---------", " - Base Weight: 11.33 µs", " - DB Weight:", "     - Read: Ledger", "     - Write: Payee", " # </weight>"}}, FunctionMetadataV4{Name: "set_controller", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "controller", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" (Re-)set the controller of a stash.", "", " Effects will be felt at the beginning of the next era.", "", " The dispatch origin for this call must be _Signed_ by the stash, not the controller.", "", " # <weight>", " - Independent of the arguments. Insignificant complexity.", " - Contains a limited number of reads.", " - Writes are limited to the `origin` account key.", " ----------", " Base Weight: 25.22 µs", " DB Weight:", " - Read: Bonded, Ledger New Controller, Ledger Old Controller", " - Write: Bonded, Ledger New Controller, Ledger Old Controller", " # </weight>"}}, FunctionMetadataV4{Name: "set_validator_count", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new", Type: "Compact<u32>"}}, Documentation: []Text{" Sets the ideal number of validators.", "", " The dispatch origin must be Root.", "", " # <weight>", " Base Weight: 1.717 µs", " Write: Validator Count", " # </weight>"}}, FunctionMetadataV4{Name: "increase_validator_count", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "additional", Type: "Compact<u32>"}}, Documentation: []Text{" Increments the ideal number of validators.", "", " The dispatch origin must be Root.", "", " # <weight>", " Base Weight: 1.717 µs", " Read/Write: Validator Count", " # </weight>"}}, FunctionMetadataV4{Name: "scale_validator_count", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "factor", Type: "Percent"}}, Documentation: []Text{" Scale up the ideal number of validators by a factor.", "", " The dispatch origin must be Root.", "", " # <weight>", " Base Weight: 1.717 µs", " Read/Write: Validator Count", " # </weight>"}}, FunctionMetadataV4{Name: "force_no_eras", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Force there to be no new eras indefinitely.", "", " The dispatch origin must be Root.", "", " # <weight>", " - No arguments.", " - Base Weight: 1.857 µs", " - Write: ForceEra", " # </weight>"}}, FunctionMetadataV4{Name: "force_new_era", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Force there to be a new era at the end of the next session. After this, it will be", " reset to normal (non-forced) behaviour.", "", " The dispatch origin must be Root.", "", " # <weight>", " - No arguments.", " - Base Weight: 1.959 µs", " - Write ForceEra", " # </weight>"}}, FunctionMetadataV4{Name: "set_invulnerables", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "validators", Type: "Vec<T::AccountId>"}}, Documentation: []Text{" Set the validators who cannot be slashed (if any).", "", " The dispatch origin must be Root.", "", " # <weight>", " - O(V)", " - Base Weight: 2.208 + .006 * V µs", " - Write: Invulnerables", " # </weight>"}}, FunctionMetadataV4{Name: "force_unstake", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "stash", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "num_slashing_spans", Type: "u32"}}, Documentation: []Text{" Force a current staker to become completely unstaked, immediately.", "", " The dispatch origin must be Root.", "", " # <weight>", " O(S) where S is the number of slashing spans to be removed", " Base Weight: 53.07 + 2.365 * S µs", " Reads: Bonded, Slashing Spans, Account, Locks", " Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Account, Locks", " Writes Each: SpanSlash * S", " # </weight>"}}, FunctionMetadataV4{Name: "force_new_era_always", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Force there to be a new era at the end of sessions indefinitely.", "", " The dispatch origin must be Root.", "", " # <weight>", " - Base Weight: 2.05 µs", " - Write: ForceEra", " # </weight>"}}, FunctionMetadataV4{Name: "cancel_deferred_slash", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "era", Type: "EraIndex"}, FunctionArgumentMetadata{Name: "slash_indices", Type: "Vec<u32>"}}, Documentation: []Text{" Cancel enactment of a deferred slash.", "", " Can be called by the `T::SlashCancelOrigin`.", "", " Parameters: era and indices of the slashes for that era to kill.", "", " # <weight>", " Complexity: O(U + S)", " with U unapplied slashes weighted with U=1000", " and S is the number of slash indices to be canceled.", " - Base: 5870 + 34.61 * S µs", " - Read: Unapplied Slashes", " - Write: Unapplied Slashes", " # </weight>"}}, FunctionMetadataV4{Name: "payout_stakers", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "validator_stash", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "era", Type: "EraIndex"}}, Documentation: []Text{" Pay out all the stakers behind a single validator for a single era.", "", " - `validator_stash` is the stash account of the validator. Their nominators, up to", "   `T::MaxNominatorRewardedPerValidator`, will also receive their rewards.", " - `era` may be any era between `[current_era - history_depth; current_era]`.", "", " The origin of this call must be _Signed_. Any account can call this function, even if", " it is not one of the stakers.", "", " This can only be called when [`EraElectionStatus`] is `Closed`.", "", " # <weight>", " - Time complexity: at most O(MaxNominatorRewardedPerValidator).", " - Contains a limited number of reads and writes.", " -----------", " N is the Number of payouts for the validator (including the validator)", " Base Weight:", " - Reward Destination Staked: 110 + 54.2 * N µs (Median Slopes)", " - Reward Destination Controller (Creating): 120 + 41.95 * N µs (Median Slopes)", " DB Weight:", " - Read: EraElectionStatus, CurrentEra, HistoryDepth, ErasValidatorReward,", "         ErasStakersClipped, ErasRewardPoints, ErasValidatorPrefs (8 items)", " - Read Each: Bonded, Ledger, Payee, Locks, System Account (5 items)", " - Write Each: System Account, Locks, Ledger (3 items)", " # </weight>"}}, FunctionMetadataV4{Name: "rebond", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Rebond a portion of the stash scheduled to be unlocked.", "", " The dispatch origin must be signed by the controller, and it can be only called when", " [`EraElectionStatus`] is `Closed`.", "", " # <weight>", " - Time complexity: O(L), where L is unlocking chunks", " - Bounded by `MAX_UNLOCKING_CHUNKS`.", " - Storage changes: Can't increase storage, only decrease it.", " ---------------", " - Base Weight: 34.51 µs * .048 L µs", " - DB Weight:", "     - Reads: EraElectionStatus, Ledger, Locks, [Origin Account]", "     - Writes: [Origin Account], Locks, Ledger", " # </weight>"}}, FunctionMetadataV4{Name: "set_history_depth", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new_history_depth", Type: "Compact<EraIndex>"}, FunctionArgumentMetadata{Name: "_era_items_deleted", Type: "Compact<u32>"}}, Documentation: []Text{" Set `HistoryDepth` value. This function will delete any history information", " when `HistoryDepth` is reduced.", "", " Parameters:", " - `new_history_depth`: The new history depth you would like to set.", " - `era_items_deleted`: The number of items that will be deleted by this dispatch.", "    This should report all the storage items that will be deleted by clearing old", "    era history. Needed to report an accurate weight for the dispatch. Trusted by", "    `Root` to report an accurate number.", "", " Origin must be root.", "", " # <weight>", " - E: Number of history depths removed, i.e. 10 -> 7 = 3", " - Base Weight: 29.13 * E µs", " - DB Weight:", "     - Reads: Current Era, History Depth", "     - Writes: History Depth", "     - Clear Prefix Each: Era Stakers, EraStakersClipped, ErasValidatorPrefs", "     - Writes Each: ErasValidatorReward, ErasRewardPoints, ErasTotalStake, ErasStartSessionIndex", " # </weight>"}}, FunctionMetadataV4{Name: "reap_stash", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "stash", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "num_slashing_spans", Type: "u32"}}, Documentation: []Text{" Remove all data structure concerning a staker/stash once its balance is zero.", " This is essentially equivalent to `withdraw_unbonded` except it can be called by anyone", " and the target `stash` must have no funds left.", "", " This can be called from any origin.", "", " - `stash`: The stash account to reap. Its balance must be zero.", "", " # <weight>", " Complexity: O(S) where S is the number of slashing spans on the account.", " Base Weight: 75.94 + 2.396 * S µs", " DB Weight:", " - Reads: Stash Account, Bonded, Slashing Spans, Locks", " - Writes: Bonded, Slashing Spans (if S > 0), Ledger, Payee, Validators, Nominators, Stash Account, Locks", " - Writes Each: SpanSlash * S", " # </weight>"}}, FunctionMetadataV4{Name: "submit_election_solution", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "winners", Type: "Vec<ValidatorIndex>"}, FunctionArgumentMetadata{Name: "compact", Type: "CompactAssignments"}, FunctionArgumentMetadata{Name: "score", Type: "ElectionScore"}, FunctionArgumentMetadata{Name: "era", Type: "EraIndex"}, FunctionArgumentMetadata{Name: "size", Type: "ElectionSize"}}, Documentation: []Text{" Submit an election result to the chain. If the solution:", "", " 1. is valid.", " 2. has a better score than a potentially existing solution on chain.", "", " then, it will be _put_ on chain.", "", " A solution consists of two pieces of data:", "", " 1. `winners`: a flat vector of all the winners of the round.", " 2. `assignments`: the compact version of an assignment vector that encodes the edge", "    weights.", "", " Both of which may be computed using _phragmen_, or any other algorithm.", "", " Additionally, the submitter must provide:", "", " - The `score` that they claim their solution has.", "", " Both validators and nominators will be represented by indices in the solution. The", " indices should respect the corresponding types ([`ValidatorIndex`] and", " [`NominatorIndex`]). Moreover, they should be valid when used to index into", " [`SnapshotValidators`] and [`SnapshotNominators`]. Any invalid index will cause the", " solution to be rejected. These two storage items are set during the election window and", " may be used to determine the indices.", "", " A solution is valid if:", "", " 0. It is submitted when [`EraElectionStatus`] is `Open`.", " 1. Its claimed score is equal to the score computed on-chain.", " 2. Presents the correct number of winners.", " 3. All indexes must be value according to the snapshot vectors. All edge values must", "    also be correct and should not overflow the granularity of the ratio type (i.e. 256", "    or billion).", " 4. For each edge, all targets are actually nominated by the voter.", " 5. Has correct self-votes.", "", " A solutions score is consisted of 3 parameters:", "", " 1. `min { support.total }` for each support of a winner. This value should be maximized.", " 2. `sum { support.total }` for each support of a winner. This value should be minimized.", " 3. `sum { support.total^2 }` for each support of a winner. This value should be", "    minimized (to ensure less variance)", "", " # <weight>", " See `crate::weight` module.", " # </weight>"}}, FunctionMetadataV4{Name: "submit_election_solution_unsigned", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "winners", Type: "Vec<ValidatorIndex>"}, FunctionArgumentMetadata{Name: "compact", Type: "CompactAssignments"}, FunctionArgumentMetadata{Name: "score", Type: "ElectionScore"}, FunctionArgumentMetadata{Name: "era", Type: "EraIndex"}, FunctionArgumentMetadata{Name: "size", Type: "ElectionSize"}}, Documentation: []Text{" Unsigned version of `submit_election_solution`.", "", " Note that this must pass the [`ValidateUnsigned`] check which only allows transactions", " from the local node to be included. In other words, only the block author can include a", " transaction in the block.", "", " # <weight>", " See `crate::weight` module.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "EraPayout", Args: []Type{"EraIndex", "Balance", "Balance"}, Documentation: []Text{" The era payout has been set; the first balance is the validator-payout; the second is", " the remainder from the maximum amount of reward.", " [era_index, validator_payout, remainder]"}}, EventMetadataV4{Name: "Reward", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" The staker has been rewarded by this amount. [stash, amount]"}}, EventMetadataV4{Name: "Slash", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" One validator (and its nominators) has been slashed by the given amount.", " [validator, amount]"}}, EventMetadataV4{Name: "OldSlashingReportDiscarded", Args: []Type{"SessionIndex"}, Documentation: []Text{" An old slashing report from a prior era was discarded because it could", " not be processed. [session_index]"}}, EventMetadataV4{Name: "StakingElection", Args: []Type{"ElectionCompute"}, Documentation: []Text{" A new set of stakers was elected with the given [compute]."}}, EventMetadataV4{Name: "SolutionStored", Args: []Type{"ElectionCompute"}, Documentation: []Text{" A new solution for the upcoming election has been stored. [compute]"}}, EventMetadataV4{Name: "Bonded", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" An account has bonded this amount. [stash, amount]", "", " NOTE: This event is only emitted when funds are bonded via a dispatchable. Notably,", " it will not be emitted for staking rewards when they are added to stake."}}, EventMetadataV4{Name: "Unbonded", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" An account has unbonded this amount. [stash, amount]"}}, EventMetadataV4{Name: "Withdrawn", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" An account has called `withdraw_unbonded` and removed unbonding chunks worth `Balance`", " from the unlocking queue. [stash, amount]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "SessionsPerEra", Type: "SessionIndex", Value: Bytes{0x6, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of sessions per era."}}, ModuleConstantMetadataV6{Name: "BondingDuration", Type: "EraIndex", Value: Bytes{0xa0, 0x2, 0x0, 0x0}, Documentation: []Text{" Number of eras that staked funds must remain bonded for."}}, ModuleConstantMetadataV6{Name: "SlashDeferDuration", Type: "EraIndex", Value: Bytes{0xa8, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of eras that slashes are deferred by, after computation.", "", " This should be less than the bonding duration.", " Set to 0 if slashes should be applied immediately, without opportunity for", " intervention."}}, ModuleConstantMetadataV6{Name: "ElectionLookahead", Type: "T::BlockNumber", Value: Bytes{0x32, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of blocks before the end of the era from which election submissions are allowed.", "", " Setting this to zero will disable the offchain compute and only on-chain seq-phragmen will", " be used.", "", " This is bounded by being within the last session. Hence, setting it to a value more than the", " length of a session will be pointless."}}, ModuleConstantMetadataV6{Name: "MaxIterations", Type: "u32", Value: Bytes{0xa, 0x0, 0x0, 0x0}, Documentation: []Text{" Maximum number of balancing iterations to run in the offchain submission.", "", " If set to 0, balance_solution will not be executed at all."}}, ModuleConstantMetadataV6{Name: "MinSolutionScoreBump", Type: "Perbill", Value: Bytes{0x20, 0xa1, 0x7, 0x0}, Documentation: []Text{" The threshold of improvement that should be provided for a new solution to be accepted."}}, ModuleConstantMetadataV6{Name: "MaxNominatorRewardedPerValidator", Type: "u32", Value: Bytes{0x40, 0x0, 0x0, 0x0}, Documentation: []Text{" The maximum number of nominators rewarded for each validator.", "", " For each validator only the `$MaxNominatorRewardedPerValidator` biggest stakers can claim", " their reward. This used to limit the i/o cost for the nominator payout."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "NotController", Documentation: []Text{" Not a controller account."}}, ErrorMetadataV8{Name: "NotStash", Documentation: []Text{" Not a stash account."}}, ErrorMetadataV8{Name: "AlreadyBonded", Documentation: []Text{" Stash is already bonded."}}, ErrorMetadataV8{Name: "AlreadyPaired", Documentation: []Text{" Controller is already paired."}}, ErrorMetadataV8{Name: "EmptyTargets", Documentation: []Text{" Targets cannot be empty."}}, ErrorMetadataV8{Name: "DuplicateIndex", Documentation: []Text{" Duplicate index."}}, ErrorMetadataV8{Name: "InvalidSlashIndex", Documentation: []Text{" Slash record index out of bounds."}}, ErrorMetadataV8{Name: "InsufficientValue", Documentation: []Text{" Can not bond with value less than minimum balance."}}, ErrorMetadataV8{Name: "NoMoreChunks", Documentation: []Text{" Can not schedule more unlock chunks."}}, ErrorMetadataV8{Name: "NoUnlockChunk", Documentation: []Text{" Can not rebond without unlocking chunks."}}, ErrorMetadataV8{Name: "FundedTarget", Documentation: []Text{" Attempting to target a stash that still has funds."}}, ErrorMetadataV8{Name: "InvalidEraToReward", Documentation: []Text{" Invalid era to reward."}}, ErrorMetadataV8{Name: "InvalidNumberOfNominations", Documentation: []Text{" Invalid number of nominations."}}, ErrorMetadataV8{Name: "NotSortedAndUnique", Documentation: []Text{" Items are not sorted and unique."}}, ErrorMetadataV8{Name: "AlreadyClaimed", Documentation: []Text{" Rewards for this era have already been claimed for this validator."}}, ErrorMetadataV8{Name: "OffchainElectionEarlySubmission", Documentation: []Text{" The submitted result is received out of the open window."}}, ErrorMetadataV8{Name: "OffchainElectionWeakSubmission", Documentation: []Text{" The submitted result is not as good as the one stored on chain."}}, ErrorMetadataV8{Name: "SnapshotUnavailable", Documentation: []Text{" The snapshot data of the current window is missing."}}, ErrorMetadataV8{Name: "OffchainElectionBogusWinnerCount", Documentation: []Text{" Incorrect number of winners were presented."}}, ErrorMetadataV8{Name: "OffchainElectionBogusWinner", Documentation: []Text{" One of the submitted winners is not an active candidate on chain (index is out of range", " in snapshot)."}}, ErrorMetadataV8{Name: "OffchainElectionBogusCompact", Documentation: []Text{" Error while building the assignment type from the compact. This can happen if an index", " is invalid, or if the weights _overflow_."}}, ErrorMetadataV8{Name: "OffchainElectionBogusNominator", Documentation: []Text{" One of the submitted nominators is not an active nominator on chain."}}, ErrorMetadataV8{Name: "OffchainElectionBogusNomination", Documentation: []Text{" One of the submitted nominators has an edge to which they have not voted on chain."}}, ErrorMetadataV8{Name: "OffchainElectionSlashedNomination", Documentation: []Text{" One of the submitted nominators has an edge which is submitted before the last non-zero", " slash of the target."}}, ErrorMetadataV8{Name: "OffchainElectionBogusSelfVote", Documentation: []Text{" A self vote must only be originated from a validator to ONLY themselves."}}, ErrorMetadataV8{Name: "OffchainElectionBogusEdge", Documentation: []Text{" The submitted result has unknown edges that are not among the presented winners."}}, ErrorMetadataV8{Name: "OffchainElectionBogusScore", Documentation: []Text{" The claimed score does not match with the one computed from the data."}}, ErrorMetadataV8{Name: "OffchainElectionBogusElectionSize", Documentation: []Text{" The election size is invalid."}}, ErrorMetadataV8{Name: "CallNotAllowed", Documentation: []Text{" The call is not allowed at the given time due to restrictions of election period."}}, ErrorMetadataV8{Name: "IncorrectHistoryDepth", Documentation: []Text{" Incorrect previous history depth input provided."}}, ErrorMetadataV8{Name: "IncorrectSlashingSpans", Documentation: []Text{" Incorrect number of slashing spans provided."}}}}, ModuleMetadataV10{Name: "Session", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Session", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Validators", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::ValidatorId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current set of validators."}}, StorageFunctionMetadataV10{Name: "CurrentIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "SessionIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Current index of the session."}}, StorageFunctionMetadataV10{Name: "QueuedChanged", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" True if the underlying economic identities or weighting behind the validators", " has changed in the queued validator set."}}, StorageFunctionMetadataV10{Name: "QueuedKeys", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<(T::ValidatorId, T::Keys)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The queued keys for the next session. When the next session begins, these keys", " will be used to determine the validator's session keys."}}, StorageFunctionMetadataV10{Name: "DisabledValidators", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<u32>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Indices of disabled validators.", "", " The set is cleared when `on_session_ending` returns a new set of identities."}}, StorageFunctionMetadataV10{Name: "NextKeys", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::ValidatorId", Value: "T::Keys", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The next session keys for a validator."}}, StorageFunctionMetadataV10{Name: "KeyOwner", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "(KeyTypeId, Vec<u8>)", Value: "T::ValidatorId", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The owner of a key. The key is the `KeyTypeId` + the encoded key."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "set_keys", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "keys", Type: "T::Keys"}, FunctionArgumentMetadata{Name: "proof", Type: "Vec<u8>"}}, Documentation: []Text{" Sets the session key(s) of the function caller to `keys`.", " Allows an account to set its session key prior to becoming a validator.", " This doesn't take effect until the next session.", "", " The dispatch origin of this function must be signed.", "", " # <weight>", " - Complexity: `O(1)`", "   Actual cost depends on the number of length of `T::Keys::key_ids()` which is fixed.", " - DbReads: `origin account`, `T::ValidatorIdOf`, `NextKeys`", " - DbWrites: `origin account`, `NextKeys`", " - DbReads per key id: `KeyOwner`", " - DbWrites per key id: `KeyOwner`", " # </weight>"}}, FunctionMetadataV4{Name: "purge_keys", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Removes any session key(s) of the function caller.", " This doesn't take effect until the next session.", "", " The dispatch origin of this function must be signed.", "", " # <weight>", " - Complexity: `O(1)` in number of key ", "   Actual cost depends on the number of length of `T::Keys::key_ids()` which is fixed.", " - DbReads: `T::ValidatorIdOf`, `NextKeys`, `origin account`", " - DbWrites: `NextKeys`, `origin account`", " - DbWrites per key id: `KeyOwnder`", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "NewSession", Args: []Type{"SessionIndex"}, Documentation: []Text{" New session has happened. Note that the argument is the [session_index], not the block", " number as the type might suggest."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InvalidProof", Documentation: []Text{" Invalid ownership proof."}}, ErrorMetadataV8{Name: "NoAssociatedValidatorId", Documentation: []Text{" No associated validator ID for account."}}, ErrorMetadataV8{Name: "DuplicatedKey", Documentation: []Text{" Registered duplicate key."}}, ErrorMetadataV8{Name: "NoKeys", Documentation: []Text{" No keys are associated with this account."}}}}, ModuleMetadataV10{Name: "Democracy", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Democracy", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "PublicPropCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "PropIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of (public) proposals that have been made so far."}}, StorageFunctionMetadataV10{Name: "PublicProps", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<(PropIndex, T::Hash, T::AccountId)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The public proposals. Unsorted. The second item is the proposal's hash."}}, StorageFunctionMetadataV10{Name: "DepositOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "PropIndex", Value: "(Vec<T::AccountId>, BalanceOf<T>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Those who have locked a deposit.", "", " TWOX-NOTE: Safe, as increasing integer keys are safe."}}, StorageFunctionMetadataV10{Name: "Preimages", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "T::Hash", Value: "PreimageStatus<T::AccountId, BalanceOf<T>, T::BlockNumber>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Map of hashes to the proposal preimage, along with who registered it and their deposit.", " The block number is the block at which it was deposited."}}, StorageFunctionMetadataV10{Name: "ReferendumCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "ReferendumIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The next free referendum index, aka the number of referenda started so far."}}, StorageFunctionMetadataV10{Name: "LowestUnbaked", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "ReferendumIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The lowest referendum index representing an unbaked referendum. Equal to", " `ReferendumCount` if there isn't a unbaked referendum."}}, StorageFunctionMetadataV10{Name: "ReferendumInfoOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "ReferendumIndex", Value: "ReferendumInfo<T::BlockNumber, T::Hash, BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Information concerning any given referendum.", "", " TWOX-NOTE: SAFE as indexes are not under an attacker’s control."}}, StorageFunctionMetadataV10{Name: "VotingOf", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "Voting<BalanceOf<T>, T::AccountId, T::BlockNumber>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" All votes for a particular voter. We store the balance for the number of votes that we", " have recorded. The second item is the total amount of delegations, that will be added.", "", " TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway."}}, StorageFunctionMetadataV10{Name: "Locks", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "T::BlockNumber", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Accounts for which there are locks in action which may be removed at some point in the", " future. The value is the block number at which the lock expires and may be removed.", "", " TWOX-NOTE: OK ― `AccountId` is a secure hash."}}, StorageFunctionMetadataV10{Name: "LastTabledWasExternal", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "bool", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" True if the last referendum tabled was submitted externally. False if it was a public", " proposal."}}, StorageFunctionMetadataV10{Name: "NextExternal", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "(T::Hash, VoteThreshold)", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The referendum to be tabled whenever it would be valid to table an external proposal.", " This happens when a referendum needs to be tabled and one of two conditions are met:", " - `LastTabledWasExternal` is `false`; or", " - `PublicProps` is empty."}}, StorageFunctionMetadataV10{Name: "Blacklist", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "T::Hash", Value: "(T::BlockNumber, Vec<T::AccountId>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A record of who vetoed what. Maps proposal hash to a possible existent block number", " (until when it may not be resubmitted) and who vetoed it."}}, StorageFunctionMetadataV10{Name: "Cancellations", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "T::Hash", Value: "bool", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Record of all proposals that have been subject to emergency cancellation."}}, StorageFunctionMetadataV10{Name: "StorageVersion", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Releases", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Storage version of the pallet.", "", " New networks start with last version."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "propose", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Propose a sensitive action to be taken.", "", " The dispatch origin of this call must be _Signed_ and the sender must", " have funds to cover the deposit.", "", " - `proposal_hash`: The hash of the proposal preimage.", " - `value`: The amount of deposit (must be at least `MinimumDeposit`).", "", " Emits `Proposed`.", "", " # <weight>", " - Complexity: `O(1)`", " - Db reads: `PublicPropCount`, `PublicProps`", " - Db writes: `PublicPropCount`, `PublicProps`, `DepositOf`", " # </weight>"}}, FunctionMetadataV4{Name: "second", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal", Type: "Compact<PropIndex>"}, FunctionArgumentMetadata{Name: "seconds_upper_bound", Type: "Compact<u32>"}}, Documentation: []Text{" Signals agreement with a particular proposal.", "", " The dispatch origin of this call must be _Signed_ and the sender", " must have funds to cover the deposit, equal to the original deposit.", "", " - `proposal`: The index of the proposal to second.", " - `seconds_upper_bound`: an upper bound on the current number of seconds on this", "   proposal. Extrinsic is weighted according to this value with no refund.", "", " # <weight>", " - Complexity: `O(S)` where S is the number of seconds a proposal already has.", " - Db reads: `DepositOf`", " - Db writes: `DepositOf`", " # </weight>"}}, FunctionMetadataV4{Name: "vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "ref_index", Type: "Compact<ReferendumIndex>"}, FunctionArgumentMetadata{Name: "vote", Type: "AccountVote<BalanceOf<T>>"}}, Documentation: []Text{" Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;", " otherwise it is a vote to keep the status quo.", "", " The dispatch origin of this call must be _Signed_.", "", " - `ref_index`: The index of the referendum to vote for.", " - `vote`: The vote configuration.", "", " # <weight>", " - Complexity: `O(R)` where R is the number of referendums the voter has voted on.", "   weight is charged as if maximum votes.", " - Db reads: `ReferendumInfoOf`, `VotingOf`, `balances locks`", " - Db writes: `ReferendumInfoOf`, `VotingOf`, `balances locks`", " # </weight>"}}, FunctionMetadataV4{Name: "emergency_cancel", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "ref_index", Type: "ReferendumIndex"}}, Documentation: []Text{" Schedule an emergency cancellation of a referendum. Cannot happen twice to the same", " referendum.", "", " The dispatch origin of this call must be `CancellationOrigin`.", "", " -`ref_index`: The index of the referendum to cancel.", "", " # <weight>", " - Complexity: `O(1)`.", " - Db reads: `ReferendumInfoOf`, `Cancellations`", " - Db writes: `ReferendumInfoOf`, `Cancellations`", " # </weight>"}}, FunctionMetadataV4{Name: "external_propose", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Schedule a referendum to be tabled once it is legal to schedule an external", " referendum.", "", " The dispatch origin of this call must be `ExternalOrigin`.", "", " - `proposal_hash`: The preimage hash of the proposal.", "", " # <weight>", " - Complexity `O(V)` with V number of vetoers in the blacklist of proposal.", "   Decoding vec of length V. Charged as maximum", " - Db reads: `NextExternal`, `Blacklist`", " - Db writes: `NextExternal`", " # </weight>"}}, FunctionMetadataV4{Name: "external_propose_majority", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Schedule a majority-carries referendum to be tabled next once it is legal to schedule", " an external referendum.", "", " The dispatch of this call must be `ExternalMajorityOrigin`.", "", " - `proposal_hash`: The preimage hash of the proposal.", "", " Unlike `external_propose`, blacklisting has no effect on this and it may replace a", " pre-scheduled `external_propose` call.", "", " # <weight>", " - Complexity: `O(1)`", " - Db write: `NextExternal`", " # </weight>"}}, FunctionMetadataV4{Name: "external_propose_default", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Schedule a negative-turnout-bias referendum to be tabled next once it is legal to", " schedule an external referendum.", "", " The dispatch of this call must be `ExternalDefaultOrigin`.", "", " - `proposal_hash`: The preimage hash of the proposal.", "", " Unlike `external_propose`, blacklisting has no effect on this and it may replace a", " pre-scheduled `external_propose` call.", "", " # <weight>", " - Complexity: `O(1)`", " - Db write: `NextExternal`", " # </weight>"}}, FunctionMetadataV4{Name: "fast_track", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "voting_period", Type: "T::BlockNumber"}, FunctionArgumentMetadata{Name: "delay", Type: "T::BlockNumber"}}, Documentation: []Text{" Schedule the currently externally-proposed majority-carries referendum to be tabled", " immediately. If there is no externally-proposed referendum currently, or if there is one", " but it is not a majority-carries referendum then it fails.", "", " The dispatch of this call must be `FastTrackOrigin`.", "", " - `proposal_hash`: The hash of the current external proposal.", " - `voting_period`: The period that is allowed for voting on this proposal. Increased to", "   `FastTrackVotingPeriod` if too low.", " - `delay`: The number of block after voting has ended in approval and this should be", "   enacted. This doesn't have a minimum amount.", "", " Emits `Started`.", "", " # <weight>", " - Complexity: `O(1)`", " - Db reads: `NextExternal`, `ReferendumCount`", " - Db writes: `NextExternal`, `ReferendumCount`, `ReferendumInfoOf`", " - Base Weight: 30.1 µs", " # </weight>"}}, FunctionMetadataV4{Name: "veto_external", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Veto and blacklist the external proposal hash.", "", " The dispatch origin of this call must be `VetoOrigin`.", "", " - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.", "", " Emits `Vetoed`.", "", " # <weight>", " - Complexity: `O(V + log(V))` where V is number of `existing vetoers`", "   Performs a binary search on `existing_vetoers` which should not be very large.", " - Db reads: `NextExternal`, `Blacklist`", " - Db writes: `NextExternal`, `Blacklist`", " # </weight>"}}, FunctionMetadataV4{Name: "cancel_referendum", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "ref_index", Type: "Compact<ReferendumIndex>"}}, Documentation: []Text{" Remove a referendum.", "", " The dispatch origin of this call must be _Root_.", "", " - `ref_index`: The index of the referendum to cancel.", "", " # <weight>", " - Complexity: `O(1)`.", " - Db writes: `ReferendumInfoOf`", " # </weight>"}}, FunctionMetadataV4{Name: "cancel_queued", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "which", Type: "ReferendumIndex"}}, Documentation: []Text{" Cancel a proposal queued for enactment.", "", " The dispatch origin of this call must be _Root_.", "", " - `which`: The index of the referendum to cancel.", "", " # <weight>", " - `O(D)` where `D` is the items in the dispatch queue. Weighted as `D = 10`.", " - Db reads: `scheduler lookup`, scheduler agenda`", " - Db writes: `scheduler lookup`, scheduler agenda`", " # </weight>"}}, FunctionMetadataV4{Name: "delegate", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "to", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "conviction", Type: "Conviction"}, FunctionArgumentMetadata{Name: "balance", Type: "BalanceOf<T>"}}, Documentation: []Text{" Delegate the voting power (with some given conviction) of the sending account.", "", " The balance delegated is locked for as long as it's delegated, and thereafter for the", " time appropriate for the conviction's lock period.", "", " The dispatch origin of this call must be _Signed_, and the signing account must either:", "   - be delegating already; or", "   - have no voting activity (if there is, then it will need to be removed/consolidated", "     through `reap_vote` or `unvote`).", "", " - `to`: The account whose voting the `target` account's voting power will follow.", " - `conviction`: The conviction that will be attached to the delegated votes. When the", "   account is undelegated, the funds will be locked for the corresponding period.", " - `balance`: The amount of the account's balance to be used in delegating. This must", "   not be more than the account's current balance.", "", " Emits `Delegated`.", "", " # <weight>", " - Complexity: `O(R)` where R is the number of referendums the voter delegating to has", "   voted on. Weight is charged as if maximum votes.", " - Db reads: 3*`VotingOf`, `origin account locks`", " - Db writes: 3*`VotingOf`, `origin account locks`", " - Db reads per votes: `ReferendumInfoOf`", " - Db writes per votes: `ReferendumInfoOf`", " # </weight>"}}, FunctionMetadataV4{Name: "undelegate", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Undelegate the voting power of the sending account.", "", " Tokens may be unlocked following once an amount of time consistent with the lock period", " of the conviction with which the delegation was issued.", "", " The dispatch origin of this call must be _Signed_ and the signing account must be", " currently delegating.", "", " Emits `Undelegated`.", "", " # <weight>", " - Complexity: `O(R)` where R is the number of referendums the voter delegating to has", "   voted on. Weight is charged as if maximum votes.", " - Db reads: 2*`VotingOf`", " - Db writes: 2*`VotingOf`", " - Db reads per votes: `ReferendumInfoOf`", " - Db writes per votes: `ReferendumInfoOf`", " # </weight>"}}, FunctionMetadataV4{Name: "clear_public_proposals", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Clears all public proposals.", "", " The dispatch origin of this call must be _Root_.", "", " # <weight>", " - `O(1)`.", " - Db writes: `PublicProps`", " # </weight>"}}, FunctionMetadataV4{Name: "note_preimage", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "encoded_proposal", Type: "Vec<u8>"}}, Documentation: []Text{" Register the preimage for an upcoming proposal. This doesn't require the proposal to be", " in the dispatch queue but does require a deposit, returned once enacted.", "", " The dispatch origin of this call must be _Signed_.", "", " - `encoded_proposal`: The preimage of a proposal.", "", " Emits `PreimageNoted`.", "", " # <weight>", " - Complexity: `O(E)` with E size of `encoded_proposal` (protected by a required deposit).", " - Db reads: `Preimages`", " - Db writes: `Preimages`", " # </weight>"}}, FunctionMetadataV4{Name: "note_preimage_operational", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "encoded_proposal", Type: "Vec<u8>"}}, Documentation: []Text{" Same as `note_preimage` but origin is `OperationalPreimageOrigin`."}}, FunctionMetadataV4{Name: "note_imminent_preimage", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "encoded_proposal", Type: "Vec<u8>"}}, Documentation: []Text{" Register the preimage for an upcoming proposal. This requires the proposal to be", " in the dispatch queue. No deposit is needed. When this call is successful, i.e.", " the preimage has not been uploaded before and matches some imminent proposal,", " no fee is paid.", "", " The dispatch origin of this call must be _Signed_.", "", " - `encoded_proposal`: The preimage of a proposal.", "", " Emits `PreimageNoted`.", "", " # <weight>", " - Complexity: `O(E)` with E size of `encoded_proposal` (protected by a required deposit).", " - Db reads: `Preimages`", " - Db writes: `Preimages`", " # </weight>"}}, FunctionMetadataV4{Name: "note_imminent_preimage_operational", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "encoded_proposal", Type: "Vec<u8>"}}, Documentation: []Text{" Same as `note_imminent_preimage` but origin is `OperationalPreimageOrigin`."}}, FunctionMetadataV4{Name: "reap_preimage", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "proposal_len_upper_bound", Type: "Compact<u32>"}}, Documentation: []Text{" Remove an expired proposal preimage and collect the deposit.", "", " The dispatch origin of this call must be _Signed_.", "", " - `proposal_hash`: The preimage hash of a proposal.", " - `proposal_length_upper_bound`: an upper bound on length of the proposal.", "   Extrinsic is weighted according to this value with no refund.", "", " This will only work after `VotingPeriod` blocks from the time that the preimage was", " noted, if it's the same account doing it. If it's a different account, then it'll only", " work an additional `EnactmentPeriod` later.", "", " Emits `PreimageReaped`.", "", " # <weight>", " - Complexity: `O(D)` where D is length of proposal.", " - Db reads: `Preimages`, provider account data", " - Db writes: `Preimages` provider account data", " # </weight>"}}, FunctionMetadataV4{Name: "unlock", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "target", Type: "T::AccountId"}}, Documentation: []Text{" Unlock tokens that have an expired lock.", "", " The dispatch origin of this call must be _Signed_.", "", " - `target`: The account to remove the lock on.", "", " # <weight>", " - Complexity `O(R)` with R number of vote of target.", " - Db reads: `VotingOf`, `balances locks`, `target account`", " - Db writes: `VotingOf`, `balances locks`, `target account`", " # </weight>"}}, FunctionMetadataV4{Name: "remove_vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "ReferendumIndex"}}, Documentation: []Text{" Remove a vote for a referendum.", "", " If:", " - the referendum was cancelled, or", " - the referendum is ongoing, or", " - the referendum has ended such that", "   - the vote of the account was in opposition to the result; or", "   - there was no conviction to the account's vote; or", "   - the account made a split vote", " ...then the vote is removed cleanly and a following call to `unlock` may result in more", " funds being available.", "", " If, however, the referendum has ended and:", " - it finished corresponding to the vote of the account, and", " - the account made a standard vote with conviction, and", " - the lock period of the conviction is not over", " ...then the lock will be aggregated into the overall account's lock, which may involve", " *overlocking* (where the two locks are combined into a single lock that is the maximum", " of both the amount locked and the time is it locked for).", "", " The dispatch origin of this call must be _Signed_, and the signer must have a vote", " registered for referendum `index`.", "", " - `index`: The index of referendum of the vote to be removed.", "", " # <weight>", " - `O(R + log R)` where R is the number of referenda that `target` has voted on.", "   Weight is calculated for the maximum number of vote.", " - Db reads: `ReferendumInfoOf`, `VotingOf`", " - Db writes: `ReferendumInfoOf`, `VotingOf`", " # </weight>"}}, FunctionMetadataV4{Name: "remove_other_vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "target", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "index", Type: "ReferendumIndex"}}, Documentation: []Text{" Remove a vote for a referendum.", "", " If the `target` is equal to the signer, then this function is exactly equivalent to", " `remove_vote`. If not equal to the signer, then the vote must have expired,", " either because the referendum was cancelled, because the voter lost the referendum or", " because the conviction period is over.", "", " The dispatch origin of this call must be _Signed_.", "", " - `target`: The account of the vote to be removed; this account must have voted for", "   referendum `index`.", " - `index`: The index of referendum of the vote to be removed.", "", " # <weight>", " - `O(R + log R)` where R is the number of referenda that `target` has voted on.", "   Weight is calculated for the maximum number of vote.", " - Db reads: `ReferendumInfoOf`, `VotingOf`", " - Db writes: `ReferendumInfoOf`, `VotingOf`", " # </weight>"}}, FunctionMetadataV4{Name: "enact_proposal", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "index", Type: "ReferendumIndex"}}, Documentation: []Text{" Enact a proposal from a referendum. For now we just make the weight be the maximum."}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Proposed", Args: []Type{"PropIndex", "Balance"}, Documentation: []Text{" A motion has been proposed by a public account. [proposal_index, deposit]"}}, EventMetadataV4{Name: "Tabled", Args: []Type{"PropIndex", "Balance", "Vec<AccountId>"}, Documentation: []Text{" A public proposal has been tabled for referendum vote. [proposal_index, deposit, depositors]"}}, EventMetadataV4{Name: "ExternalTabled", Args: []Type(nil), Documentation: []Text{" An external proposal has been tabled."}}, EventMetadataV4{Name: "Started", Args: []Type{"ReferendumIndex", "VoteThreshold"}, Documentation: []Text{" A referendum has begun. [ref_index, threshold]"}}, EventMetadataV4{Name: "Passed", Args: []Type{"ReferendumIndex"}, Documentation: []Text{" A proposal has been approved by referendum. [ref_index]"}}, EventMetadataV4{Name: "NotPassed", Args: []Type{"ReferendumIndex"}, Documentation: []Text{" A proposal has been rejected by referendum. [ref_index]"}}, EventMetadataV4{Name: "Cancelled", Args: []Type{"ReferendumIndex"}, Documentation: []Text{" A referendum has been cancelled. [ref_index]"}}, EventMetadataV4{Name: "Executed", Args: []Type{"ReferendumIndex", "bool"}, Documentation: []Text{" A proposal has been enacted. [ref_index, is_ok]"}}, EventMetadataV4{Name: "Delegated", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" An account has delegated their vote to another account. [who, target]"}}, EventMetadataV4{Name: "Undelegated", Args: []Type{"AccountId"}, Documentation: []Text{" An [account] has cancelled a previous delegation operation."}}, EventMetadataV4{Name: "Vetoed", Args: []Type{"AccountId", "Hash", "BlockNumber"}, Documentation: []Text{" An external proposal has been vetoed. [who, proposal_hash, until]"}}, EventMetadataV4{Name: "PreimageNoted", Args: []Type{"Hash", "AccountId", "Balance"}, Documentation: []Text{" A proposal's preimage was noted, and the deposit taken. [proposal_hash, who, deposit]"}}, EventMetadataV4{Name: "PreimageUsed", Args: []Type{"Hash", "AccountId", "Balance"}, Documentation: []Text{" A proposal preimage was removed and used (the deposit was returned).", " [proposal_hash, provider, deposit]"}}, EventMetadataV4{Name: "PreimageInvalid", Args: []Type{"Hash", "ReferendumIndex"}, Documentation: []Text{" A proposal could not be executed because its preimage was invalid. [proposal_hash, ref_index]"}}, EventMetadataV4{Name: "PreimageMissing", Args: []Type{"Hash", "ReferendumIndex"}, Documentation: []Text{" A proposal could not be executed because its preimage was missing. [proposal_hash, ref_index]"}}, EventMetadataV4{Name: "PreimageReaped", Args: []Type{"Hash", "AccountId", "Balance", "AccountId"}, Documentation: []Text{" A registered preimage was removed and the deposit collected by the reaper.", " [proposal_hash, provider, deposit, reaper]"}}, EventMetadataV4{Name: "Unlocked", Args: []Type{"AccountId"}, Documentation: []Text{" An [account] has been unlocked successfully."}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "EnactmentPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x2f, 0xd, 0x0}, Documentation: []Text{" The minimum period of locking and the period between a proposal being approved and enacted.", "", " It should generally be a little more than the unstake period to ensure that", " voting stakers have an opportunity to remove themselves from the system in the case where", " they are on the losing side of a vote."}}, ModuleConstantMetadataV6{Name: "LaunchPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x4e, 0xc, 0x0}, Documentation: []Text{" How often (in blocks) new public referenda are launched."}}, ModuleConstantMetadataV6{Name: "VotingPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x4e, 0xc, 0x0}, Documentation: []Text{" How often (in blocks) to check for new votes."}}, ModuleConstantMetadataV6{Name: "MinimumDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x0, 0xc1, 0x6f, 0xf2, 0x86, 0x23, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount to be used as a deposit for a public referendum proposal."}}, ModuleConstantMetadataV6{Name: "FastTrackVotingPeriod", Type: "T::BlockNumber", Value: Bytes{0x80, 0x51, 0x1, 0x0}, Documentation: []Text{" Minimum voting period allowed for an emergency referendum."}}, ModuleConstantMetadataV6{Name: "CooloffPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x4e, 0xc, 0x0}, Documentation: []Text{" Period in blocks where an external proposal may not be re-submitted after being vetoed."}}, ModuleConstantMetadataV6{Name: "PreimageByteDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of balance that must be deposited per byte of preimage stored."}}, ModuleConstantMetadataV6{Name: "MaxVotes", Type: "u32", Value: Bytes{0x64, 0x0, 0x0, 0x0}, Documentation: []Text{" The maximum number of votes for an account."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "ValueLow", Documentation: []Text{" Value too low"}}, ErrorMetadataV8{Name: "ProposalMissing", Documentation: []Text{" Proposal does not exist"}}, ErrorMetadataV8{Name: "BadIndex", Documentation: []Text{" Unknown index"}}, ErrorMetadataV8{Name: "AlreadyCanceled", Documentation: []Text{" Cannot cancel the same proposal twice"}}, ErrorMetadataV8{Name: "DuplicateProposal", Documentation: []Text{" Proposal already made"}}, ErrorMetadataV8{Name: "ProposalBlacklisted", Documentation: []Text{" Proposal still blacklisted"}}, ErrorMetadataV8{Name: "NotSimpleMajority", Documentation: []Text{" Next external proposal not simple majority"}}, ErrorMetadataV8{Name: "InvalidHash", Documentation: []Text{" Invalid hash"}}, ErrorMetadataV8{Name: "NoProposal", Documentation: []Text{" No external proposal"}}, ErrorMetadataV8{Name: "AlreadyVetoed", Documentation: []Text{" Identity may not veto a proposal twice"}}, ErrorMetadataV8{Name: "NotDelegated", Documentation: []Text{" Not delegated"}}, ErrorMetadataV8{Name: "DuplicatePreimage", Documentation: []Text{" Preimage already noted"}}, ErrorMetadataV8{Name: "NotImminent", Documentation: []Text{" Not imminent"}}, ErrorMetadataV8{Name: "TooEarly", Documentation: []Text{" Too early"}}, ErrorMetadataV8{Name: "Imminent", Documentation: []Text{" Imminent"}}, ErrorMetadataV8{Name: "PreimageMissing", Documentation: []Text{" Preimage not found"}}, ErrorMetadataV8{Name: "ReferendumInvalid", Documentation: []Text{" Vote given for invalid referendum"}}, ErrorMetadataV8{Name: "PreimageInvalid", Documentation: []Text{" Invalid preimage"}}, ErrorMetadataV8{Name: "NoneWaiting", Documentation: []Text{" No proposals waiting"}}, ErrorMetadataV8{Name: "NotLocked", Documentation: []Text{" The target account does not have a lock."}}, ErrorMetadataV8{Name: "NotExpired", Documentation: []Text{" The lock on the account to be unlocked has not yet expired."}}, ErrorMetadataV8{Name: "NotVoter", Documentation: []Text{" The given account did not vote on the referendum."}}, ErrorMetadataV8{Name: "NoPermission", Documentation: []Text{" The actor has no permission to conduct the action."}}, ErrorMetadataV8{Name: "AlreadyDelegating", Documentation: []Text{" The account is already delegating."}}, ErrorMetadataV8{Name: "Overflow", Documentation: []Text{" An unexpected integer overflow occurred."}}, ErrorMetadataV8{Name: "Underflow", Documentation: []Text{" An unexpected integer underflow occurred."}}, ErrorMetadataV8{Name: "InsufficientFunds", Documentation: []Text{" Too high a balance was provided that the account cannot afford."}}, ErrorMetadataV8{Name: "NotDelegating", Documentation: []Text{" The account is not currently delegating."}}, ErrorMetadataV8{Name: "VotesExist", Documentation: []Text{" The account currently has votes attached to it and the operation cannot succeed until", " these are removed, either through `unvote` or `reap_vote`."}}, ErrorMetadataV8{Name: "InstantNotAllowed", Documentation: []Text{" The instant referendum origin is currently disallowed."}}, ErrorMetadataV8{Name: "Nonsense", Documentation: []Text{" Delegation to oneself makes no sense."}}, ErrorMetadataV8{Name: "WrongUpperBound", Documentation: []Text{" Invalid upper bound."}}, ErrorMetadataV8{Name: "MaxVotesReached", Documentation: []Text{" Maximum number of votes reached."}}}}, ModuleMetadataV10{Name: "Council", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Instance1Collective", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Proposals", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::Hash>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The hashes of the active proposals."}}, StorageFunctionMetadataV10{Name: "ProposalOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "T::Hash", Value: "<T as Trait<I>>::Proposal", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Actual proposal for a given hash, if it's current."}}, StorageFunctionMetadataV10{Name: "Voting", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "T::Hash", Value: "Votes<T::AccountId, T::BlockNumber>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Votes on a given proposal, if it is ongoing."}}, StorageFunctionMetadataV10{Name: "ProposalCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Proposals so far."}}, StorageFunctionMetadataV10{Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current members of the collective. This is stored sorted (just by value)."}}, StorageFunctionMetadataV10{Name: "Prime", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The member who provides the default vote for any other members that do not vote before", " the timeout. If None, then no member has that privilege."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "set_members", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new_members", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "prime", Type: "Option<T::AccountId>"}, FunctionArgumentMetadata{Name: "old_count", Type: "MemberCount"}}, Documentation: []Text{" Set the collective's membership.", "", " - `new_members`: The new member list. Be nice to the chain and provide it sorted.", " - `prime`: The prime member whose vote sets the default.", " - `old_count`: The upper bound for the previous number of members in storage.", "                Used for weight estimation.", "", " Requires root origin.", "", " NOTE: Does not enforce the expected `MAX_MEMBERS` limit on the amount of members, but", "       the weight estimations rely on it to estimate dispatchable weight.", "", " # <weight>", " ## Weight", " - `O(MP + N)` where:", "   - `M` old-members-count (code- and governance-bounded)", "   - `N` new-members-count (code- and governance-bounded)", "   - `P` proposals-count (code-bounded)", " - DB:", "   - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members", "   - 1 storage read (codec `O(P)`) for reading the proposals", "   - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal", "   - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one", " # </weight>"}}, FunctionMetadataV4{Name: "execute", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal", Type: "Box<<T as Trait<I>>::Proposal>"}, FunctionArgumentMetadata{Name: "length_bound", Type: "Compact<u32>"}}, Documentation: []Text{" Dispatch a proposal from a member using the `Member` origin.", "", " Origin must be a member of the collective.", "", " # <weight>", " ## Weight", " - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`", " - DB: 1 read (codec `O(M)`) + DB access of `proposal`", " - 1 event", " # </weight>"}}, FunctionMetadataV4{Name: "propose", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "threshold", Type: "Compact<MemberCount>"}, FunctionArgumentMetadata{Name: "proposal", Type: "Box<<T as Trait<I>>::Proposal>"}, FunctionArgumentMetadata{Name: "length_bound", Type: "Compact<u32>"}}, Documentation: []Text{" Add a new proposal to either be voted on or executed directly.", "", " Requires the sender to be member.", "", " `threshold` determines whether `proposal` is executed directly (`threshold < 2`)", " or put up for voting.", "", " # <weight>", " ## Weight", " - `O(B + M + P1)` or `O(B + M + P2)` where:", "   - `B` is `proposal` size in bytes (length-fee-bounded)", "   - `M` is members-count (code- and governance-bounded)", "   - branching is influenced by `threshold` where:", "     - `P1` is proposal execution complexity (`threshold < 2`)", "     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)", " - DB:", "   - 1 storage read `is_member` (codec `O(M)`)", "   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)", "   - DB accesses influenced by `threshold`:", "     - EITHER storage accesses done by `proposal` (`threshold < 2`)", "     - OR proposal insertion (`threshold <= 2`)", "       - 1 storage mutation `Proposals` (codec `O(P2)`)", "       - 1 storage mutation `ProposalCount` (codec `O(1)`)", "       - 1 storage write `ProposalOf` (codec `O(B)`)", "       - 1 storage write `Voting` (codec `O(M)`)", "   - 1 event", " # </weight>"}}, FunctionMetadataV4{Name: "vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "index", Type: "Compact<ProposalIndex>"}, FunctionArgumentMetadata{Name: "approve", Type: "bool"}}, Documentation: []Text{" Add an aye or nay vote for the sender to the given proposal.", "", " Requires the sender to be a member.", "", " # <weight>", " ## Weight", " - `O(M)` where `M` is members-count (code- and governance-bounded)", " - DB:", "   - 1 storage read `Members` (codec `O(M)`)", "   - 1 storage mutation `Voting` (codec `O(M)`)", " - 1 event", " # </weight>"}}, FunctionMetadataV4{Name: "close", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "index", Type: "Compact<ProposalIndex>"}, FunctionArgumentMetadata{Name: "proposal_weight_bound", Type: "Compact<Weight>"}, FunctionArgumentMetadata{Name: "length_bound", Type: "Compact<u32>"}}, Documentation: []Text{" Close a vote that is either approved, disapproved or whose voting period has ended.", "", " May be called by any signed account in order to finish voting and close the proposal.", "", " If called before the end of the voting period it will only close the vote if it is", " has enough votes to be approved or disapproved.", "", " If called after the end of the voting period abstentions are counted as rejections", " unless there is a prime member set and the prime member cast an approval.", "", " + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.", " + `length_bound`: The upper bound for the length of the proposal in storage. Checked via", "                   `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.", "", " # <weight>", " ## Weight", " - `O(B + M + P1 + P2)` where:", "   - `B` is `proposal` size in bytes (length-fee-bounded)", "   - `M` is members-count (code- and governance-bounded)", "   - `P1` is the complexity of `proposal` preimage.", "   - `P2` is proposal-count (code-bounded)", " - DB:", "  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)", "  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)", "  - any mutations done while executing `proposal` (`P1`)", " - up to 3 events", " # </weight>"}}, FunctionMetadataV4{Name: "disapprove_proposal", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Disapprove a proposal, close, and remove it from the system, regardless of its current state.", "", " Must be called by the Root origin.", "", " Parameters:", " * `proposal_hash`: The hash of the proposal that should be disapproved.", "", " # <weight>", " Complexity: O(P) where P is the number of max proposals", " Base Weight: .49 * P", " DB Weight:", " * Reads: Proposals", " * Writes: Voting, Proposals, ProposalOf", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Proposed", Args: []Type{"AccountId", "ProposalIndex", "Hash", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been proposed (by given account) with a threshold (given", " `MemberCount`).", " [account, proposal_index, proposal_hash, threshold]"}}, EventMetadataV4{Name: "Voted", Args: []Type{"AccountId", "Hash", "bool", "MemberCount", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been voted on by given account, leaving", " a tally (yes votes and no votes given respectively as `MemberCount`).", " [account, proposal_hash, voted, yes, no]"}}, EventMetadataV4{Name: "Approved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was approved by the required threshold.", " [proposal_hash]"}}, EventMetadataV4{Name: "Disapproved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was not approved by the required threshold.", " [proposal_hash]"}}, EventMetadataV4{Name: "Executed", Args: []Type{"Hash", "DispatchResult"}, Documentation: []Text{" A motion was executed; result will be `Ok` if it returned without error.", " [proposal_hash, result]"}}, EventMetadataV4{Name: "MemberExecuted", Args: []Type{"Hash", "DispatchResult"}, Documentation: []Text{" A single member did some action; result will be `Ok` if it returned without error.", " [proposal_hash, result]"}}, EventMetadataV4{Name: "Closed", Args: []Type{"Hash", "MemberCount", "MemberCount"}, Documentation: []Text{" A proposal was closed because its threshold was reached or after its duration was up.", " [proposal_hash, yes, no]"}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "NotMember", Documentation: []Text{" Account is not a member"}}, ErrorMetadataV8{Name: "DuplicateProposal", Documentation: []Text{" Duplicate proposals not allowed"}}, ErrorMetadataV8{Name: "ProposalMissing", Documentation: []Text{" Proposal must exist"}}, ErrorMetadataV8{Name: "WrongIndex", Documentation: []Text{" Mismatched index"}}, ErrorMetadataV8{Name: "DuplicateVote", Documentation: []Text{" Duplicate vote ignored"}}, ErrorMetadataV8{Name: "AlreadyInitialized", Documentation: []Text{" Members are already initialized!"}}, ErrorMetadataV8{Name: "TooEarly", Documentation: []Text{" The close call was made too early, before the end of the voting."}}, ErrorMetadataV8{Name: "TooManyProposals", Documentation: []Text{" There can only be a maximum of `MaxProposals` active proposals."}}, ErrorMetadataV8{Name: "WrongProposalWeight", Documentation: []Text{" The given weight bound for the proposal was too low."}}, ErrorMetadataV8{Name: "WrongProposalLength", Documentation: []Text{" The given length bound for the proposal was too low."}}}}, ModuleMetadataV10{Name: "TechnicalCommittee", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Instance2Collective", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Proposals", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::Hash>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The hashes of the active proposals."}}, StorageFunctionMetadataV10{Name: "ProposalOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "T::Hash", Value: "<T as Trait<I>>::Proposal", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Actual proposal for a given hash, if it's current."}}, StorageFunctionMetadataV10{Name: "Voting", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "T::Hash", Value: "Votes<T::AccountId, T::BlockNumber>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Votes on a given proposal, if it is ongoing."}}, StorageFunctionMetadataV10{Name: "ProposalCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Proposals so far."}}, StorageFunctionMetadataV10{Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current members of the collective. This is stored sorted (just by value)."}}, StorageFunctionMetadataV10{Name: "Prime", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The member who provides the default vote for any other members that do not vote before", " the timeout. If None, then no member has that privilege."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "set_members", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new_members", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "prime", Type: "Option<T::AccountId>"}, FunctionArgumentMetadata{Name: "old_count", Type: "MemberCount"}}, Documentation: []Text{" Set the collective's membership.", "", " - `new_members`: The new member list. Be nice to the chain and provide it sorted.", " - `prime`: The prime member whose vote sets the default.", " - `old_count`: The upper bound for the previous number of members in storage.", "                Used for weight estimation.", "", " Requires root origin.", "", " NOTE: Does not enforce the expected `MAX_MEMBERS` limit on the amount of members, but", "       the weight estimations rely on it to estimate dispatchable weight.", "", " # <weight>", " ## Weight", " - `O(MP + N)` where:", "   - `M` old-members-count (code- and governance-bounded)", "   - `N` new-members-count (code- and governance-bounded)", "   - `P` proposals-count (code-bounded)", " - DB:", "   - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members", "   - 1 storage read (codec `O(P)`) for reading the proposals", "   - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal", "   - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one", " # </weight>"}}, FunctionMetadataV4{Name: "execute", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal", Type: "Box<<T as Trait<I>>::Proposal>"}, FunctionArgumentMetadata{Name: "length_bound", Type: "Compact<u32>"}}, Documentation: []Text{" Dispatch a proposal from a member using the `Member` origin.", "", " Origin must be a member of the collective.", "", " # <weight>", " ## Weight", " - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`", " - DB: 1 read (codec `O(M)`) + DB access of `proposal`", " - 1 event", " # </weight>"}}, FunctionMetadataV4{Name: "propose", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "threshold", Type: "Compact<MemberCount>"}, FunctionArgumentMetadata{Name: "proposal", Type: "Box<<T as Trait<I>>::Proposal>"}, FunctionArgumentMetadata{Name: "length_bound", Type: "Compact<u32>"}}, Documentation: []Text{" Add a new proposal to either be voted on or executed directly.", "", " Requires the sender to be member.", "", " `threshold` determines whether `proposal` is executed directly (`threshold < 2`)", " or put up for voting.", "", " # <weight>", " ## Weight", " - `O(B + M + P1)` or `O(B + M + P2)` where:", "   - `B` is `proposal` size in bytes (length-fee-bounded)", "   - `M` is members-count (code- and governance-bounded)", "   - branching is influenced by `threshold` where:", "     - `P1` is proposal execution complexity (`threshold < 2`)", "     - `P2` is proposals-count (code-bounded) (`threshold >= 2`)", " - DB:", "   - 1 storage read `is_member` (codec `O(M)`)", "   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)", "   - DB accesses influenced by `threshold`:", "     - EITHER storage accesses done by `proposal` (`threshold < 2`)", "     - OR proposal insertion (`threshold <= 2`)", "       - 1 storage mutation `Proposals` (codec `O(P2)`)", "       - 1 storage mutation `ProposalCount` (codec `O(1)`)", "       - 1 storage write `ProposalOf` (codec `O(B)`)", "       - 1 storage write `Voting` (codec `O(M)`)", "   - 1 event", " # </weight>"}}, FunctionMetadataV4{Name: "vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "index", Type: "Compact<ProposalIndex>"}, FunctionArgumentMetadata{Name: "approve", Type: "bool"}}, Documentation: []Text{" Add an aye or nay vote for the sender to the given proposal.", "", " Requires the sender to be a member.", "", " # <weight>", " ## Weight", " - `O(M)` where `M` is members-count (code- and governance-bounded)", " - DB:", "   - 1 storage read `Members` (codec `O(M)`)", "   - 1 storage mutation `Voting` (codec `O(M)`)", " - 1 event", " # </weight>"}}, FunctionMetadataV4{Name: "close", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "index", Type: "Compact<ProposalIndex>"}, FunctionArgumentMetadata{Name: "proposal_weight_bound", Type: "Compact<Weight>"}, FunctionArgumentMetadata{Name: "length_bound", Type: "Compact<u32>"}}, Documentation: []Text{" Close a vote that is either approved, disapproved or whose voting period has ended.", "", " May be called by any signed account in order to finish voting and close the proposal.", "", " If called before the end of the voting period it will only close the vote if it is", " has enough votes to be approved or disapproved.", "", " If called after the end of the voting period abstentions are counted as rejections", " unless there is a prime member set and the prime member cast an approval.", "", " + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.", " + `length_bound`: The upper bound for the length of the proposal in storage. Checked via", "                   `storage::read` so it is `size_of::<u32>() == 4` larger than the pure length.", "", " # <weight>", " ## Weight", " - `O(B + M + P1 + P2)` where:", "   - `B` is `proposal` size in bytes (length-fee-bounded)", "   - `M` is members-count (code- and governance-bounded)", "   - `P1` is the complexity of `proposal` preimage.", "   - `P2` is proposal-count (code-bounded)", " - DB:", "  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)", "  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)", "  - any mutations done while executing `proposal` (`P1`)", " - up to 3 events", " # </weight>"}}, FunctionMetadataV4{Name: "disapprove_proposal", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_hash", Type: "T::Hash"}}, Documentation: []Text{" Disapprove a proposal, close, and remove it from the system, regardless of its current state.", "", " Must be called by the Root origin.", "", " Parameters:", " * `proposal_hash`: The hash of the proposal that should be disapproved.", "", " # <weight>", " Complexity: O(P) where P is the number of max proposals", " Base Weight: .49 * P", " DB Weight:", " * Reads: Proposals", " * Writes: Voting, Proposals, ProposalOf", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Proposed", Args: []Type{"AccountId", "ProposalIndex", "Hash", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been proposed (by given account) with a threshold (given", " `MemberCount`).", " [account, proposal_index, proposal_hash, threshold]"}}, EventMetadataV4{Name: "Voted", Args: []Type{"AccountId", "Hash", "bool", "MemberCount", "MemberCount"}, Documentation: []Text{" A motion (given hash) has been voted on by given account, leaving", " a tally (yes votes and no votes given respectively as `MemberCount`).", " [account, proposal_hash, voted, yes, no]"}}, EventMetadataV4{Name: "Approved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was approved by the required threshold.", " [proposal_hash]"}}, EventMetadataV4{Name: "Disapproved", Args: []Type{"Hash"}, Documentation: []Text{" A motion was not approved by the required threshold.", " [proposal_hash]"}}, EventMetadataV4{Name: "Executed", Args: []Type{"Hash", "DispatchResult"}, Documentation: []Text{" A motion was executed; result will be `Ok` if it returned without error.", " [proposal_hash, result]"}}, EventMetadataV4{Name: "MemberExecuted", Args: []Type{"Hash", "DispatchResult"}, Documentation: []Text{" A single member did some action; result will be `Ok` if it returned without error.", " [proposal_hash, result]"}}, EventMetadataV4{Name: "Closed", Args: []Type{"Hash", "MemberCount", "MemberCount"}, Documentation: []Text{" A proposal was closed because its threshold was reached or after its duration was up.", " [proposal_hash, yes, no]"}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "NotMember", Documentation: []Text{" Account is not a member"}}, ErrorMetadataV8{Name: "DuplicateProposal", Documentation: []Text{" Duplicate proposals not allowed"}}, ErrorMetadataV8{Name: "ProposalMissing", Documentation: []Text{" Proposal must exist"}}, ErrorMetadataV8{Name: "WrongIndex", Documentation: []Text{" Mismatched index"}}, ErrorMetadataV8{Name: "DuplicateVote", Documentation: []Text{" Duplicate vote ignored"}}, ErrorMetadataV8{Name: "AlreadyInitialized", Documentation: []Text{" Members are already initialized!"}}, ErrorMetadataV8{Name: "TooEarly", Documentation: []Text{" The close call was made too early, before the end of the voting."}}, ErrorMetadataV8{Name: "TooManyProposals", Documentation: []Text{" There can only be a maximum of `MaxProposals` active proposals."}}, ErrorMetadataV8{Name: "WrongProposalWeight", Documentation: []Text{" The given weight bound for the proposal was too low."}}, ErrorMetadataV8{Name: "WrongProposalLength", Documentation: []Text{" The given length bound for the proposal was too low."}}}}, ModuleMetadataV10{Name: "Elections", HasStorage: true, Storage: StorageMetadataV10{Prefix: "PhragmenElection", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<(T::AccountId, BalanceOf<T>)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current elected membership. Sorted based on account id."}}, StorageFunctionMetadataV10{Name: "RunnersUp", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<(T::AccountId, BalanceOf<T>)>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current runners_up. Sorted based on low to high merit (worse to best runner)."}}, StorageFunctionMetadataV10{Name: "ElectionRounds", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The total number of vote rounds that have happened, excluding the upcoming one."}}, StorageFunctionMetadataV10{Name: "Voting", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "(BalanceOf<T>, Vec<T::AccountId>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Votes and locked stake of a particular voter.", "", " TWOX-NOTE: SAFE as `AccountId` is a crypto hash"}}, StorageFunctionMetadataV10{Name: "Candidates", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The present candidate list. Sorted based on account-id. A current member or runner-up", " can never enter this vector and is always implicitly assumed to be a candidate."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "votes", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Vote for a set of candidates for the upcoming round of election. This can be called to", " set the initial votes, or update already existing votes.", "", " Upon initial voting, `value` units of `who`'s balance is locked and a bond amount is", " reserved.", "", " The `votes` should:", "   - not be empty.", "   - be less than the number of possible candidates. Note that all current members and", "     runners-up are also automatically candidates for the next round.", "", " It is the responsibility of the caller to not place all of their balance into the lock", " and keep some for further transactions.", "", " # <weight>", " Base weight: 47.93 µs", " State reads:", " \t- Candidates.len() + Members.len() + RunnersUp.len()", " \t- Voting (is_voter)", " \t- [AccountBalance(who) (unreserve + total_balance)]", " State writes:", " \t- Voting", " \t- Lock", " \t- [AccountBalance(who) (unreserve -- only when creating a new voter)]", " # </weight>"}}, FunctionMetadataV4{Name: "remove_voter", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Remove `origin` as a voter. This removes the lock and returns the bond.", "", " # <weight>", " Base weight: 36.8 µs", " All state access is from do_remove_voter.", " State reads:", " \t- Voting", " \t- [AccountData(who)]", " State writes:", " \t- Voting", " \t- Locks", " \t- [AccountData(who)]", " # </weight>"}}, FunctionMetadataV4{Name: "report_defunct_voter", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "defunct", Type: "DefunctVoter<<T::Lookup as StaticLookup>::Source>"}}, Documentation: []Text{" Report `target` for being an defunct voter. In case of a valid report, the reporter is", " rewarded by the bond amount of `target`. Otherwise, the reporter itself is removed and", " their bond is slashed.", "", " A defunct voter is defined to be:", "   - a voter whose current submitted votes are all invalid. i.e. all of them are no", "     longer a candidate nor an active member or a runner-up.", "", "", " The origin must provide the number of current candidates and votes of the reported target", " for the purpose of accurate weight calculation.", "", " # <weight>", " No Base weight based on min square analysis.", " Complexity of candidate_count: 1.755 µs", " Complexity of vote_count: 18.51 µs", " State reads:", "  \t- Voting(reporter)", "  \t- Candidate.len()", "  \t- Voting(Target)", "  \t- Candidates, Members, RunnersUp (is_defunct_voter)", " State writes:", " \t- Lock(reporter || target)", " \t- [AccountBalance(reporter)] + AccountBalance(target)", " \t- Voting(reporter || target)", " Note: the db access is worse with respect to db, which is when the report is correct.", " # </weight>"}}, FunctionMetadataV4{Name: "submit_candidacy", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "candidate_count", Type: "Compact<u32>"}}, Documentation: []Text{" Submit oneself for candidacy.", "", " A candidate will either:", "   - Lose at the end of the term and forfeit their deposit.", "   - Win and become a member. Members will eventually get their stash back.", "   - Become a runner-up. Runners-ups are reserved members in case one gets forcefully", "     removed.", "", " # <weight>", " Base weight = 33.33 µs", " Complexity of candidate_count: 0.375 µs", " State reads:", " \t- Candidates.len()", " \t- Candidates", " \t- Members", " \t- RunnersUp", " \t- [AccountBalance(who)]", " State writes:", " \t- [AccountBalance(who)]", " \t- Candidates", " # </weight>"}}, FunctionMetadataV4{Name: "renounce_candidacy", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "renouncing", Type: "Renouncing"}}, Documentation: []Text{" Renounce one's intention to be a candidate for the next election round. 3 potential", " outcomes exist:", " - `origin` is a candidate and not elected in any set. In this case, the bond is", "   unreserved, returned and origin is removed as a candidate.", " - `origin` is a current runner-up. In this case, the bond is unreserved, returned and", "   origin is removed as a runner-up.", " - `origin` is a current member. In this case, the bond is unreserved and origin is", "   removed as a member, consequently not being a candidate for the next round anymore.", "   Similar to [`remove_voter`], if replacement runners exists, they are immediately used.", " <weight>", " If a candidate is renouncing:", " \tBase weight: 17.28 µs", " \tComplexity of candidate_count: 0.235 µs", " \tState reads:", " \t\t- Candidates", " \t\t- [AccountBalance(who) (unreserve)]", " \tState writes:", " \t\t- Candidates", " \t\t- [AccountBalance(who) (unreserve)]", " If member is renouncing:", " \tBase weight: 46.25 µs", " \tState reads:", " \t\t- Members, RunnersUp (remove_and_replace_member),", " \t\t- [AccountData(who) (unreserve)]", " \tState writes:", " \t\t- Members, RunnersUp (remove_and_replace_member),", " \t\t- [AccountData(who) (unreserve)]", " If runner is renouncing:", " \tBase weight: 46.25 µs", " \tState reads:", " \t\t- RunnersUp (remove_and_replace_member),", " \t\t- [AccountData(who) (unreserve)]", " \tState writes:", " \t\t- RunnersUp (remove_and_replace_member),", " \t\t- [AccountData(who) (unreserve)]", "", " Weight note: The call into changeMembers need to be accounted for.", " </weight>"}}, FunctionMetadataV4{Name: "remove_member", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "has_replacement", Type: "bool"}}, Documentation: []Text{" Remove a particular member from the set. This is effective immediately and the bond of", " the outgoing member is slashed.", "", " If a runner-up is available, then the best runner-up will be removed and replaces the", " outgoing member. Otherwise, a new phragmen election is started.", "", " Note that this does not affect the designated block number of the next election.", "", " # <weight>", " If we have a replacement:", " \t- Base weight: 50.93 µs", " \t- State reads:", " \t\t- RunnersUp.len()", " \t\t- Members, RunnersUp (remove_and_replace_member)", " \t- State writes:", " \t\t- Members, RunnersUp (remove_and_replace_member)", " Else, since this is a root call and will go into phragmen, we assume full block for now.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "NewTerm", Args: []Type{"Vec<(AccountId, Balance)>"}, Documentation: []Text{" A new term with [new_members]. This indicates that enough candidates existed to run the", " election, not that enough have has been elected. The inner value must be examined for", " this purpose. A `NewTerm([])` indicates that some candidates got their bond slashed and", " none were elected, whilst `EmptyTerm` means that no candidates existed to begin with."}}, EventMetadataV4{Name: "EmptyTerm", Args: []Type(nil), Documentation: []Text{" No (or not enough) candidates existed for this round. This is different from", " `NewTerm([])`. See the description of `NewTerm`."}}, EventMetadataV4{Name: "MemberKicked", Args: []Type{"AccountId"}, Documentation: []Text{" A [member] has been removed. This should always be followed by either `NewTerm` ot", " `EmptyTerm`."}}, EventMetadataV4{Name: "MemberRenounced", Args: []Type{"AccountId"}, Documentation: []Text{" A [member] has renounced their candidacy."}}, EventMetadataV4{Name: "VoterReported", Args: []Type{"AccountId", "AccountId", "bool"}, Documentation: []Text{" A voter was reported with the the report being successful or not.", " [voter, reporter, success]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "CandidacyBond", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x80, 0xc6, 0xa4, 0x7e, 0x8d, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text(nil)}, ModuleConstantMetadataV6{Name: "VotingBond", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text(nil)}, ModuleConstantMetadataV6{Name: "DesiredMembers", Type: "u32", Value: Bytes{0xd, 0x0, 0x0, 0x0}, Documentation: []Text(nil)}, ModuleConstantMetadataV6{Name: "DesiredRunnersUp", Type: "u32", Value: Bytes{0x7, 0x0, 0x0, 0x0}, Documentation: []Text(nil)}, ModuleConstantMetadataV6{Name: "TermDuration", Type: "T::BlockNumber", Value: Bytes{0x80, 0x13, 0x3, 0x0}, Documentation: []Text(nil)}, ModuleConstantMetadataV6{Name: "ModuleId", Type: "LockIdentifier", Value: Bytes{0x70, 0x68, 0x72, 0x65, 0x6c, 0x65, 0x63, 0x74}, Documentation: []Text(nil)}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "UnableToVote", Documentation: []Text{" Cannot vote when no candidates or members exist."}}, ErrorMetadataV8{Name: "NoVotes", Documentation: []Text{" Must vote for at least one candidate."}}, ErrorMetadataV8{Name: "TooManyVotes", Documentation: []Text{" Cannot vote more than candidates."}}, ErrorMetadataV8{Name: "MaximumVotesExceeded", Documentation: []Text{" Cannot vote more than maximum allowed."}}, ErrorMetadataV8{Name: "LowBalance", Documentation: []Text{" Cannot vote with stake less than minimum balance."}}, ErrorMetadataV8{Name: "UnableToPayBond", Documentation: []Text{" Voter can not pay voting bond."}}, ErrorMetadataV8{Name: "MustBeVoter", Documentation: []Text{" Must be a voter."}}, ErrorMetadataV8{Name: "ReportSelf", Documentation: []Text{" Cannot report self."}}, ErrorMetadataV8{Name: "DuplicatedCandidate", Documentation: []Text{" Duplicated candidate submission."}}, ErrorMetadataV8{Name: "MemberSubmit", Documentation: []Text{" Member cannot re-submit candidacy."}}, ErrorMetadataV8{Name: "RunnerSubmit", Documentation: []Text{" Runner cannot re-submit candidacy."}}, ErrorMetadataV8{Name: "InsufficientCandidateFunds", Documentation: []Text{" Candidate does not have enough funds."}}, ErrorMetadataV8{Name: "NotMember", Documentation: []Text{" Not a member."}}, ErrorMetadataV8{Name: "InvalidCandidateCount", Documentation: []Text{" The provided count of number of candidates is incorrect."}}, ErrorMetadataV8{Name: "InvalidVoteCount", Documentation: []Text{" The provided count of number of votes is incorrect."}}, ErrorMetadataV8{Name: "InvalidRenouncing", Documentation: []Text{" The renouncing origin presented a wrong `Renouncing` parameter."}}, ErrorMetadataV8{Name: "InvalidReplacement", Documentation: []Text{" Prediction regarding replacement after member removal is wrong."}}}}, ModuleMetadataV10{Name: "TechnicalMembership", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Instance1Membership", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current membership, stored as an ordered Vec."}}, StorageFunctionMetadataV10{Name: "Prime", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current prime member, if one exists."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "add_member", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}}, Documentation: []Text{" Add a member `who` to the set.", "", " May only be called from `T::AddOrigin`."}}, FunctionMetadataV4{Name: "remove_member", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}}, Documentation: []Text{" Remove a member `who` from the set.", "", " May only be called from `T::RemoveOrigin`."}}, FunctionMetadataV4{Name: "swap_member", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "remove", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "add", Type: "T::AccountId"}}, Documentation: []Text{" Swap out one member `remove` for another `add`.", "", " May only be called from `T::SwapOrigin`.", "", " Prime membership is *not* passed from `remove` to `add`, if extant."}}, FunctionMetadataV4{Name: "reset_members", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "members", Type: "Vec<T::AccountId>"}}, Documentation: []Text{" Change the membership to a new set, disregarding the existing membership. Be nice and", " pass `members` pre-sorted.", "", " May only be called from `T::ResetOrigin`."}}, FunctionMetadataV4{Name: "change_key", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new", Type: "T::AccountId"}}, Documentation: []Text{" Swap out the sending member for some other key `new`.", "", " May only be called from `Signed` origin of a current member.", "", " Prime membership is passed from the origin account to `new`, if extant."}}, FunctionMetadataV4{Name: "set_prime", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}}, Documentation: []Text{" Set the prime member. Must be a current member.", "", " May only be called from `T::PrimeOrigin`."}}, FunctionMetadataV4{Name: "clear_prime", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Remove the prime member if it exists.", "", " May only be called from `T::PrimeOrigin`."}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "MemberAdded", Args: []Type(nil), Documentation: []Text{" The given member was added; see the transaction for who."}}, EventMetadataV4{Name: "MemberRemoved", Args: []Type(nil), Documentation: []Text{" The given member was removed; see the transaction for who."}}, EventMetadataV4{Name: "MembersSwapped", Args: []Type(nil), Documentation: []Text{" Two members were swapped; see the transaction for who."}}, EventMetadataV4{Name: "MembersReset", Args: []Type(nil), Documentation: []Text{" The membership was reset; see the transaction for who the new set is."}}, EventMetadataV4{Name: "KeyChanged", Args: []Type(nil), Documentation: []Text{" One of the members' keys changed."}}, EventMetadataV4{Name: "Dummy", Args: []Type{"sp_std::marker::PhantomData<(AccountId, Event)>"}, Documentation: []Text{" Phantom member, never used."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, ModuleMetadataV10{Name: "FinalityTracker", HasStorage: false, Storage: StorageMetadataV10{Prefix: "", Items: []StorageFunctionMetadataV10(nil)}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "final_hint", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "hint", Type: "Compact<T::BlockNumber>"}}, Documentation: []Text{" Hint that the author of this block thinks the best finalized", " block is the given number."}}}, HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "WindowSize", Type: "T::BlockNumber", Value: Bytes{0x65, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of recent samples to keep from this chain. Default is 101."}}, ModuleConstantMetadataV6{Name: "ReportLatency", Type: "T::BlockNumber", Value: Bytes{0xe8, 0x3, 0x0, 0x0}, Documentation: []Text{" The delay after which point things become suspicious. Default is 1000."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "AlreadyUpdated", Documentation: []Text{" Final hint must be updated only once in the block"}}, ErrorMetadataV8{Name: "BadHint", Documentation: []Text{" Finalized height above block number"}}}}, ModuleMetadataV10{Name: "Grandpa", HasStorage: true, Storage: StorageMetadataV10{Prefix: "GrandpaFinality", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "State", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "StoredState<T::BlockNumber>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" State of the current authority set."}}, StorageFunctionMetadataV10{Name: "PendingChange", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "StoredPendingChange<T::BlockNumber>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Pending change: (signaled at, scheduled change)."}}, StorageFunctionMetadataV10{Name: "NextForced", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" next block number where we can force a change."}}, StorageFunctionMetadataV10{Name: "Stalled", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "(T::BlockNumber, T::BlockNumber)", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" `true` if we are currently stalled."}}, StorageFunctionMetadataV10{Name: "CurrentSetId", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "SetId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of changes (both in terms of keys and underlying economic responsibilities)", " in the \"set\" of Grandpa validators from genesis."}}, StorageFunctionMetadataV10{Name: "SetIdSession", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "SetId", Value: "SessionIndex", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping from grandpa set ID to the index of the *most recent* session for which its", " members were responsible.", "", " TWOX-NOTE: `SetId` is not under user control."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "report_equivocation", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "equivocation_proof", Type: "EquivocationProof<T::Hash, T::BlockNumber>"}, FunctionArgumentMetadata{Name: "key_owner_proof", Type: "T::KeyOwnerProof"}}, Documentation: []Text{" Report voter equivocation/misbehavior. This method will verify the", " equivocation proof and validate the given key ownership proof", " against the extracted offender. If both are valid, the offence", " will be reported."}}, FunctionMetadataV4{Name: "report_equivocation_unsigned", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "equivocation_proof", Type: "EquivocationProof<T::Hash, T::BlockNumber>"}, FunctionArgumentMetadata{Name: "key_owner_proof", Type: "T::KeyOwnerProof"}}, Documentation: []Text{" Report voter equivocation/misbehavior. This method will verify the", " equivocation proof and validate the given key ownership proof", " against the extracted offender. If both are valid, the offence", " will be reported.", "", " This extrinsic must be called unsigned and it is expected that only", " block authors will call it (validated in `ValidateUnsigned`), as such", " if the block author is defined it will be defined as the equivocation", " reporter."}}, FunctionMetadataV4{Name: "note_stalled", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "delay", Type: "T::BlockNumber"}, FunctionArgumentMetadata{Name: "best_finalized_block_number", Type: "T::BlockNumber"}}, Documentation: []Text{" Note that the current authority set of the GRANDPA finality gadget has", " stalled. This will trigger a forced authority set change at the beginning", " of the next session, to be enacted `delay` blocks after that. The delay", " should be high enough to safely assume that the block signalling the", " forced change will not be re-orged (e.g. 1000 blocks). The GRANDPA voters", " will start the new authority set using the given finalized block as base.", " Only callable by root."}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "NewAuthorities", Args: []Type{"AuthorityList"}, Documentation: []Text{" New authority set has been applied. [authority_set]"}}, EventMetadataV4{Name: "Paused", Args: []Type(nil), Documentation: []Text{" Current authority set has been paused."}}, EventMetadataV4{Name: "Resumed", Args: []Type(nil), Documentation: []Text{" Current authority set has been resumed."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "PauseFailed", Documentation: []Text{" Attempt to signal GRANDPA pause when the authority set isn't live", " (either paused or already pending pause)."}}, ErrorMetadataV8{Name: "ResumeFailed", Documentation: []Text{" Attempt to signal GRANDPA resume when the authority set isn't paused", " (either live or already pending resume)."}}, ErrorMetadataV8{Name: "ChangePending", Documentation: []Text{" Attempt to signal GRANDPA change with one already pending."}}, ErrorMetadataV8{Name: "TooSoon", Documentation: []Text{" Cannot signal forced change so soon after last."}}, ErrorMetadataV8{Name: "InvalidKeyOwnershipProof", Documentation: []Text{" A key ownership proof provided as part of an equivocation report is invalid."}}, ErrorMetadataV8{Name: "InvalidEquivocationProof", Documentation: []Text{" An equivocation proof provided as part of an equivocation report is invalid."}}, ErrorMetadataV8{Name: "DuplicateOffenceReport", Documentation: []Text{" A given equivocation report is valid but already previously reported."}}}}, ModuleMetadataV10{Name: "Treasury", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Treasury", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "ProposalCount", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "ProposalIndex", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of proposals that have been made."}}, StorageFunctionMetadataV10{Name: "Proposals", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "ProposalIndex", Value: "Proposal<T::AccountId, BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Proposals that have been made."}}, StorageFunctionMetadataV10{Name: "Approvals", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<ProposalIndex>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Proposal indices that have been approved but not yet awarded."}}, StorageFunctionMetadataV10{Name: "Tips", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::Hash", Value: "OpenTip<T::AccountId, BalanceOf<T>, T::BlockNumber, T::Hash>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Tips that are not yet completed. Keyed by the hash of `(reason, who)` from the value.", " This has the insecure enumerable hash function since the key itself is already", " guaranteed to be a secure hash."}}, StorageFunctionMetadataV10{Name: "Reasons", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "T::Hash", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Simple preimage lookup from the reason's hash to the original data. Again, has an", " insecure enumerable hash since the key is guaranteed to be the result of a secure hash."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "propose_spend", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}, FunctionArgumentMetadata{Name: "beneficiary", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Put forward a suggestion for spending. A deposit proportional to the value", " is reserved and slashed if the proposal is rejected. It is returned once the", " proposal is awarded.", "", " # <weight>", " - Complexity: O(1)", " - DbReads: `ProposalCount`, `origin account`", " - DbWrites: `ProposalCount`, `Proposals`, `origin account`", " # </weight>"}}, FunctionMetadataV4{Name: "reject_proposal", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_id", Type: "Compact<ProposalIndex>"}}, Documentation: []Text{" Reject a proposed spend. The original deposit will be slashed.", "", " May only be called from `T::RejectOrigin`.", "", " # <weight>", " - Complexity: O(1)", " - DbReads: `Proposals`, `rejected proposer account`", " - DbWrites: `Proposals`, `rejected proposer account`", " # </weight>"}}, FunctionMetadataV4{Name: "approve_proposal", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proposal_id", Type: "Compact<ProposalIndex>"}}, Documentation: []Text{" Approve a proposal. At a later time, the proposal will be allocated to the beneficiary", " and the original deposit will be returned.", "", " May only be called from `T::ApproveOrigin`.", "", " # <weight>", " - Complexity: O(1).", " - DbReads: `Proposals`, `Approvals`", " - DbWrite: `Approvals`", " # </weight>"}}, FunctionMetadataV4{Name: "report_awesome", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "reason", Type: "Vec<u8>"}, FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}}, Documentation: []Text{" Report something `reason` that deserves a tip and claim any eventual the finder's fee.", "", " The dispatch origin for this call must be _Signed_.", "", " Payment: `TipReportDepositBase` will be reserved from the origin account, as well as", " `TipReportDepositPerByte` for each byte in `reason`.", "", " - `reason`: The reason for, or the thing that deserves, the tip; generally this will be", "   a UTF-8-encoded URL.", " - `who`: The account which should be credited for the tip.", "", " Emits `NewTip` if successful.", "", " # <weight>", " - Complexity: `O(R)` where `R` length of `reason`.", "   - encoding and hashing of 'reason'", " - DbReads: `Reasons`, `Tips`, `who account data`", " - DbWrites: `Tips`, `who account data`", " # </weight>"}}, FunctionMetadataV4{Name: "retract_tip", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "hash", Type: "T::Hash"}}, Documentation: []Text{" Retract a prior tip-report from `report_awesome`, and cancel the process of tipping.", "", " If successful, the original deposit will be unreserved.", "", " The dispatch origin for this call must be _Signed_ and the tip identified by `hash`", " must have been reported by the signing account through `report_awesome` (and not", " through `tip_new`).", "", " - `hash`: The identity of the open tip for which a tip value is declared. This is formed", "   as the hash of the tuple of the original tip `reason` and the beneficiary account ID.", "", " Emits `TipRetracted` if successful.", "", " # <weight>", " - Complexity: `O(1)`", "   - Depends on the length of `T::Hash` which is fixed.", " - DbReads: `Tips`, `origin account`", " - DbWrites: `Reasons`, `Tips`, `origin account`", " # </weight>"}}, FunctionMetadataV4{Name: "tip_new", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "reason", Type: "Vec<u8>"}, FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "tip_value", Type: "BalanceOf<T>"}}, Documentation: []Text{" Give a tip for something new; no finder's fee will be taken.", "", " The dispatch origin for this call must be _Signed_ and the signing account must be a", " member of the `Tippers` set.", "", " - `reason`: The reason for, or the thing that deserves, the tip; generally this will be", "   a UTF-8-encoded URL.", " - `who`: The account which should be credited for the tip.", " - `tip_value`: The amount of tip that the sender would like to give. The median tip", "   value of active tippers will be given to the `who`.", "", " Emits `NewTip` if successful.", "", " # <weight>", " - Complexity: `O(R + T)` where `R` length of `reason`, `T` is the number of tippers.", "   - `O(T)`: decoding `Tipper` vec of length `T`", "     `T` is charged as upper bound given by `ContainsLengthBound`.", "     The actual cost depends on the implementation of `T::Tippers`.", "   - `O(R)`: hashing and encoding of reason of length `R`", " - DbReads: `Tippers`, `Reasons`", " - DbWrites: `Reasons`, `Tips`", " # </weight>"}}, FunctionMetadataV4{Name: "tip", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "hash", Type: "T::Hash"}, FunctionArgumentMetadata{Name: "tip_value", Type: "BalanceOf<T>"}}, Documentation: []Text{" Declare a tip value for an already-open tip.", "", " The dispatch origin for this call must be _Signed_ and the signing account must be a", " member of the `Tippers` set.", "", " - `hash`: The identity of the open tip for which a tip value is declared. This is formed", "   as the hash of the tuple of the hash of the original tip `reason` and the beneficiary", "   account ID.", " - `tip_value`: The amount of tip that the sender would like to give. The median tip", "   value of active tippers will be given to the `who`.", "", " Emits `TipClosing` if the threshold of tippers has been reached and the countdown period", " has started.", "", " # <weight>", " - Complexity: `O(T)` where `T` is the number of tippers.", "   decoding `Tipper` vec of length `T`, insert tip and check closing,", "   `T` is charged as upper bound given by `ContainsLengthBound`.", "   The actual cost depends on the implementation of `T::Tippers`.", "", "   Actually weight could be lower as it depends on how many tips are in `OpenTip` but it", "   is weighted as if almost full i.e of length `T-1`.", " - DbReads: `Tippers`, `Tips`", " - DbWrites: `Tips`", " # </weight>"}}, FunctionMetadataV4{Name: "close_tip", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "hash", Type: "T::Hash"}}, Documentation: []Text{" Close and payout a tip.", "", " The dispatch origin for this call must be _Signed_.", "", " The tip identified by `hash` must have finished its countdown period.", "", " - `hash`: The identity of the open tip for which a tip value is declared. This is formed", "   as the hash of the tuple of the original tip `reason` and the beneficiary account ID.", "", " # <weight>", " - Complexity: `O(T)` where `T` is the number of tippers.", "   decoding `Tipper` vec of length `T`.", "   `T` is charged as upper bound given by `ContainsLengthBound`.", "   The actual cost depends on the implementation of `T::Tippers`.", " - DbReads: `Tips`, `Tippers`, `tip finder`", " - DbWrites: `Reasons`, `Tips`, `Tippers`, `tip finder`", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Proposed", Args: []Type{"ProposalIndex"}, Documentation: []Text{" New proposal. [proposal_index]"}}, EventMetadataV4{Name: "Spending", Args: []Type{"Balance"}, Documentation: []Text{" We have ended a spend period and will now allocate funds. [budget_remaining]"}}, EventMetadataV4{Name: "Awarded", Args: []Type{"ProposalIndex", "Balance", "AccountId"}, Documentation: []Text{" Some funds have been allocated. [proposal_index, award, beneficiary]"}}, EventMetadataV4{Name: "Rejected", Args: []Type{"ProposalIndex", "Balance"}, Documentation: []Text{" A proposal was rejected; funds were slashed. [proposal_index, slashed]"}}, EventMetadataV4{Name: "Burnt", Args: []Type{"Balance"}, Documentation: []Text{" Some of our funds have been burnt. [burn]"}}, EventMetadataV4{Name: "Rollover", Args: []Type{"Balance"}, Documentation: []Text{" Spending has finished; this is the amount that rolls over until next spend. [budget_remaining]"}}, EventMetadataV4{Name: "Deposit", Args: []Type{"Balance"}, Documentation: []Text{" Some funds have been deposited. [deposit]"}}, EventMetadataV4{Name: "NewTip", Args: []Type{"Hash"}, Documentation: []Text{" A new tip suggestion has been opened. [tip_hash]"}}, EventMetadataV4{Name: "TipClosing", Args: []Type{"Hash"}, Documentation: []Text{" A tip suggestion has reached threshold and is closing. [tip_hash]"}}, EventMetadataV4{Name: "TipClosed", Args: []Type{"Hash", "AccountId", "Balance"}, Documentation: []Text{" A tip suggestion has been closed. [tip_hash, who, payout]"}}, EventMetadataV4{Name: "TipRetracted", Args: []Type{"Hash"}, Documentation: []Text{" A tip suggestion has been retracted. [tip_hash]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "ProposalBond", Type: "Permill", Value: Bytes{0x50, 0xc3, 0x0, 0x0}, Documentation: []Text{" Fraction of a proposal's value that should be bonded in order to place the proposal.", " An accepted proposal gets these back. A rejected proposal does not."}}, ModuleConstantMetadataV6{Name: "ProposalBondMinimum", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Minimum amount of funds that should be placed in a deposit for making a proposal."}}, ModuleConstantMetadataV6{Name: "SpendPeriod", Type: "T::BlockNumber", Value: Bytes{0x80, 0x70, 0x0, 0x0}, Documentation: []Text{" Period between successive spends."}}, ModuleConstantMetadataV6{Name: "Burn", Type: "Permill", Value: Bytes{0x20, 0xa1, 0x7, 0x0}, Documentation: []Text{" Percentage of spare funds (if any) that are burnt per spend period."}}, ModuleConstantMetadataV6{Name: "TipCountdown", Type: "T::BlockNumber", Value: Bytes{0x80, 0x70, 0x0, 0x0}, Documentation: []Text{" The period for which a tip remains open after is has achieved threshold tippers."}}, ModuleConstantMetadataV6{Name: "TipFindersFee", Type: "Percent", Value: Bytes{0x14}, Documentation: []Text{" The amount of the final tip which goes to the original reporter of the tip."}}, ModuleConstantMetadataV6{Name: "TipReportDepositBase", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x7a, 0x10, 0xf3, 0x5a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount held on deposit for placing a tip report."}}, ModuleConstantMetadataV6{Name: "TipReportDepositPerByte", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount held on deposit per byte within the tip report reason."}}, ModuleConstantMetadataV6{Name: "ModuleId", Type: "ModuleId", Value: Bytes{0x70, 0x79, 0x2f, 0x74, 0x72, 0x73, 0x72, 0x79}, Documentation: []Text{" The treasury's module id, used for deriving its sovereign account ID."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InsufficientProposersBalance", Documentation: []Text{" Proposer's balance is too low."}}, ErrorMetadataV8{Name: "InvalidProposalIndex", Documentation: []Text{" No proposal at that index."}}, ErrorMetadataV8{Name: "ReasonTooBig", Documentation: []Text{" The reason given is just too big."}}, ErrorMetadataV8{Name: "AlreadyKnown", Documentation: []Text{" The tip was already found/started."}}, ErrorMetadataV8{Name: "UnknownTip", Documentation: []Text{" The tip hash is unknown."}}, ErrorMetadataV8{Name: "NotFinder", Documentation: []Text{" The account attempting to retract the tip is not the finder of the tip."}}, ErrorMetadataV8{Name: "StillOpen", Documentation: []Text{" The tip cannot be claimed/closed because there are not enough tippers yet."}}, ErrorMetadataV8{Name: "Premature", Documentation: []Text{" The tip cannot be claimed/closed because it's still in the countdown period."}}}}, ModuleMetadataV10{Name: "Contracts", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Contracts", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "CurrentSchedule", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Schedule", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x20, 0xa1, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0xa1, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0xa1, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0xa1, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0xa1, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0xa1, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0xa1, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe0, 0xf7, 0x5, 0x4, 0x0, 0x0, 0x0, 0x0, 0xe0, 0x24, 0x37, 0x5, 0x0, 0x0, 0x0, 0x0, 0xe0, 0xf7, 0x5, 0x4, 0x0, 0x0, 0x0, 0x0, 0x20, 0xa1, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0xa1, 0x7, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80, 0xf0, 0xfa, 0x2, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe1, 0xf5, 0x5, 0x0, 0x0, 0x0, 0x0, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x40, 0x0, 0x0, 0x0, 0x20, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x0}, Documentation: []Text{" Current cost schedule for contracts."}}, StorageFunctionMetadataV10{Name: "PristineCode", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "CodeHash<T>", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping from an original code hash to the original code, untouched by instrumentation."}}, StorageFunctionMetadataV10{Name: "CodeStorage", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "CodeHash<T>", Value: "wasm::PrefabWasmModule", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A mapping between an original code hash and instrumented wasm code, ready for execution."}}, StorageFunctionMetadataV10{Name: "AccountCounter", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u64", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The subtrie counter."}}, StorageFunctionMetadataV10{Name: "ContractInfoOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "ContractInfo<T>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The code associated with a given account.", "", " TWOX-NOTE: SAFE since `AccountId` is a secure hash."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "update_schedule", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "schedule", Type: "Schedule"}}, Documentation: []Text{" Updates the schedule for metering contracts.", "", " The schedule must have a greater version than the stored schedule."}}, FunctionMetadataV4{Name: "put_code", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "code", Type: "Vec<u8>"}}, Documentation: []Text{" Stores the given binary Wasm code into the chain's storage and returns its `codehash`.", " You can instantiate contracts only with stored code."}}, FunctionMetadataV4{Name: "call", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "dest", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "value", Type: "Compact<BalanceOf<T>>"}, FunctionArgumentMetadata{Name: "gas_limit", Type: "Compact<Gas>"}, FunctionArgumentMetadata{Name: "data", Type: "Vec<u8>"}}, Documentation: []Text{" Makes a call to an account, optionally transferring some balance.", "", " * If the account is a smart-contract account, the associated code will be", " executed and any value will be transferred.", " * If the account is a regular account, any value will be transferred.", " * If no account exists and the call value is not less than `existential_deposit`,", " a regular account will be created and any value will be transferred."}}, FunctionMetadataV4{Name: "instantiate", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "endowment", Type: "Compact<BalanceOf<T>>"}, FunctionArgumentMetadata{Name: "gas_limit", Type: "Compact<Gas>"}, FunctionArgumentMetadata{Name: "code_hash", Type: "CodeHash<T>"}, FunctionArgumentMetadata{Name: "data", Type: "Vec<u8>"}}, Documentation: []Text{" Instantiates a new contract from the `codehash` generated by `put_code`, optionally transferring some balance.", "", " Instantiation is executed as follows:", "", " - The destination address is computed based on the sender and hash of the code.", " - The smart-contract account is created at the computed address.", " - The `ctor_code` is executed in the context of the newly-created account. Buffer returned", "   after the execution is saved as the `code` of the account. That code will be invoked", "   upon any call received by this account.", " - The contract is initialized."}}, FunctionMetadataV4{Name: "claim_surcharge", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "dest", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "aux_sender", Type: "Option<T::AccountId>"}}, Documentation: []Text{" Allows block producers to claim a small reward for evicting a contract. If a block producer", " fails to do so, a regular users will be allowed to claim the reward.", "", " If contract is not evicted as a result of this call, no actions are taken and", " the sender is not eligible for the reward."}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Instantiated", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" Contract deployed by address at the specified address. [owner, contract]"}}, EventMetadataV4{Name: "Evicted", Args: []Type{"AccountId", "bool"}, Documentation: []Text{" Contract has been evicted and is now in tombstone state.", " [contract, tombstone]", " ", " # Params", "", " - `contract`: `AccountId`: The account ID of the evicted contract.", " - `tombstone`: `bool`: True if the evicted contract left behind a tombstone."}}, EventMetadataV4{Name: "Restored", Args: []Type{"AccountId", "AccountId", "Hash", "Balance"}, Documentation: []Text{" Restoration for a contract has been successful.", " [donor, dest, code_hash, rent_allowance]", " ", " # Params", "", " - `donor`: `AccountId`: Account ID of the restoring contract", " - `dest`: `AccountId`: Account ID of the restored contract", " - `code_hash`: `Hash`: Code hash of the restored contract", " - `rent_allowance: `Balance`: Rent allowance of the restored contract"}}, EventMetadataV4{Name: "CodeStored", Args: []Type{"Hash"}, Documentation: []Text{" Code with the specified hash has been stored.", " [code_hash]"}}, EventMetadataV4{Name: "ScheduleUpdated", Args: []Type{"u32"}, Documentation: []Text{" Triggered when the current [schedule] is updated."}}, EventMetadataV4{Name: "ContractExecution", Args: []Type{"AccountId", "Vec<u8>"}, Documentation: []Text{" An event deposited upon execution of a contract from the account.", " [account, data]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "SignedClaimHandicap", Type: "T::BlockNumber", Value: Bytes{0x2, 0x0, 0x0, 0x0}, Documentation: []Text{" Number of block delay an extrinsic claim surcharge has.", "", " When claim surcharge is called by an extrinsic the rent is checked", " for current_block - delay"}}, ModuleConstantMetadataV6{Name: "TombstoneDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0xa0, 0xac, 0xb9, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount required to generate a tombstone."}}, ModuleConstantMetadataV6{Name: "StorageSizeOffset", Type: "u32", Value: Bytes{0x8, 0x0, 0x0, 0x0}, Documentation: []Text{" A size offset for an contract. A just created account with untouched storage will have that", " much of storage from the perspective of the state rent.", "", " This is a simple way to ensure that contracts with empty storage eventually get deleted", " by making them pay rent. This creates an incentive to remove them early in order to save", " rent."}}, ModuleConstantMetadataV6{Name: "RentByteFee", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x28, 0x6b, 0xee, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Price of a byte of storage per one block interval. Should be greater than 0."}}, ModuleConstantMetadataV6{Name: "RentDepositOffset", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x10, 0xa5, 0xd4, 0xe8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of funds a contract should deposit in order to offset", " the cost of one byte.", "", " Let's suppose the deposit is 1,000 BU (balance units)/byte and the rent is 1 BU/byte/day,", " then a contract with 1,000,000 BU that uses 1,000 bytes of storage would pay no rent.", " But if the balance reduced to 500,000 BU and the storage stayed the same at 1,000,", " then it would pay 500 BU/day."}}, ModuleConstantMetadataV6{Name: "SurchargeReward", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x5c, 0xb2, 0xec, 0x22, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Reward that is received by the party whose touch has led", " to removal of a contract."}}, ModuleConstantMetadataV6{Name: "MaxDepth", Type: "u32", Value: Bytes{0x20, 0x0, 0x0, 0x0}, Documentation: []Text{" The maximum nesting level of a call/instantiate stack. A reasonable default", " value is 100."}}, ModuleConstantMetadataV6{Name: "MaxValueSize", Type: "u32", Value: Bytes{0x0, 0x40, 0x0, 0x0}, Documentation: []Text{" The maximum size of a storage value in bytes. A reasonable default is 16 KiB."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InvalidScheduleVersion", Documentation: []Text{" A new schedule must have a greater version than the current one."}}, ErrorMetadataV8{Name: "InvalidSurchargeClaim", Documentation: []Text{" An origin must be signed or inherent and auxiliary sender only provided on inherent."}}, ErrorMetadataV8{Name: "InvalidSourceContract", Documentation: []Text{" Cannot restore from nonexisting or tombstone contract."}}, ErrorMetadataV8{Name: "InvalidDestinationContract", Documentation: []Text{" Cannot restore to nonexisting or alive contract."}}, ErrorMetadataV8{Name: "InvalidTombstone", Documentation: []Text{" Tombstones don't match."}}, ErrorMetadataV8{Name: "InvalidContractOrigin", Documentation: []Text{" An origin TrieId written in the current block."}}, ErrorMetadataV8{Name: "OutOfGas", Documentation: []Text{" The executed contract exhausted its gas limit."}}, ErrorMetadataV8{Name: "OutputBufferTooSmall", Documentation: []Text{" The output buffer supplied to a contract API call was too small."}}, ErrorMetadataV8{Name: "BelowSubsistenceThreshold", Documentation: []Text{" Performing the requested transfer would have brought the contract below", " the subsistence threshold. No transfer is allowed to do this in order to allow", " for a tombstone to be created. Use `seal_terminate` to remove a contract without", " leaving a tombstone behind."}}, ErrorMetadataV8{Name: "NewContractNotFunded", Documentation: []Text{" The newly created contract is below the subsistence threshold after executing", " its contructor. No contracts are allowed to exist below that threshold."}}, ErrorMetadataV8{Name: "TransferFailed", Documentation: []Text{" Performing the requested transfer failed for a reason originating in the", " chosen currency implementation of the runtime. Most probably the balance is", " too low or locks are placed on it."}}, ErrorMetadataV8{Name: "MaxCallDepthReached", Documentation: []Text{" Performing a call was denied because the calling depth reached the limit", " of what is specified in the schedule."}}, ErrorMetadataV8{Name: "NotCallable", Documentation: []Text{" The contract that was called is either no contract at all (a plain account)", " or is a tombstone."}}, ErrorMetadataV8{Name: "CodeTooLarge", Documentation: []Text{" The code supplied to `put_code` exceeds the limit specified in the current schedule."}}, ErrorMetadataV8{Name: "CodeNotFound", Documentation: []Text{" No code could be found at the supplied code hash."}}, ErrorMetadataV8{Name: "OutOfBounds", Documentation: []Text{" A buffer outside of sandbox memory was passed to a contract API function."}}, ErrorMetadataV8{Name: "DecodingFailed", Documentation: []Text{" Input passed to a contract API function failed to decode as expected type."}}, ErrorMetadataV8{Name: "ContractTrapped", Documentation: []Text{" Contract trapped during execution."}}}}, ModuleMetadataV10{Name: "Sudo", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Sudo", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Key", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The `AccountId` of the sudo key."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "sudo", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Trait>::Call>"}}, Documentation: []Text{" Authenticates the sudo key and dispatches a function call with `Root` origin.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB write (event).", " - Weight of derivative `call` execution + 10,000.", " # </weight>"}}, FunctionMetadataV4{Name: "sudo_unchecked_weight", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Trait>::Call>"}, FunctionArgumentMetadata{Name: "_weight", Type: "Weight"}}, Documentation: []Text{" Authenticates the sudo key and dispatches a function call with `Root` origin.", " This function does not check the weight of the call, and instead allows the", " Sudo user to specify the weight of the call.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - O(1).", " - The weight of this call is defined by the caller.", " # </weight>"}}, FunctionMetadataV4{Name: "set_key", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "new", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB change.", " # </weight>"}}, FunctionMetadataV4{Name: "sudo_as", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Trait>::Call>"}}, Documentation: []Text{" Authenticates the sudo key and dispatches a function call with `Signed` origin from", " a given account.", "", " The dispatch origin for this call must be _Signed_.", "", " # <weight>", " - O(1).", " - Limited storage reads.", " - One DB write (event).", " - Weight of derivative `call` execution + 10,000.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Sudid", Args: []Type{"DispatchResult"}, Documentation: []Text{" A sudo just took place. [result]"}}, EventMetadataV4{Name: "KeyChanged", Args: []Type{"AccountId"}, Documentation: []Text{" The [sudoer] just switched identity; the old key is supplied."}}, EventMetadataV4{Name: "SudoAsDone", Args: []Type{"bool"}, Documentation: []Text{" A sudo just took place. [result]"}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "RequireSudo", Documentation: []Text{" Sender must be the Sudo account"}}}}, ModuleMetadataV10{Name: "ImOnline", HasStorage: true, Storage: StorageMetadataV10{Prefix: "ImOnline", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "HeartbeatAfter", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::BlockNumber", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The block number after which it's ok to send heartbeats in current session.", "", " At the beginning of each session we set this to a value that should", " fall roughly in the middle of the session duration.", " The idea is to first wait for the validators to produce a block", " in the current session, so that the heartbeat later on will not be necessary."}}, StorageFunctionMetadataV10{Name: "Keys", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::AuthorityId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current set of keys that may issue a heartbeat."}}, StorageFunctionMetadataV10{Name: "ReceivedHeartbeats", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "SessionIndex", Key2: "AuthIndex", Value: "Vec<u8>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" For each session index, we keep a mapping of `AuthIndex` to", " `offchain::OpaqueNetworkState`."}}, StorageFunctionMetadataV10{Name: "AuthoredBlocks", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "SessionIndex", Key2: "T::ValidatorId", Value: "u32", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" For each session index, we keep a mapping of `T::ValidatorId` to the", " number of blocks authored by the given authority."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "heartbeat", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "heartbeat", Type: "Heartbeat<T::BlockNumber>"}, FunctionArgumentMetadata{Name: "_signature", Type: "<T::AuthorityId as RuntimeAppPublic>::Signature"}}, Documentation: []Text{" # <weight>", " - Complexity: `O(K + E)` where K is length of `Keys` and E is length of", "   `Heartbeat.network_state.external_address`", "", "   - `O(K)`: decoding of length `K`", "   - `O(E)`: decoding/encoding of length `E`", " - DbReads: pallet_session `Validators`, pallet_session `CurrentIndex`, `Keys`,", "   `ReceivedHeartbeats`", " - DbWrites: `ReceivedHeartbeats`", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "HeartbeatReceived", Args: []Type{"AuthorityId"}, Documentation: []Text{" A new heartbeat was received from `AuthorityId` [authority_id]"}}, EventMetadataV4{Name: "AllGood", Args: []Type(nil), Documentation: []Text{" At the end of the session, no offence was committed."}}, EventMetadataV4{Name: "SomeOffline", Args: []Type{"Vec<IdentificationTuple>"}, Documentation: []Text{" At the end of the session, at least one validator was found to be [offline]."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "InvalidKey", Documentation: []Text{" Non existent public key."}}, ErrorMetadataV8{Name: "DuplicatedHeartbeat", Documentation: []Text{" Duplicated heartbeat."}}}}, ModuleMetadataV10{Name: "AuthorityDiscovery", HasStorage: false, Storage: StorageMetadataV10{Prefix: "", Items: []StorageFunctionMetadataV10(nil)}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, ModuleMetadataV10{Name: "Offences", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Offences", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Reports", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "ReportIdOf<T>", Value: "OffenceDetails<T::AccountId, T::IdentificationTuple>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The primary structure that holds all offence records keyed by report identifiers."}}, StorageFunctionMetadataV10{Name: "DeferredOffences", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<DeferredOffenceOf<T>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Deferred reports that have been rejected by the offence handler and need to be submitted", " at a later time."}}, StorageFunctionMetadataV10{Name: "ConcurrentReportsIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "Kind", Key2: "OpaqueTimeSlot", Value: "Vec<ReportIdOf<T>>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A vector of reports of the same kind that happened at the same time slot."}}, StorageFunctionMetadataV10{Name: "ReportsByKindIndex", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "Kind", Value: "Vec<u8>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Enumerates all reports of a kind along with the time they happened.", "", " All reports are sorted by the time of offence.", "", " Note that the actual type of this mapping is `Vec<u8>`, this is because values of", " different types are not supported at the moment so we are doing the manual serialization."}}}}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Offence", Args: []Type{"Kind", "OpaqueTimeSlot", "bool"}, Documentation: []Text{" There is an offence reported of the given `kind` happened at the `session_index` and", " (kind-specific) time slot. This event is not deposited for duplicate slashes. last", " element indicates of the offence was applied (true) or queued (false) ", " [kind, timeslot, applied]."}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, ModuleMetadataV10{Name: "Historical", HasStorage: false, Storage: StorageMetadataV10{Prefix: "", Items: []StorageFunctionMetadataV10(nil)}, HasCalls: false, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, ModuleMetadataV10{Name: "RandomnessCollectiveFlip", HasStorage: true, Storage: StorageMetadataV10{Prefix: "RandomnessCollectiveFlip", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "RandomMaterial", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::Hash>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Series of block headers from the last 81 blocks that acts as random seed material. This", " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of", " the oldest hash."}}}}, HasCalls: true, Calls: []FunctionMetadataV4(nil), HasEvents: false, Events: []EventMetadataV4(nil), Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8(nil)}, ModuleMetadataV10{Name: "Identity", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Identity", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "IdentityOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "Registration<BalanceOf<T>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Information that is pertinent to identify the entity behind an account.", "", " TWOX-NOTE: OK ― `AccountId` is a secure hash."}}, StorageFunctionMetadataV10{Name: "SuperOf", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::AccountId", Value: "(T::AccountId, Data)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The super-identity of an alternative \"sub\" identity together with its name, within that", " context. If the account is not some other account's sub-identity, then just `None`."}}, StorageFunctionMetadataV10{Name: "SubsOf", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "(BalanceOf<T>, Vec<T::AccountId>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Alternative \"sub\" identities of this account.", "", " The first item is the deposit, the second is a vector of the accounts.", "", " TWOX-NOTE: OK ― `AccountId` is a secure hash."}}, StorageFunctionMetadataV10{Name: "Registrars", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<Option<RegistrarInfo<BalanceOf<T>, T::AccountId>>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The set of registrars. Not expected to get very big as can only be added through a", " special origin (likely a council motion).", "", " The index into this can be cast to `RegistrarIndex` to get a valid value."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "add_registrar", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "account", Type: "T::AccountId"}}, Documentation: []Text{" Add a registrar to the system.", "", " The dispatch origin for this call must be `T::RegistrarOrigin`.", "", " - `account`: the account of the registrar.", "", " Emits `RegistrarAdded` if successful.", "", " # <weight>", " - `O(R)` where `R` registrar-count (governance-bounded and code-bounded).", " - One storage mutation (codec `O(R)`).", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "set_identity", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "info", Type: "IdentityInfo"}}, Documentation: []Text{" Set an account's identity information and reserve the appropriate deposit.", "", " If the account already has identity information, the deposit is taken as part payment", " for the new deposit.", "", " The dispatch origin for this call must be _Signed_.", "", " - `info`: The identity information.", "", " Emits `IdentitySet` if successful.", "", " # <weight>", " - `O(X + X' + R)`", "   - where `X` additional-field-count (deposit-bounded and code-bounded)", "   - where `R` judgements-count (registrar-count-bounded)", " - One balance reserve operation.", " - One storage mutation (codec-read `O(X' + R)`, codec-write `O(X + R)`).", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "set_subs", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "subs", Type: "Vec<(T::AccountId, Data)>"}}, Documentation: []Text{" Set the sub-accounts of the sender.", "", " Payment: Any aggregate balance reserved by previous `set_subs` calls will be returned", " and an amount `SubAccountDeposit` will be reserved for each item in `subs`.", "", " The dispatch origin for this call must be _Signed_ and the sender must have a registered", " identity.", "", " - `subs`: The identity's (new) sub-accounts.", "", " # <weight>", " - `O(P + S)`", "   - where `P` old-subs-count (hard- and deposit-bounded).", "   - where `S` subs-count (hard- and deposit-bounded).", " - At most one balance operations.", " - DB:", "   - `P + S` storage mutations (codec complexity `O(1)`)", "   - One storage read (codec complexity `O(P)`).", "   - One storage write (codec complexity `O(S)`).", "   - One storage-exists (`IdentityOf::contains_key`).", " # </weight>"}}, FunctionMetadataV4{Name: "clear_identity", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Clear an account's identity info and all sub-accounts and return all deposits.", "", " Payment: All reserved balances on the account are returned.", "", " The dispatch origin for this call must be _Signed_ and the sender must have a registered", " identity.", "", " Emits `IdentityCleared` if successful.", "", " # <weight>", " - `O(R + S + X)`", "   - where `R` registrar-count (governance-bounded).", "   - where `S` subs-count (hard- and deposit-bounded).", "   - where `X` additional-field-count (deposit-bounded and code-bounded).", " - One balance-unreserve operation.", " - `2` storage reads and `S + 2` storage deletions.", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "request_judgement", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "reg_index", Type: "Compact<RegistrarIndex>"}, FunctionArgumentMetadata{Name: "max_fee", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Request a judgement from a registrar.", "", " Payment: At most `max_fee` will be reserved for payment to the registrar if judgement", " given.", "", " The dispatch origin for this call must be _Signed_ and the sender must have a", " registered identity.", "", " - `reg_index`: The index of the registrar whose judgement is requested.", " - `max_fee`: The maximum fee that may be paid. This should just be auto-populated as:", "", " ```nocompile", " Self::registrars().get(reg_index).unwrap().fee", " ```", "", " Emits `JudgementRequested` if successful.", "", " # <weight>", " - `O(R + X)`.", " - One balance-reserve operation.", " - Storage: 1 read `O(R)`, 1 mutate `O(X + R)`.", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "cancel_request", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "reg_index", Type: "RegistrarIndex"}}, Documentation: []Text{" Cancel a previous request.", "", " Payment: A previously reserved deposit is returned on success.", "", " The dispatch origin for this call must be _Signed_ and the sender must have a", " registered identity.", "", " - `reg_index`: The index of the registrar whose judgement is no longer requested.", "", " Emits `JudgementUnrequested` if successful.", "", " # <weight>", " - `O(R + X)`.", " - One balance-reserve operation.", " - One storage mutation `O(R + X)`.", " - One event", " # </weight>"}}, FunctionMetadataV4{Name: "set_fee", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "Compact<RegistrarIndex>"}, FunctionArgumentMetadata{Name: "fee", Type: "Compact<BalanceOf<T>>"}}, Documentation: []Text{" Set the fee required for a judgement to be requested from a registrar.", "", " The dispatch origin for this call must be _Signed_ and the sender must be the account", " of the registrar whose index is `index`.", "", " - `index`: the index of the registrar whose fee is to be set.", " - `fee`: the new fee.", "", " # <weight>", " - `O(R)`.", " - One storage mutation `O(R)`.", " - Benchmark: 7.315 + R * 0.329 µs (min squares analysis)", " # </weight>"}}, FunctionMetadataV4{Name: "set_account_id", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "Compact<RegistrarIndex>"}, FunctionArgumentMetadata{Name: "new", Type: "T::AccountId"}}, Documentation: []Text{" Change the account associated with a registrar.", "", " The dispatch origin for this call must be _Signed_ and the sender must be the account", " of the registrar whose index is `index`.", "", " - `index`: the index of the registrar whose fee is to be set.", " - `new`: the new account ID.", "", " # <weight>", " - `O(R)`.", " - One storage mutation `O(R)`.", " - Benchmark: 8.823 + R * 0.32 µs (min squares analysis)", " # </weight>"}}, FunctionMetadataV4{Name: "set_fields", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "index", Type: "Compact<RegistrarIndex>"}, FunctionArgumentMetadata{Name: "fields", Type: "IdentityFields"}}, Documentation: []Text{" Set the field information for a registrar.", "", " The dispatch origin for this call must be _Signed_ and the sender must be the account", " of the registrar whose index is `index`.", "", " - `index`: the index of the registrar whose fee is to be set.", " - `fields`: the fields that the registrar concerns themselves with.", "", " # <weight>", " - `O(R)`.", " - One storage mutation `O(R)`.", " - Benchmark: 7.464 + R * 0.325 µs (min squares analysis)", " # </weight>"}}, FunctionMetadataV4{Name: "provide_judgement", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "reg_index", Type: "Compact<RegistrarIndex>"}, FunctionArgumentMetadata{Name: "target", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "judgement", Type: "Judgement<BalanceOf<T>>"}}, Documentation: []Text{" Provide a judgement for an account's identity.", "", " The dispatch origin for this call must be _Signed_ and the sender must be the account", " of the registrar whose index is `reg_index`.", "", " - `reg_index`: the index of the registrar whose judgement is being made.", " - `target`: the account whose identity the judgement is upon. This must be an account", "   with a registered identity.", " - `judgement`: the judgement of the registrar of index `reg_index` about `target`.", "", " Emits `JudgementGiven` if successful.", "", " # <weight>", " - `O(R + X)`.", " - One balance-transfer operation.", " - Up to one account-lookup operation.", " - Storage: 1 read `O(R)`, 1 mutate `O(R + X)`.", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "kill_identity", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "target", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Remove an account's identity and sub-account information and slash the deposits.", "", " Payment: Reserved balances from `set_subs` and `set_identity` are slashed and handled by", " `Slash`. Verification request deposits are not returned; they should be cancelled", " manually using `cancel_request`.", "", " The dispatch origin for this call must match `T::ForceOrigin`.", "", " - `target`: the account whose identity the judgement is upon. This must be an account", "   with a registered identity.", "", " Emits `IdentityKilled` if successful.", "", " # <weight>", " - `O(R + S + X)`.", " - One balance-reserve operation.", " - `S + 2` storage mutations.", " - One event.", " # </weight>"}}, FunctionMetadataV4{Name: "add_sub", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "sub", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "data", Type: "Data"}}, Documentation: []Text{" Add the given account to the sender's subs.", "", " Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated", " to the sender.", "", " The dispatch origin for this call must be _Signed_ and the sender must have a registered", " sub identity of `sub`."}}, FunctionMetadataV4{Name: "rename_sub", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "sub", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "data", Type: "Data"}}, Documentation: []Text{" Alter the associated name of the given sub-account.", "", " The dispatch origin for this call must be _Signed_ and the sender must have a registered", " sub identity of `sub`."}}, FunctionMetadataV4{Name: "remove_sub", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "sub", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Remove the given account from the sender's subs.", "", " Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated", " to the sender.", "", " The dispatch origin for this call must be _Signed_ and the sender must have a registered", " sub identity of `sub`."}}, FunctionMetadataV4{Name: "quit_sub", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Remove the sender as a sub-account.", "", " Payment: Balance reserved by a previous `set_subs` call for one sub will be repatriated", " to the sender (*not* the original depositor).", "", " The dispatch origin for this call must be _Signed_ and the sender must have a registered", " super-identity.", "", " NOTE: This should not normally be used, but is provided in the case that the non-", " controller of an account is maliciously registered as a sub-account."}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "IdentitySet", Args: []Type{"AccountId"}, Documentation: []Text{" A name was set or reset (which will remove all judgements). [who]"}}, EventMetadataV4{Name: "IdentityCleared", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" A name was cleared, and the given balance returned. [who, deposit]"}}, EventMetadataV4{Name: "IdentityKilled", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" A name was removed and the given balance slashed. [who, deposit]"}}, EventMetadataV4{Name: "JudgementRequested", Args: []Type{"AccountId", "RegistrarIndex"}, Documentation: []Text{" A judgement was asked from a registrar. [who, registrar_index]"}}, EventMetadataV4{Name: "JudgementUnrequested", Args: []Type{"AccountId", "RegistrarIndex"}, Documentation: []Text{" A judgement request was retracted. [who, registrar_index]"}}, EventMetadataV4{Name: "JudgementGiven", Args: []Type{"AccountId", "RegistrarIndex"}, Documentation: []Text{" A judgement was given by a registrar. [target, registrar_index]"}}, EventMetadataV4{Name: "RegistrarAdded", Args: []Type{"RegistrarIndex"}, Documentation: []Text{" A registrar was added. [registrar_index]"}}, EventMetadataV4{Name: "SubIdentityAdded", Args: []Type{"AccountId", "AccountId", "Balance"}, Documentation: []Text{" A sub-identity was added to an identity and the deposit paid. [sub, main, deposit]"}}, EventMetadataV4{Name: "SubIdentityRemoved", Args: []Type{"AccountId", "AccountId", "Balance"}, Documentation: []Text{" A sub-identity was removed from an identity and the deposit freed.", " [sub, main, deposit]"}}, EventMetadataV4{Name: "SubIdentityRevoked", Args: []Type{"AccountId", "AccountId", "Balance"}, Documentation: []Text{" A sub-identity was cleared, and the given deposit repatriated from the", " main identity account to the sub-identity account. [sub, main, deposit]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "BasicDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x80, 0xc6, 0xa4, 0x7e, 0x8d, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount held on deposit for a registered identity."}}, ModuleConstantMetadataV6{Name: "FieldDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0xa0, 0x31, 0xa9, 0x5f, 0xe3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount held on deposit per additional field for a registered identity."}}, ModuleConstantMetadataV6{Name: "SubAccountDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x80, 0xf4, 0x20, 0xe6, 0xb5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount held on deposit for a registered subaccount. This should account for the fact", " that one storage item's value will increase by the size of an account ID, and there will be", " another trie item whose value is the size of an account ID plus 32 bytes."}}, ModuleConstantMetadataV6{Name: "MaxSubAccounts", Type: "u32", Value: Bytes{0x64, 0x0, 0x0, 0x0}, Documentation: []Text{" The maximum number of sub-accounts allowed per identified account."}}, ModuleConstantMetadataV6{Name: "MaxAdditionalFields", Type: "u32", Value: Bytes{0x64, 0x0, 0x0, 0x0}, Documentation: []Text{" Maximum number of additional fields that may be stored in an ID. Needed to bound the I/O", " required to access an identity, but can be pretty high."}}, ModuleConstantMetadataV6{Name: "MaxRegistrars", Type: "u32", Value: Bytes{0x14, 0x0, 0x0, 0x0}, Documentation: []Text{" Maxmimum number of registrars allowed in the system. Needed to bound the complexity", " of, e.g., updating judgements."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "TooManySubAccounts", Documentation: []Text{" Too many subs-accounts."}}, ErrorMetadataV8{Name: "NotFound", Documentation: []Text{" Account isn't found."}}, ErrorMetadataV8{Name: "NotNamed", Documentation: []Text{" Account isn't named."}}, ErrorMetadataV8{Name: "EmptyIndex", Documentation: []Text{" Empty index."}}, ErrorMetadataV8{Name: "FeeChanged", Documentation: []Text{" Fee is changed."}}, ErrorMetadataV8{Name: "NoIdentity", Documentation: []Text{" No identity found."}}, ErrorMetadataV8{Name: "StickyJudgement", Documentation: []Text{" Sticky judgement."}}, ErrorMetadataV8{Name: "JudgementGiven", Documentation: []Text{" Judgement given."}}, ErrorMetadataV8{Name: "InvalidJudgement", Documentation: []Text{" Invalid judgement."}}, ErrorMetadataV8{Name: "InvalidIndex", Documentation: []Text{" The index is invalid."}}, ErrorMetadataV8{Name: "InvalidTarget", Documentation: []Text{" The target is invalid."}}, ErrorMetadataV8{Name: "TooManyFields", Documentation: []Text{" Too many additional fields."}}, ErrorMetadataV8{Name: "TooManyRegistrars", Documentation: []Text{" Maximum amount of registrars reached. Cannot add any more."}}, ErrorMetadataV8{Name: "AlreadyClaimed", Documentation: []Text{" Account ID is already named."}}, ErrorMetadataV8{Name: "NotSub", Documentation: []Text{" Sender is not a sub-account."}}, ErrorMetadataV8{Name: "NotOwned", Documentation: []Text{" Sub-account isn't owned by sender."}}}}, ModuleMetadataV10{Name: "Society", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Society", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Founder", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The first member."}}, StorageFunctionMetadataV10{Name: "Rules", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::Hash", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" A hash of the rules of this society concerning membership. Can only be set once and", " only by the founder."}}, StorageFunctionMetadataV10{Name: "Candidates", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<Bid<T::AccountId, BalanceOf<T, I>>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current set of candidates; bidders that are attempting to become members."}}, StorageFunctionMetadataV10{Name: "SuspendedCandidates", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "(BalanceOf<T, I>, BidKind<T::AccountId, BalanceOf<T, I>>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The set of suspended candidates."}}, StorageFunctionMetadataV10{Name: "Pot", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "BalanceOf<T, I>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" Amount of our account balance that is specifically for the next round's bid(s)."}}, StorageFunctionMetadataV10{Name: "Head", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The most primary from the most recently approved members."}}, StorageFunctionMetadataV10{Name: "Members", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<T::AccountId>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current set of members, ordered."}}, StorageFunctionMetadataV10{Name: "SuspendedMembers", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "bool", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The set of suspended members."}}, StorageFunctionMetadataV10{Name: "Bids", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Vec<Bid<T::AccountId, BalanceOf<T, I>>>", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The current bids, stored ordered by the value of the bid."}}, StorageFunctionMetadataV10{Name: "Vouching", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "VouchingStatus", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Members currently vouching or banned from vouching again"}}, StorageFunctionMetadataV10{Name: "Payouts", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "Vec<(T::BlockNumber, BalanceOf<T, I>)>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Pending payouts; ordered by block number, with the amount that should be paid out."}}, StorageFunctionMetadataV10{Name: "Strikes", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "StrikeCount", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The ongoing number of losing votes cast by the member."}}, StorageFunctionMetadataV10{Name: "Votes", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "T::AccountId", Key2: "T::AccountId", Value: "Vote", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Double map from Candidate -> Voter -> (Maybe) Vote."}}, StorageFunctionMetadataV10{Name: "Defender", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "T::AccountId", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The defending member currently being challenged."}}, StorageFunctionMetadataV10{Name: "DefenderVotes", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "Vote", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Votes for the defender."}}, StorageFunctionMetadataV10{Name: "MaxMembers", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "u32", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The max number of members for the society at one time."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "bid", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "value", Type: "BalanceOf<T, I>"}}, Documentation: []Text{" A user outside of the society can make a bid for entry.", "", " Payment: `CandidateDeposit` will be reserved for making a bid. It is returned", " when the bid becomes a member, or if the bid calls `unbid`.", "", " The dispatch origin for this call must be _Signed_.", "", " Parameters:", " - `value`: A one time payment the bid would like to receive when joining the society.", "", " # <weight>", " Key: B (len of bids), C (len of candidates), M (len of members), X (balance reserve)", " - Storage Reads:", " \t- One storage read to check for suspended candidate. O(1)", " \t- One storage read to check for suspended member. O(1)", " \t- One storage read to retrieve all current bids. O(B)", " \t- One storage read to retrieve all current candidates. O(C)", " \t- One storage read to retrieve all members. O(M)", " - Storage Writes:", " \t- One storage mutate to add a new bid to the vector O(B) (TODO: possible optimization w/ read)", " \t- Up to one storage removal if bid.len() > MAX_BID_COUNT. O(1)", " - Notable Computation:", " \t- O(B + C + log M) search to check user is not already a part of society.", " \t- O(log B) search to insert the new bid sorted.", " - External Module Operations:", " \t- One balance reserve operation. O(X)", " \t- Up to one balance unreserve operation if bids.len() > MAX_BID_COUNT.", " - Events:", " \t- One event for new bid.", " \t- Up to one event for AutoUnbid if bid.len() > MAX_BID_COUNT.", "", " Total Complexity: O(M + B + C + logM + logB + X)", " # </weight>"}}, FunctionMetadataV4{Name: "unbid", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "pos", Type: "u32"}}, Documentation: []Text{" A bidder can remove their bid for entry into society.", " By doing so, they will have their candidate deposit returned or", " they will unvouch their voucher.", "", " Payment: The bid deposit is unreserved if the user made a bid.", "", " The dispatch origin for this call must be _Signed_ and a bidder.", "", " Parameters:", " - `pos`: Position in the `Bids` vector of the bid who wants to unbid.", "", " # <weight>", " Key: B (len of bids), X (balance unreserve)", " - One storage read and write to retrieve and update the bids. O(B)", " - Either one unreserve balance action O(X) or one vouching storage removal. O(1)", " - One event.", "", " Total Complexity: O(B + X)", " # </weight>"}}, FunctionMetadataV4{Name: "vouch", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "value", Type: "BalanceOf<T, I>"}, FunctionArgumentMetadata{Name: "tip", Type: "BalanceOf<T, I>"}}, Documentation: []Text{" As a member, vouch for someone to join society by placing a bid on their behalf.", "", " There is no deposit required to vouch for a new bid, but a member can only vouch for", " one bid at a time. If the bid becomes a suspended candidate and ultimately rejected by", " the suspension judgement origin, the member will be banned from vouching again.", "", " As a vouching member, you can claim a tip if the candidate is accepted. This tip will", " be paid as a portion of the reward the member will receive for joining the society.", "", " The dispatch origin for this call must be _Signed_ and a member.", "", " Parameters:", " - `who`: The user who you would like to vouch for.", " - `value`: The total reward to be paid between you and the candidate if they become", " a member in the society.", " - `tip`: Your cut of the total `value` payout when the candidate is inducted into", " the society. Tips larger than `value` will be saturated upon payout.", "", " # <weight>", " Key: B (len of bids), C (len of candidates), M (len of members)", " - Storage Reads:", " \t- One storage read to retrieve all members. O(M)", " \t- One storage read to check member is not already vouching. O(1)", " \t- One storage read to check for suspended candidate. O(1)", " \t- One storage read to check for suspended member. O(1)", " \t- One storage read to retrieve all current bids. O(B)", " \t- One storage read to retrieve all current candidates. O(C)", " - Storage Writes:", " \t- One storage write to insert vouching status to the member. O(1)", " \t- One storage mutate to add a new bid to the vector O(B) (TODO: possible optimization w/ read)", " \t- Up to one storage removal if bid.len() > MAX_BID_COUNT. O(1)", " - Notable Computation:", " \t- O(log M) search to check sender is a member.", " \t- O(B + C + log M) search to check user is not already a part of society.", " \t- O(log B) search to insert the new bid sorted.", " - External Module Operations:", " \t- One balance reserve operation. O(X)", " \t- Up to one balance unreserve operation if bids.len() > MAX_BID_COUNT.", " - Events:", " \t- One event for vouch.", " \t- Up to one event for AutoUnbid if bid.len() > MAX_BID_COUNT.", "", " Total Complexity: O(M + B + C + logM + logB + X)", " # </weight>"}}, FunctionMetadataV4{Name: "unvouch", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "pos", Type: "u32"}}, Documentation: []Text{" As a vouching member, unvouch a bid. This only works while vouched user is", " only a bidder (and not a candidate).", "", " The dispatch origin for this call must be _Signed_ and a vouching member.", "", " Parameters:", " - `pos`: Position in the `Bids` vector of the bid who should be unvouched.", "", " # <weight>", " Key: B (len of bids)", " - One storage read O(1) to check the signer is a vouching member.", " - One storage mutate to retrieve and update the bids. O(B)", " - One vouching storage removal. O(1)", " - One event.", "", " Total Complexity: O(B)", " # </weight>"}}, FunctionMetadataV4{Name: "vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "candidate", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "approve", Type: "bool"}}, Documentation: []Text{" As a member, vote on a candidate.", "", " The dispatch origin for this call must be _Signed_ and a member.", "", " Parameters:", " - `candidate`: The candidate that the member would like to bid on.", " - `approve`: A boolean which says if the candidate should be", "              approved (`true`) or rejected (`false`).", "", " # <weight>", " Key: C (len of candidates), M (len of members)", " - One storage read O(M) and O(log M) search to check user is a member.", " - One account lookup.", " - One storage read O(C) and O(C) search to check that user is a candidate.", " - One storage write to add vote to votes. O(1)", " - One event.", "", " Total Complexity: O(M + logM + C)", " # </weight>"}}, FunctionMetadataV4{Name: "defender_vote", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "approve", Type: "bool"}}, Documentation: []Text{" As a member, vote on the defender.", "", " The dispatch origin for this call must be _Signed_ and a member.", "", " Parameters:", " - `approve`: A boolean which says if the candidate should be", " approved (`true`) or rejected (`false`).", "", " # <weight>", " - Key: M (len of members)", " - One storage read O(M) and O(log M) search to check user is a member.", " - One storage write to add vote to votes. O(1)", " - One event.", "", " Total Complexity: O(M + logM)", " # </weight>"}}, FunctionMetadataV4{Name: "payout", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Transfer the first matured payout for the sender and remove it from the records.", "", " NOTE: This extrinsic needs to be called multiple times to claim multiple matured payouts.", "", " Payment: The member will receive a payment equal to their first matured", " payout to their free balance.", "", " The dispatch origin for this call must be _Signed_ and a member with", " payouts remaining.", "", " # <weight>", " Key: M (len of members), P (number of payouts for a particular member)", " - One storage read O(M) and O(log M) search to check signer is a member.", " - One storage read O(P) to get all payouts for a member.", " - One storage read O(1) to get the current block number.", " - One currency transfer call. O(X)", " - One storage write or removal to update the member's payouts. O(P)", "", " Total Complexity: O(M + logM + P + X)", " # </weight>"}}, FunctionMetadataV4{Name: "found", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "founder", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "max_members", Type: "u32"}, FunctionArgumentMetadata{Name: "rules", Type: "Vec<u8>"}}, Documentation: []Text{" Found the society.", "", " This is done as a discrete action in order to allow for the", " module to be included into a running chain and can only be done once.", "", " The dispatch origin for this call must be from the _FounderSetOrigin_.", "", " Parameters:", " - `founder` - The first member and head of the newly founded society.", " - `max_members` - The initial max number of members for the society.", " - `rules` - The rules of this society concerning membership.", "", " # <weight>", " - Two storage mutates to set `Head` and `Founder`. O(1)", " - One storage write to add the first member to society. O(1)", " - One event.", "", " Total Complexity: O(1)", " # </weight>"}}, FunctionMetadataV4{Name: "unfound", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Annul the founding of the society.", "", " The dispatch origin for this call must be Signed, and the signing account must be both", " the `Founder` and the `Head`. This implies that it may only be done when there is one", " member.", "", " # <weight>", " - Two storage reads O(1).", " - Four storage removals O(1).", " - One event.", "", " Total Complexity: O(1)", " # </weight>"}}, FunctionMetadataV4{Name: "judge_suspended_member", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "forgive", Type: "bool"}}, Documentation: []Text{" Allow suspension judgement origin to make judgement on a suspended member.", "", " If a suspended member is forgiven, we simply add them back as a member, not affecting", " any of the existing storage items for that member.", "", " If a suspended member is rejected, remove all associated storage items, including", " their payouts, and remove any vouched bids they currently have.", "", " The dispatch origin for this call must be from the _SuspensionJudgementOrigin_.", "", " Parameters:", " - `who` - The suspended member to be judged.", " - `forgive` - A boolean representing whether the suspension judgement origin", "               forgives (`true`) or rejects (`false`) a suspended member.", "", " # <weight>", " Key: B (len of bids), M (len of members)", " - One storage read to check `who` is a suspended member. O(1)", " - Up to one storage write O(M) with O(log M) binary search to add a member back to society.", " - Up to 3 storage removals O(1) to clean up a removed member.", " - Up to one storage write O(B) with O(B) search to remove vouched bid from bids.", " - Up to one additional event if unvouch takes place.", " - One storage removal. O(1)", " - One event for the judgement.", "", " Total Complexity: O(M + logM + B)", " # </weight>"}}, FunctionMetadataV4{Name: "judge_suspended_candidate", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "who", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "judgement", Type: "Judgement"}}, Documentation: []Text{" Allow suspended judgement origin to make judgement on a suspended candidate.", "", " If the judgement is `Approve`, we add them to society as a member with the appropriate", " payment for joining society.", "", " If the judgement is `Reject`, we either slash the deposit of the bid, giving it back", " to the society treasury, or we ban the voucher from vouching again.", "", " If the judgement is `Rebid`, we put the candidate back in the bid pool and let them go", " through the induction process again.", "", " The dispatch origin for this call must be from the _SuspensionJudgementOrigin_.", "", " Parameters:", " - `who` - The suspended candidate to be judged.", " - `judgement` - `Approve`, `Reject`, or `Rebid`.", "", " # <weight>", " Key: B (len of bids), M (len of members), X (balance action)", " - One storage read to check `who` is a suspended candidate.", " - One storage removal of the suspended candidate.", " - Approve Logic", " \t- One storage read to get the available pot to pay users with. O(1)", " \t- One storage write to update the available pot. O(1)", " \t- One storage read to get the current block number. O(1)", " \t- One storage read to get all members. O(M)", " \t- Up to one unreserve currency action.", " \t- Up to two new storage writes to payouts.", " \t- Up to one storage write with O(log M) binary search to add a member to society.", " - Reject Logic", " \t- Up to one repatriate reserved currency action. O(X)", " \t- Up to one storage write to ban the vouching member from vouching again.", " - Rebid Logic", " \t- Storage mutate with O(log B) binary search to place the user back into bids.", " - Up to one additional event if unvouch takes place.", " - One storage removal.", " - One event for the judgement.", "", " Total Complexity: O(M + logM + B + X)", " # </weight>"}}, FunctionMetadataV4{Name: "set_max_members", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "max", Type: "u32"}}, Documentation: []Text{" Allows root origin to change the maximum number of members in society.", " Max membership count must be greater than 1.", "", " The dispatch origin for this call must be from _ROOT_.", "", " Parameters:", " - `max` - The maximum number of members for the society.", "", " # <weight>", " - One storage write to update the max. O(1)", " - One event.", "", " Total Complexity: O(1)", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Founded", Args: []Type{"AccountId"}, Documentation: []Text{" The society is founded by the given identity. [founder]"}}, EventMetadataV4{Name: "Bid", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" A membership bid just happened. The given account is the candidate's ID and their offer", " is the second. [candidate_id, offer]"}}, EventMetadataV4{Name: "Vouch", Args: []Type{"AccountId", "Balance", "AccountId"}, Documentation: []Text{" A membership bid just happened by vouching. The given account is the candidate's ID and", " their offer is the second. The vouching party is the third. [candidate_id, offer, vouching]"}}, EventMetadataV4{Name: "AutoUnbid", Args: []Type{"AccountId"}, Documentation: []Text{" A [candidate] was dropped (due to an excess of bids in the system)."}}, EventMetadataV4{Name: "Unbid", Args: []Type{"AccountId"}, Documentation: []Text{" A [candidate] was dropped (by their request)."}}, EventMetadataV4{Name: "Unvouch", Args: []Type{"AccountId"}, Documentation: []Text{" A [candidate] was dropped (by request of who vouched for them)."}}, EventMetadataV4{Name: "Inducted", Args: []Type{"AccountId", "Vec<AccountId>"}, Documentation: []Text{" A group of candidates have been inducted. The batch's primary is the first value, the", " batch in full is the second. [primary, candidates]"}}, EventMetadataV4{Name: "SuspendedMemberJudgement", Args: []Type{"AccountId", "bool"}, Documentation: []Text{" A suspended member has been judged. [who, judged]"}}, EventMetadataV4{Name: "CandidateSuspended", Args: []Type{"AccountId"}, Documentation: []Text{" A [candidate] has been suspended"}}, EventMetadataV4{Name: "MemberSuspended", Args: []Type{"AccountId"}, Documentation: []Text{" A [member] has been suspended"}}, EventMetadataV4{Name: "Challenged", Args: []Type{"AccountId"}, Documentation: []Text{" A [member] has been challenged"}}, EventMetadataV4{Name: "Vote", Args: []Type{"AccountId", "AccountId", "bool"}, Documentation: []Text{" A vote has been placed [candidate, voter, vote]"}}, EventMetadataV4{Name: "DefenderVote", Args: []Type{"AccountId", "bool"}, Documentation: []Text{" A vote has been placed for a defending member [voter, vote]"}}, EventMetadataV4{Name: "NewMaxMembers", Args: []Type{"u32"}, Documentation: []Text{" A new [max] member count has been set"}}, EventMetadataV4{Name: "Unfounded", Args: []Type{"AccountId"}, Documentation: []Text{" Society is unfounded. [founder]"}}, EventMetadataV4{Name: "Deposit", Args: []Type{"Balance"}, Documentation: []Text{" Some funds were deposited into the society account. [value]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "CandidateDeposit", Type: "BalanceOf<T, I>", Value: Bytes{0x0, 0x80, 0xc6, 0xa4, 0x7e, 0x8d, 0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount of a deposit required for a bid to be made."}}, ModuleConstantMetadataV6{Name: "WrongSideDeduction", Type: "BalanceOf<T, I>", Value: Bytes{0x0, 0x80, 0xf4, 0x20, 0xe6, 0xb5, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of the unpaid reward that gets deducted in the case that either a skeptic", " doesn't vote or someone votes in the wrong way."}}, ModuleConstantMetadataV6{Name: "MaxStrikes", Type: "u32", Value: Bytes{0xa, 0x0, 0x0, 0x0}, Documentation: []Text{" The number of times a member may vote the wrong way (or not at all, when they are a skeptic)", " before they become suspended."}}, ModuleConstantMetadataV6{Name: "PeriodSpend", Type: "BalanceOf<T, I>", Value: Bytes{0x0, 0x0, 0xc5, 0x2e, 0xbc, 0xa2, 0xb1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of incentive paid within each period. Doesn't include VoterTip."}}, ModuleConstantMetadataV6{Name: "RotationPeriod", Type: "T::BlockNumber", Value: Bytes{0x0, 0x77, 0x1, 0x0}, Documentation: []Text{" The number of blocks between candidate/membership rotation periods."}}, ModuleConstantMetadataV6{Name: "ChallengePeriod", Type: "T::BlockNumber", Value: Bytes{0x80, 0x13, 0x3, 0x0}, Documentation: []Text{" The number of blocks between membership challenges."}}, ModuleConstantMetadataV6{Name: "ModuleId", Type: "ModuleId", Value: Bytes{0x70, 0x79, 0x2f, 0x73, 0x6f, 0x63, 0x69, 0x65}, Documentation: []Text{" The societies's module id"}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "BadPosition", Documentation: []Text{" An incorrect position was provided."}}, ErrorMetadataV8{Name: "NotMember", Documentation: []Text{" User is not a member."}}, ErrorMetadataV8{Name: "AlreadyMember", Documentation: []Text{" User is already a member."}}, ErrorMetadataV8{Name: "Suspended", Documentation: []Text{" User is suspended."}}, ErrorMetadataV8{Name: "NotSuspended", Documentation: []Text{" User is not suspended."}}, ErrorMetadataV8{Name: "NoPayout", Documentation: []Text{" Nothing to payout."}}, ErrorMetadataV8{Name: "AlreadyFounded", Documentation: []Text{" Society already founded."}}, ErrorMetadataV8{Name: "InsufficientPot", Documentation: []Text{" Not enough in pot to accept candidate."}}, ErrorMetadataV8{Name: "AlreadyVouching", Documentation: []Text{" Member is already vouching or banned from vouching again."}}, ErrorMetadataV8{Name: "NotVouching", Documentation: []Text{" Member is not vouching."}}, ErrorMetadataV8{Name: "Head", Documentation: []Text{" Cannot remove the head of the chain."}}, ErrorMetadataV8{Name: "Founder", Documentation: []Text{" Cannot remove the founder."}}, ErrorMetadataV8{Name: "AlreadyBid", Documentation: []Text{" User has already made a bid."}}, ErrorMetadataV8{Name: "AlreadyCandidate", Documentation: []Text{" User is already a candidate."}}, ErrorMetadataV8{Name: "NotCandidate", Documentation: []Text{" User is not a candidate."}}, ErrorMetadataV8{Name: "MaxMembers", Documentation: []Text{" Too many members in the society."}}, ErrorMetadataV8{Name: "NotFounder", Documentation: []Text{" The caller is not the founder."}}, ErrorMetadataV8{Name: "NotHead", Documentation: []Text{" The caller is not the head."}}}}, ModuleMetadataV10{Name: "Recovery", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Recovery", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Recoverable", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "RecoveryConfig<T::BlockNumber, BalanceOf<T>, T::AccountId>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The set of recoverable accounts and their recovery configuration."}}, StorageFunctionMetadataV10{Name: "ActiveRecoveries", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "T::AccountId", Key2: "T::AccountId", Value: "ActiveRecovery<T::BlockNumber, BalanceOf<T>, T::AccountId>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Active recovery attempts.", "", " First account is the account to be recovered, and the second account", " is the user trying to recover the account."}}, StorageFunctionMetadataV10{Name: "Proxy", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::AccountId", Value: "T::AccountId", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The list of allowed proxy accounts.", "", " Map from the user who can access it to the recovered account."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "as_recovered", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "account", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Trait>::Call>"}}, Documentation: []Text{" Send a call through a recovered account.", "", " The dispatch origin for this call must be _Signed_ and registered to", " be able to make calls on behalf of the recovered account.", "", " Parameters:", " - `account`: The recovered account you want to make a call on-behalf-of.", " - `call`: The call you want to make with the recovered account.", "", " # <weight>", " - The weight of the `call` + 10,000.", " - One storage lookup to check account is recovered by `who`. O(1)", " # </weight>"}}, FunctionMetadataV4{Name: "set_recovered", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "lost", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "rescuer", Type: "T::AccountId"}}, Documentation: []Text{" Allow ROOT to bypass the recovery process and set an a rescuer account", " for a lost account directly.", "", " The dispatch origin for this call must be _ROOT_.", "", " Parameters:", " - `lost`: The \"lost account\" to be recovered.", " - `rescuer`: The \"rescuer account\" which can call as the lost account.", "", " # <weight>", " - One storage write O(1)", " - One event", " # </weight>"}}, FunctionMetadataV4{Name: "create_recovery", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "friends", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "threshold", Type: "u16"}, FunctionArgumentMetadata{Name: "delay_period", Type: "T::BlockNumber"}}, Documentation: []Text{" Create a recovery configuration for your account. This makes your account recoverable.", "", " Payment: `ConfigDepositBase` + `FriendDepositFactor` * #_of_friends balance", " will be reserved for storing the recovery configuration. This deposit is returned", " in full when the user calls `remove_recovery`.", "", " The dispatch origin for this call must be _Signed_.", "", " Parameters:", " - `friends`: A list of friends you trust to vouch for recovery attempts.", "   Should be ordered and contain no duplicate values.", " - `threshold`: The number of friends that must vouch for a recovery attempt", "   before the account can be recovered. Should be less than or equal to", "   the length of the list of friends.", " - `delay_period`: The number of blocks after a recovery attempt is initialized", "   that needs to pass before the account can be recovered.", "", " # <weight>", " - Key: F (len of friends)", " - One storage read to check that account is not already recoverable. O(1).", " - A check that the friends list is sorted and unique. O(F)", " - One currency reserve operation. O(X)", " - One storage write. O(1). Codec O(F).", " - One event.", "", " Total Complexity: O(F + X)", " # </weight>"}}, FunctionMetadataV4{Name: "initiate_recovery", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "account", Type: "T::AccountId"}}, Documentation: []Text{" Initiate the process for recovering a recoverable account.", "", " Payment: `RecoveryDeposit` balance will be reserved for initiating the", " recovery process. This deposit will always be repatriated to the account", " trying to be recovered. See `close_recovery`.", "", " The dispatch origin for this call must be _Signed_.", "", " Parameters:", " - `account`: The lost account that you want to recover. This account", "   needs to be recoverable (i.e. have a recovery configuration).", "", " # <weight>", " - One storage read to check that account is recoverable. O(F)", " - One storage read to check that this recovery process hasn't already started. O(1)", " - One currency reserve operation. O(X)", " - One storage read to get the current block number. O(1)", " - One storage write. O(1).", " - One event.", "", " Total Complexity: O(F + X)", " # </weight>"}}, FunctionMetadataV4{Name: "vouch_recovery", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "lost", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "rescuer", Type: "T::AccountId"}}, Documentation: []Text{" Allow a \"friend\" of a recoverable account to vouch for an active recovery", " process for that account.", "", " The dispatch origin for this call must be _Signed_ and must be a \"friend\"", " for the recoverable account.", "", " Parameters:", " - `lost`: The lost account that you want to recover.", " - `rescuer`: The account trying to rescue the lost account that you", "   want to vouch for.", "", " The combination of these two parameters must point to an active recovery", " process.", "", " # <weight>", " Key: F (len of friends in config), V (len of vouching friends)", " - One storage read to get the recovery configuration. O(1), Codec O(F)", " - One storage read to get the active recovery process. O(1), Codec O(V)", " - One binary search to confirm caller is a friend. O(logF)", " - One binary search to confirm caller has not already vouched. O(logV)", " - One storage write. O(1), Codec O(V).", " - One event.", "", " Total Complexity: O(F + logF + V + logV)", " # </weight>"}}, FunctionMetadataV4{Name: "claim_recovery", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "account", Type: "T::AccountId"}}, Documentation: []Text{" Allow a successful rescuer to claim their recovered account.", "", " The dispatch origin for this call must be _Signed_ and must be a \"rescuer\"", " who has successfully completed the account recovery process: collected", " `threshold` or more vouches, waited `delay_period` blocks since initiation.", "", " Parameters:", " - `account`: The lost account that you want to claim has been successfully", "   recovered by you.", "", " # <weight>", " Key: F (len of friends in config), V (len of vouching friends)", " - One storage read to get the recovery configuration. O(1), Codec O(F)", " - One storage read to get the active recovery process. O(1), Codec O(V)", " - One storage read to get the current block number. O(1)", " - One storage write. O(1), Codec O(V).", " - One event.", "", " Total Complexity: O(F + V)", " # </weight>"}}, FunctionMetadataV4{Name: "close_recovery", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "rescuer", Type: "T::AccountId"}}, Documentation: []Text{" As the controller of a recoverable account, close an active recovery", " process for your account.", "", " Payment: By calling this function, the recoverable account will receive", " the recovery deposit `RecoveryDeposit` placed by the rescuer.", "", " The dispatch origin for this call must be _Signed_ and must be a", " recoverable account with an active recovery process for it.", "", " Parameters:", " - `rescuer`: The account trying to rescue this recoverable account.", "", " # <weight>", " Key: V (len of vouching friends)", " - One storage read/remove to get the active recovery process. O(1), Codec O(V)", " - One balance call to repatriate reserved. O(X)", " - One event.", "", " Total Complexity: O(V + X)", " # </weight>"}}, FunctionMetadataV4{Name: "remove_recovery", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Remove the recovery process for your account. Recovered accounts are still accessible.", "", " NOTE: The user must make sure to call `close_recovery` on all active", " recovery attempts before calling this function else it will fail.", "", " Payment: By calling this function the recoverable account will unreserve", " their recovery configuration deposit.", " (`ConfigDepositBase` + `FriendDepositFactor` * #_of_friends)", "", " The dispatch origin for this call must be _Signed_ and must be a", " recoverable account (i.e. has a recovery configuration).", "", " # <weight>", " Key: F (len of friends)", " - One storage read to get the prefix iterator for active recoveries. O(1)", " - One storage read/remove to get the recovery configuration. O(1), Codec O(F)", " - One balance call to unreserved. O(X)", " - One event.", "", " Total Complexity: O(F + X)", " # </weight>"}}, FunctionMetadataV4{Name: "cancel_recovered", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "account", Type: "T::AccountId"}}, Documentation: []Text{" Cancel the ability to use `as_recovered` for `account`.", "", " The dispatch origin for this call must be _Signed_ and registered to", " be able to make calls on behalf of the recovered account.", "", " Parameters:", " - `account`: The recovered account you are able to call on-behalf-of.", "", " # <weight>", " - One storage mutation to check account is recovered by `who`. O(1)", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "RecoveryCreated", Args: []Type{"AccountId"}, Documentation: []Text{" A recovery process has been set up for an [account]."}}, EventMetadataV4{Name: "RecoveryInitiated", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" A recovery process has been initiated for lost account by rescuer account.", " [lost, rescuer]"}}, EventMetadataV4{Name: "RecoveryVouched", Args: []Type{"AccountId", "AccountId", "AccountId"}, Documentation: []Text{" A recovery process for lost account by rescuer account has been vouched for by sender.", " [lost, rescuer, sender]"}}, EventMetadataV4{Name: "RecoveryClosed", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" A recovery process for lost account by rescuer account has been closed.", " [lost, rescuer]"}}, EventMetadataV4{Name: "AccountRecovered", Args: []Type{"AccountId", "AccountId"}, Documentation: []Text{" Lost account has been successfully recovered by rescuer account.", " [lost, rescuer]"}}, EventMetadataV4{Name: "RecoveryRemoved", Args: []Type{"AccountId"}, Documentation: []Text{" A recovery process has been removed for an [account]."}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "ConfigDepositBase", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x63, 0x52, 0xbf, 0xc6, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The base amount of currency needed to reserve for creating a recovery configuration."}}, ModuleConstantMetadataV6{Name: "FriendDepositFactor", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x20, 0x3d, 0x88, 0x79, 0x2d, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of currency needed per additional user when creating a recovery configuration."}}, ModuleConstantMetadataV6{Name: "MaxFriends", Type: "u16", Value: Bytes{0x9, 0x0}, Documentation: []Text{" The maximum amount of friends allowed in a recovery configuration."}}, ModuleConstantMetadataV6{Name: "RecoveryDeposit", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x40, 0x63, 0x52, 0xbf, 0xc6, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The base amount of currency needed to reserve for starting a recovery."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "NotAllowed", Documentation: []Text{" User is not allowed to make a call on behalf of this account"}}, ErrorMetadataV8{Name: "ZeroThreshold", Documentation: []Text{" Threshold must be greater than zero"}}, ErrorMetadataV8{Name: "NotEnoughFriends", Documentation: []Text{" Friends list must be greater than zero and threshold"}}, ErrorMetadataV8{Name: "MaxFriends", Documentation: []Text{" Friends list must be less than max friends"}}, ErrorMetadataV8{Name: "NotSorted", Documentation: []Text{" Friends list must be sorted and free of duplicates"}}, ErrorMetadataV8{Name: "NotRecoverable", Documentation: []Text{" This account is not set up for recovery"}}, ErrorMetadataV8{Name: "AlreadyRecoverable", Documentation: []Text{" This account is already set up for recovery"}}, ErrorMetadataV8{Name: "AlreadyStarted", Documentation: []Text{" A recovery process has already started for this account"}}, ErrorMetadataV8{Name: "NotStarted", Documentation: []Text{" A recovery process has not started for this rescuer"}}, ErrorMetadataV8{Name: "NotFriend", Documentation: []Text{" This account is not a friend who can vouch"}}, ErrorMetadataV8{Name: "DelayPeriod", Documentation: []Text{" The friend must wait until the delay period to vouch for this recovery"}}, ErrorMetadataV8{Name: "AlreadyVouched", Documentation: []Text{" This user has already vouched for this recovery"}}, ErrorMetadataV8{Name: "Threshold", Documentation: []Text{" The threshold for recovering this account has not been met"}}, ErrorMetadataV8{Name: "StillActive", Documentation: []Text{" There are still active recovery attempts that need to be closed"}}, ErrorMetadataV8{Name: "Overflow", Documentation: []Text{" There was an overflow in a calculation"}}, ErrorMetadataV8{Name: "AlreadyProxy", Documentation: []Text{" This account is already set up for recovery"}}}}, ModuleMetadataV10{Name: "Vesting", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Vesting", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Vesting", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "T::AccountId", Value: "VestingInfo<BalanceOf<T>, T::BlockNumber>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Information regarding the vesting of a given account."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "vest", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Unlock any vested funds of the sender account.", "", " The dispatch origin for this call must be _Signed_ and the sender must have funds still", " locked under this module.", "", " Emits either `VestingCompleted` or `VestingUpdated`.", "", " # <weight>", " - `O(1)`.", " - DbWeight: 2 Reads, 2 Writes", "     - Reads: Vesting Storage, Balances Locks, [Sender Account]", "     - Writes: Vesting Storage, Balances Locks, [Sender Account]", " - Benchmark:", "     - Unlocked: 48.76 + .048 * l µs (min square analysis)", "     - Locked: 44.43 + .284 * l µs (min square analysis)", " - Using 50 µs fixed. Assuming less than 50 locks on any user, else we may want factor in number of locks.", " # </weight>"}}, FunctionMetadataV4{Name: "vest_other", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "target", Type: "<T::Lookup as StaticLookup>::Source"}}, Documentation: []Text{" Unlock any vested funds of a `target` account.", "", " The dispatch origin for this call must be _Signed_.", "", " - `target`: The account whose vested funds should be unlocked. Must have funds still", " locked under this module.", "", " Emits either `VestingCompleted` or `VestingUpdated`.", "", " # <weight>", " - `O(1)`.", " - DbWeight: 3 Reads, 3 Writes", "     - Reads: Vesting Storage, Balances Locks, Target Account", "     - Writes: Vesting Storage, Balances Locks, Target Account", " - Benchmark:", "     - Unlocked: 44.3 + .294 * l µs (min square analysis)", "     - Locked: 48.16 + .103 * l µs (min square analysis)", " - Using 50 µs fixed. Assuming less than 50 locks on any user, else we may want factor in number of locks.", " # </weight>"}}, FunctionMetadataV4{Name: "vested_transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "target", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "schedule", Type: "VestingInfo<BalanceOf<T>, T::BlockNumber>"}}, Documentation: []Text{" Create a vested transfer.", "", " The dispatch origin for this call must be _Signed_.", "", " - `target`: The account that should be transferred the vested funds.", " - `amount`: The amount of funds to transfer and will be vested.", " - `schedule`: The vesting schedule attached to the transfer.", "", " Emits `VestingCreated`.", "", " # <weight>", " - `O(1)`.", " - DbWeight: 3 Reads, 3 Writes", "     - Reads: Vesting Storage, Balances Locks, Target Account, [Sender Account]", "     - Writes: Vesting Storage, Balances Locks, Target Account, [Sender Account]", " - Benchmark: 100.3 + .365 * l µs (min square analysis)", " - Using 100 µs fixed. Assuming less than 50 locks on any user, else we may want factor in number of locks.", " # </weight>"}}, FunctionMetadataV4{Name: "force_vested_transfer", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "source", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "target", Type: "<T::Lookup as StaticLookup>::Source"}, FunctionArgumentMetadata{Name: "schedule", Type: "VestingInfo<BalanceOf<T>, T::BlockNumber>"}}, Documentation: []Text{" Force a vested transfer.", "", " The dispatch origin for this call must be _Root_.", "", " - `source`: The account whose funds should be transferred.", " - `target`: The account that should be transferred the vested funds.", " - `amount`: The amount of funds to transfer and will be vested.", " - `schedule`: The vesting schedule attached to the transfer.", "", " Emits `VestingCreated`.", "", " # <weight>", " - `O(1)`.", " - DbWeight: 4 Reads, 4 Writes", "     - Reads: Vesting Storage, Balances Locks, Target Account, Source Account", "     - Writes: Vesting Storage, Balances Locks, Target Account, Source Account", " - Benchmark: 100.3 + .365 * l µs (min square analysis)", " - Using 100 µs fixed. Assuming less than 50 locks on any user, else we may want factor in number of locks.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "VestingUpdated", Args: []Type{"AccountId", "Balance"}, Documentation: []Text{" The amount vested has been updated. This could indicate more funds are available. The", " balance given is the amount which is left unvested (and thus locked). ", " [account, unvested]"}}, EventMetadataV4{Name: "VestingCompleted", Args: []Type{"AccountId"}, Documentation: []Text{" An [account] has become fully vested. No further vesting can happen."}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "MinVestedTransfer", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x0, 0xc1, 0x6f, 0xf2, 0x86, 0x23, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The minimum amount to be transferred to create a new vesting schedule."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "NotVesting", Documentation: []Text{" The account given is not vesting."}}, ErrorMetadataV8{Name: "ExistingVestingSchedule", Documentation: []Text{" An existing vesting schedule already exists for this account that cannot be clobbered."}}, ErrorMetadataV8{Name: "AmountLow", Documentation: []Text{" Amount being transferred is too low to create a vesting schedule."}}}}, ModuleMetadataV10{Name: "Scheduler", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Scheduler", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Agenda", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::BlockNumber", Value: "Vec<Option<Scheduled<<T as Trait>::Call, T::BlockNumber, T::\nPalletsOrigin, T::AccountId>>>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Items to be executed, indexed by the block number that they should be executed on."}}, StorageFunctionMetadataV10{Name: "Lookup", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "Vec<u8>", Value: "TaskAddress<T::BlockNumber>", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Lookup from identity to the block number and index of the task."}}, StorageFunctionMetadataV10{Name: "StorageVersion", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: true, AsType: "Releases", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" Storage version of the pallet.", "", " New networks start with last version."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "schedule", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "when", Type: "T::BlockNumber"}, FunctionArgumentMetadata{Name: "maybe_periodic", Type: "Option<schedule::Period<T::BlockNumber>>"}, FunctionArgumentMetadata{Name: "priority", Type: "schedule::Priority"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Trait>::Call>"}}, Documentation: []Text{" Anonymously schedule a task.", "", " # <weight>", " - S = Number of already scheduled calls", " - Base Weight: 22.29 + .126 * S µs", " - DB Weight:", "     - Read: Agenda", "     - Write: Agenda", " - Will use base weight of 25 which should be good for up to 30 scheduled calls", " # </weight>"}}, FunctionMetadataV4{Name: "cancel", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "when", Type: "T::BlockNumber"}, FunctionArgumentMetadata{Name: "index", Type: "u32"}}, Documentation: []Text{" Cancel an anonymously scheduled task.", "", " # <weight>", " - S = Number of already scheduled calls", " - Base Weight: 22.15 + 2.869 * S µs", " - DB Weight:", "     - Read: Agenda", "     - Write: Agenda, Lookup", " - Will use base weight of 100 which should be good for up to 30 scheduled calls", " # </weight>"}}, FunctionMetadataV4{Name: "schedule_named", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Vec<u8>"}, FunctionArgumentMetadata{Name: "when", Type: "T::BlockNumber"}, FunctionArgumentMetadata{Name: "maybe_periodic", Type: "Option<schedule::Period<T::BlockNumber>>"}, FunctionArgumentMetadata{Name: "priority", Type: "schedule::Priority"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Trait>::Call>"}}, Documentation: []Text{" Schedule a named task.", "", " # <weight>", " - S = Number of already scheduled calls", " - Base Weight: 29.6 + .159 * S µs", " - DB Weight:", "     - Read: Agenda, Lookup", "     - Write: Agenda, Lookup", " - Will use base weight of 35 which should be good for more than 30 scheduled calls", " # </weight>"}}, FunctionMetadataV4{Name: "cancel_named", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Vec<u8>"}}, Documentation: []Text{" Cancel a named scheduled task.", "", " # <weight>", " - S = Number of already scheduled calls", " - Base Weight: 24.91 + 2.907 * S µs", " - DB Weight:", "     - Read: Agenda, Lookup", "     - Write: Agenda, Lookup", " - Will use base weight of 100 which should be good for up to 30 scheduled calls", " # </weight>"}}, FunctionMetadataV4{Name: "schedule_after", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "after", Type: "T::BlockNumber"}, FunctionArgumentMetadata{Name: "maybe_periodic", Type: "Option<schedule::Period<T::BlockNumber>>"}, FunctionArgumentMetadata{Name: "priority", Type: "schedule::Priority"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Trait>::Call>"}}, Documentation: []Text{" Anonymously schedule a task after a delay.", "", " # <weight>", " Same as [`schedule`].", " # </weight>"}}, FunctionMetadataV4{Name: "schedule_named_after", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "id", Type: "Vec<u8>"}, FunctionArgumentMetadata{Name: "after", Type: "T::BlockNumber"}, FunctionArgumentMetadata{Name: "maybe_periodic", Type: "Option<schedule::Period<T::BlockNumber>>"}, FunctionArgumentMetadata{Name: "priority", Type: "schedule::Priority"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Trait>::Call>"}}, Documentation: []Text{" Schedule a named task after a delay.", "", " # <weight>", " Same as [`schedule_named`].", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "Scheduled", Args: []Type{"BlockNumber", "u32"}, Documentation: []Text{" Scheduled some task. [when, index]"}}, EventMetadataV4{Name: "Canceled", Args: []Type{"BlockNumber", "u32"}, Documentation: []Text{" Canceled some task. [when, index]"}}, EventMetadataV4{Name: "Dispatched", Args: []Type{"TaskAddress<BlockNumber>", "Option<Vec<u8>>", "DispatchResult"}, Documentation: []Text{" Dispatched some task. [task, id, result]"}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "FailedToSchedule", Documentation: []Text{" Failed to schedule a call"}}, ErrorMetadataV8{Name: "FailedToCancel", Documentation: []Text{" Failed to cancel a scheduled call"}}, ErrorMetadataV8{Name: "TargetBlockNumberInPast", Documentation: []Text{" Given target block number is in the past."}}}}, ModuleMetadataV10{Name: "Proxy", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Proxy", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Proxies", Modifier: StorageFunctionModifierV0{IsOptional: false, IsDefault: true, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key: "T::AccountId", Value: "(Vec<(T::AccountId, T::ProxyType)>, BalanceOf<T>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The set of account proxies. Maps the account which has delegated to the accounts", " which are being delegated to, together with the amount held on deposit."}}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "proxy", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "real", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "force_proxy_type", Type: "Option<T::ProxyType>"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Trait>::Call>"}}, Documentation: []Text{" Dispatch the given `call` from an account that the sender is authorised for through", " `add_proxy`.", "", " The dispatch origin for this call must be _Signed_.", "", " Parameters:", " - `real`: The account that the proxy will make a call on behalf of.", " - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.", " - `call`: The call to be made by the `real` account.", "", " # <weight>", " P is the number of proxies the user has", " - Base weight: 19.87 + .141 * P µs", " - DB weight: 1 storage read.", " - Plus the weight of the `call`", " # </weight>"}}, FunctionMetadataV4{Name: "add_proxy", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proxy", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "proxy_type", Type: "T::ProxyType"}}, Documentation: []Text{" Register a proxy account for the sender that is able to make calls on its behalf.", "", " The dispatch origin for this call must be _Signed_.", "", " Parameters:", " - `proxy`: The account that the `caller` would like to make a proxy.", " - `proxy_type`: The permissions allowed for this proxy account.", "", " # <weight>", " P is the number of proxies the user has", " - Base weight: 17.48 + .176 * P µs", " - DB weight: 1 storage read and write.", " # </weight>"}}, FunctionMetadataV4{Name: "remove_proxy", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proxy", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "proxy_type", Type: "T::ProxyType"}}, Documentation: []Text{" Unregister a proxy account for the sender.", "", " The dispatch origin for this call must be _Signed_.", "", " Parameters:", " - `proxy`: The account that the `caller` would like to remove as a proxy.", " - `proxy_type`: The permissions currently enabled for the removed proxy account.", "", " # <weight>", " P is the number of proxies the user has", " - Base weight: 14.37 + .164 * P µs", " - DB weight: 1 storage read and write.", " # </weight>"}}, FunctionMetadataV4{Name: "remove_proxies", Args: []FunctionArgumentMetadata(nil), Documentation: []Text{" Unregister all proxy accounts for the sender.", "", " The dispatch origin for this call must be _Signed_.", "", " WARNING: This may be called on accounts created by `anonymous`, however if done, then", " the unreserved fees will be inaccessible. **All access to this account will be lost.**", "", " # <weight>", " P is the number of proxies the user has", " - Base weight: 13.73 + .129 * P µs", " - DB weight: 1 storage read and write.", " # </weight>"}}, FunctionMetadataV4{Name: "anonymous", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "proxy_type", Type: "T::ProxyType"}, FunctionArgumentMetadata{Name: "index", Type: "u16"}}, Documentation: []Text{" Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and", " initialize it with a proxy of `proxy_type` for `origin` sender.", "", " Requires a `Signed` origin.", "", " - `proxy_type`: The type of the proxy that the sender will be registered as over the", " new account. This will almost always be the most permissive `ProxyType` possible to", " allow for maximum flexibility.", " - `index`: A disambiguation index, in case this is called multiple times in the same", " transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just", " want to use `0`.", "", " Fails with `Duplicate` if this has already been called in this transaction, from the", " same sender, with the same parameters.", "", " Fails if there are insufficient funds to pay for deposit.", "", " # <weight>", " P is the number of proxies the user has", " - Base weight: 36.48 + .039 * P µs", " - DB weight: 1 storage read and write.", " # </weight>"}}, FunctionMetadataV4{Name: "kill_anonymous", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "spawner", Type: "T::AccountId"}, FunctionArgumentMetadata{Name: "proxy_type", Type: "T::ProxyType"}, FunctionArgumentMetadata{Name: "index", Type: "u16"}, FunctionArgumentMetadata{Name: "height", Type: "Compact<T::BlockNumber>"}, FunctionArgumentMetadata{Name: "ext_index", Type: "Compact<u32>"}}, Documentation: []Text{" Removes a previously spawned anonymous proxy.", "", " WARNING: **All access to this account will be lost.** Any funds held in it will be", " inaccessible.", "", " Requires a `Signed` origin, and the sender account must have been created by a call to", " `anonymous` with corresponding parameters.", "", " - `spawner`: The account that originally called `anonymous` to create this account.", " - `index`: The disambiguation index originally passed to `anonymous`. Probably `0`.", " - `proxy_type`: The proxy type originally passed to `anonymous`.", " - `height`: The height of the chain when the call to `anonymous` was processed.", " - `ext_index`: The extrinsic index in which the call to `anonymous` was processed.", "", " Fails with `NoPermission` in case the caller is not a previously created anonymous", " account whose `anonymous` call has corresponding parameters.", "", " # <weight>", " P is the number of proxies the user has", " - Base weight: 15.65 + .137 * P µs", " - DB weight: 1 storage read and write.", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "ProxyExecuted", Args: []Type{"DispatchResult"}, Documentation: []Text{" A proxy was executed correctly, with the given [result]."}}, EventMetadataV4{Name: "AnonymousCreated", Args: []Type{"AccountId", "AccountId", "ProxyType", "u16"}, Documentation: []Text{" Anonymous account has been created by new proxy with given", " disambiguation index and proxy type. [anonymous, who, proxy_type, disambiguation_index]"}}}, Constants: []ModuleConstantMetadataV6{ModuleConstantMetadataV6{Name: "ProxyDepositBase", Type: "BalanceOf<T>", Value: Bytes{0x0, 0xf0, 0x9e, 0x54, 0x4c, 0x39, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The base amount of currency needed to reserve for creating a proxy."}}, ModuleConstantMetadataV6{Name: "ProxyDepositFactor", Type: "BalanceOf<T>", Value: Bytes{0x0, 0x60, 0xaa, 0x77, 0x14, 0xb4, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, Documentation: []Text{" The amount of currency needed per proxy added."}}, ModuleConstantMetadataV6{Name: "MaxProxies", Type: "u16", Value: Bytes{0x20, 0x0}, Documentation: []Text{" The maximum amount of proxies allowed for a single account."}}}, Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "TooMany", Documentation: []Text{" There are too many proxies registered."}}, ErrorMetadataV8{Name: "NotFound", Documentation: []Text{" Proxy registration not found."}}, ErrorMetadataV8{Name: "NotProxy", Documentation: []Text{" Sender is not a proxy of the account to be proxied."}}, ErrorMetadataV8{Name: "Unproxyable", Documentation: []Text{" A call which is incompatible with the proxy type's filter was attempted."}}, ErrorMetadataV8{Name: "Duplicate", Documentation: []Text{" Account is already a proxy."}}, ErrorMetadataV8{Name: "NoPermission", Documentation: []Text{" Call may not be made by proxy because it may escalate its privileges."}}}}, ModuleMetadataV10{Name: "Multisig", HasStorage: true, Storage: StorageMetadataV10{Prefix: "Multisig", Items: []StorageFunctionMetadataV10{StorageFunctionMetadataV10{Name: "Multisigs", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: false, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key: "", Value: "", Linked: false}, IsDoubleMap: true, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: true, IsIdentity: false}, Key1: "T::AccountId", Key2: "[u8; 32]", Value: "Multisig<T::BlockNumber, BalanceOf<T>, T::AccountId>", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: true, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text{" The set of open multisig operations."}}, StorageFunctionMetadataV10{Name: "Calls", Modifier: StorageFunctionModifierV0{IsOptional: true, IsDefault: false, IsRequired: false}, Type: StorageFunctionTypeV10{IsType: false, AsType: "", IsMap: true, AsMap: MapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: true}, Key: "[u8; 32]", Value: "(OpaqueCall, T::AccountId, BalanceOf<T>)", Linked: false}, IsDoubleMap: false, AsDoubleMap: DoubleMapTypeV10{Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}, Key1: "", Key2: "", Value: "", Key2Hasher: StorageHasherV10{IsBlake2_128: false, IsBlake2_256: false, IsBlake2_128Concat: false, IsTwox128: false, IsTwox256: false, IsTwox64Concat: false, IsIdentity: false}}}, Fallback: Bytes{0x0}, Documentation: []Text(nil)}}}, HasCalls: true, Calls: []FunctionMetadataV4{FunctionMetadataV4{Name: "as_multi_threshold_1", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "other_signatories", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "call", Type: "Box<<T as Trait>::Call>"}}, Documentation: []Text{" Immediately dispatch a multi-signature call using a single approval from the caller.", "", " The dispatch origin for this call must be _Signed_.", "", " - `other_signatories`: The accounts (other than the sender) who are part of the", " multi-signature, but do not participate in the approval process.", " - `call`: The call to be executed.", "", " Result is equivalent to the dispatched result.", "", " # <weight>", " O(Z + C) where Z is the length of the call and C its execution weight.", " -------------------------------", " - Base Weight: 33.72 + 0.002 * Z µs", " - DB Weight: None", " - Plus Call Weight", " # </weight>"}}, FunctionMetadataV4{Name: "as_multi", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "threshold", Type: "u16"}, FunctionArgumentMetadata{Name: "other_signatories", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "maybe_timepoint", Type: "Option<Timepoint<T::BlockNumber>>"}, FunctionArgumentMetadata{Name: "call", Type: "OpaqueCall"}, FunctionArgumentMetadata{Name: "store_call", Type: "bool"}, FunctionArgumentMetadata{Name: "max_weight", Type: "Weight"}}, Documentation: []Text{" Register approval for a dispatch to be made from a deterministic composite account if", " approved by a total of `threshold - 1` of `other_signatories`.", "", " If there are enough, then dispatch the call.", "", " Payment: `DepositBase` will be reserved if this is the first approval, plus", " `threshold` times `DepositFactor`. It is returned once this dispatch happens or", " is cancelled.", "", " The dispatch origin for this call must be _Signed_.", "", " - `threshold`: The total number of approvals for this dispatch before it is executed.", " - `other_signatories`: The accounts (other than the sender) who can approve this", " dispatch. May not be empty.", " - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is", " not the first approval, then it must be `Some`, with the timepoint (block number and", " transaction index) of the first approval transaction.", " - `call`: The call to be executed.", "", " NOTE: Unless this is the final approval, you will generally want to use", " `approve_as_multi` instead, since it only requires a hash of the call.", "", " Result is equivalent to the dispatched result if `threshold` is exactly `1`. Otherwise", " on success, result is `Ok` and the result from the interior call, if it was executed,", " may be found in the deposited `MultisigExecuted` event.", "", " # <weight>", " - `O(S + Z + Call)`.", " - Up to one balance-reserve or unreserve operation.", " - One passthrough operation, one insert, both `O(S)` where `S` is the number of", "   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.", " - One call encode & hash, both of complexity `O(Z)` where `Z` is tx-len.", " - One encode & hash, both of complexity `O(S)`.", " - Up to one binary search and insert (`O(logS + S)`).", " - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.", " - One event.", " - The weight of the `call`.", " - Storage: inserts one item, value size bounded by `MaxSignatories`, with a", "   deposit taken for its lifetime of", "   `DepositBase + threshold * DepositFactor`.", " -------------------------------", " - Base Weight:", "     - Create:          41.89 + 0.118 * S + .002 * Z µs", "     - Create w/ Store: 53.57 + 0.119 * S + .003 * Z µs", "     - Approve:         31.39 + 0.136 * S + .002 * Z µs", "     - Complete:        39.94 + 0.26  * S + .002 * Z µs", " - DB Weight:", "     - Reads: Multisig Storage, [Caller Account], Calls (if `store_call`)", "     - Writes: Multisig Storage, [Caller Account], Calls (if `store_call`)", " - Plus Call Weight", " # </weight>"}}, FunctionMetadataV4{Name: "approve_as_multi", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "threshold", Type: "u16"}, FunctionArgumentMetadata{Name: "other_signatories", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "maybe_timepoint", Type: "Option<Timepoint<T::BlockNumber>>"}, FunctionArgumentMetadata{Name: "call_hash", Type: "[u8; 32]"}, FunctionArgumentMetadata{Name: "max_weight", Type: "Weight"}}, Documentation: []Text{" Register approval for a dispatch to be made from a deterministic composite account if", " approved by a total of `threshold - 1` of `other_signatories`.", "", " Payment: `DepositBase` will be reserved if this is the first approval, plus", " `threshold` times `DepositFactor`. It is returned once this dispatch happens or", " is cancelled.", "", " The dispatch origin for this call must be _Signed_.", "", " - `threshold`: The total number of approvals for this dispatch before it is executed.", " - `other_signatories`: The accounts (other than the sender) who can approve this", " dispatch. May not be empty.", " - `maybe_timepoint`: If this is the first approval, then this must be `None`. If it is", " not the first approval, then it must be `Some`, with the timepoint (block number and", " transaction index) of the first approval transaction.", " - `call_hash`: The hash of the call to be executed.", "", " NOTE: If this is the final approval, you will want to use `as_multi` instead.", "", " # <weight>", " - `O(S)`.", " - Up to one balance-reserve or unreserve operation.", " - One passthrough operation, one insert, both `O(S)` where `S` is the number of", "   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.", " - One encode & hash, both of complexity `O(S)`.", " - Up to one binary search and insert (`O(logS + S)`).", " - I/O: 1 read `O(S)`, up to 1 mutate `O(S)`. Up to one remove.", " - One event.", " - Storage: inserts one item, value size bounded by `MaxSignatories`, with a", "   deposit taken for its lifetime of", "   `DepositBase + threshold * DepositFactor`.", " ----------------------------------", " - Base Weight:", "     - Create: 44.71 + 0.088 * S", "     - Approve: 31.48 + 0.116 * S", " - DB Weight:", "     - Read: Multisig Storage, [Caller Account]", "     - Write: Multisig Storage, [Caller Account]", " # </weight>"}}, FunctionMetadataV4{Name: "cancel_as_multi", Args: []FunctionArgumentMetadata{FunctionArgumentMetadata{Name: "threshold", Type: "u16"}, FunctionArgumentMetadata{Name: "other_signatories", Type: "Vec<T::AccountId>"}, FunctionArgumentMetadata{Name: "timepoint", Type: "Timepoint<T::BlockNumber>"}, FunctionArgumentMetadata{Name: "call_hash", Type: "[u8; 32]"}}, Documentation: []Text{" Cancel a pre-existing, on-going multisig transaction. Any deposit reserved previously", " for this operation will be unreserved on success.", "", " The dispatch origin for this call must be _Signed_.", "", " - `threshold`: The total number of approvals for this dispatch before it is executed.", " - `other_signatories`: The accounts (other than the sender) who can approve this", " dispatch. May not be empty.", " - `timepoint`: The timepoint (block number and transaction index) of the first approval", " transaction for this dispatch.", " - `call_hash`: The hash of the call to be executed.", "", " # <weight>", " - `O(S)`.", " - Up to one balance-reserve or unreserve operation.", " - One passthrough operation, one insert, both `O(S)` where `S` is the number of", "   signatories. `S` is capped by `MaxSignatories`, with weight being proportional.", " - One encode & hash, both of complexity `O(S)`.", " - One event.", " - I/O: 1 read `O(S)`, one remove.", " - Storage: removes one item.", " ----------------------------------", " - Base Weight: 36.07 + 0.124 * S", " - DB Weight:", "     - Read: Multisig Storage, [Caller Account], Refund Account, Calls", "     - Write: Multisig Storage, [Caller Account], Refund Account, Calls", " # </weight>"}}}, HasEvents: true, Events: []EventMetadataV4{EventMetadataV4{Name: "NewMultisig", Args: []Type{"AccountId", "AccountId", "CallHash"}, Documentation: []Text{" A new multisig operation has begun. [approving, multisig, call_hash]"}}, EventMetadataV4{Name: "MultisigApproval", Args: []Type{"AccountId", "Timepoint<BlockNumber>", "AccountId", "CallHash"}, Documentation: []Text{" A multisig operation has been approved by someone. [approving, timepoint, multisig, call_hash]"}}, EventMetadataV4{Name: "MultisigExecuted", Args: []Type{"AccountId", "Timepoint<BlockNumber>", "AccountId", "CallHash", "DispatchResult"}, Documentation: []Text{" A multisig operation has been executed. [approving, timepoint, multisig, call_hash]"}}, EventMetadataV4{Name: "MultisigCancelled", Args: []Type{"AccountId", "Timepoint<BlockNumber>", "AccountId", "CallHash"}, Documentation: []Text{" A multisig operation has been cancelled. [cancelling, timepoint, multisig, call_hash]"}}}, Constants: []ModuleConstantMetadataV6(nil), Errors: []ErrorMetadataV8{ErrorMetadataV8{Name: "MinimumThreshold", Documentation: []Text{" Threshold must be 2 or greater."}}, ErrorMetadataV8{Name: "AlreadyApproved", Documentation: []Text{" Call is already approved by this signatory."}}, ErrorMetadataV8{Name: "NoApprovalsNeeded", Documentation: []Text{" Call doesn't need any (more) approvals."}}, ErrorMetadataV8{Name: "TooFewSignatories", Documentation: []Text{" There are too few signatories in the list."}}, ErrorMetadataV8{Name: "TooManySignatories", Documentation: []Text{" There are too many signatories in the list."}}, ErrorMetadataV8{Name: "SignatoriesOutOfOrder", Documentation: []Text{" The signatories were provided out of order; they should be ordered."}}, ErrorMetadataV8{Name: "SenderInSignatories", Documentation: []Text{" The sender was contained in the other signatories; it shouldn't be."}}, ErrorMetadataV8{Name: "NotFound", Documentation: []Text{" Multisig operation not found when attempting to cancel."}}, ErrorMetadataV8{Name: "NotOwner", Documentation: []Text{" Only the account that originally created the multisig is able to cancel it."}}, ErrorMetadataV8{Name: "NoTimepoint", Documentation: []Text{" No timepoint was given, yet the multisig operation is already underway."}}, ErrorMetadataV8{Name: "WrongTimepoint", Documentation: []Text{" A different timepoint was given to the multisig operation that is underway."}}, ErrorMetadataV8{Name: "UnexpectedTimepoint", Documentation: []Text{" A timepoint was given, yet no multisig operation is underway."}}, ErrorMetadataV8{Name: "WeightTooLow", Documentation: []Text{" The maximum weight information provided was too low."}}, ErrorMetadataV8{Name: "AlreadyStored", Documentation: []Text{" The data to be stored is already stored."}}}}}}, Extrinsic: ExtrinsicV11{Version: 0x4, SignedExtensions: []string{"CheckSpecVersion", "CheckTxVersion", "CheckGenesis", "CheckMortality", "CheckNonce", "CheckWeight", "ChargeTransactionPayment"}}}}
