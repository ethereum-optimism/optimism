// Code generated by counterfeiter. DO NOT EDIT.
package nodefakes

import (
	"math/big"
	"sync"

	"github.com/bobanetwork/boba/boba-chain-ops/node"
	ethereum "github.com/ledgerwatch/erigon"
	"github.com/ledgerwatch/erigon-lib/common"
	"github.com/ledgerwatch/erigon/core/types"
	"github.com/ledgerwatch/erigon/turbo/engineapi/engine_types"
)

type FakeRPC struct {
	ForkchoiceUpdateV1Stub        func(*engine_types.ForkChoiceState, *engine_types.PayloadAttributes) (*node.ForkchoiceUpdatedResult, error)
	forkchoiceUpdateV1Mutex       sync.RWMutex
	forkchoiceUpdateV1ArgsForCall []struct {
		arg1 *engine_types.ForkChoiceState
		arg2 *engine_types.PayloadAttributes
	}
	forkchoiceUpdateV1Returns struct {
		result1 *node.ForkchoiceUpdatedResult
		result2 error
	}
	forkchoiceUpdateV1ReturnsOnCall map[int]struct {
		result1 *node.ForkchoiceUpdatedResult
		result2 error
	}
	GetBlockByNumberStub        func(*big.Int) (*node.Block, error)
	getBlockByNumberMutex       sync.RWMutex
	getBlockByNumberArgsForCall []struct {
		arg1 *big.Int
	}
	getBlockByNumberReturns struct {
		result1 *node.Block
		result2 error
	}
	getBlockByNumberReturnsOnCall map[int]struct {
		result1 *node.Block
		result2 error
	}
	GetBlockNumberStub        func() (*big.Int, error)
	getBlockNumberMutex       sync.RWMutex
	getBlockNumberArgsForCall []struct {
	}
	getBlockNumberReturns struct {
		result1 *big.Int
		result2 error
	}
	getBlockNumberReturnsOnCall map[int]struct {
		result1 *big.Int
		result2 error
	}
	GetLatestBlockStub        func() (*node.Block, error)
	getLatestBlockMutex       sync.RWMutex
	getLatestBlockArgsForCall []struct {
	}
	getLatestBlockReturns struct {
		result1 *node.Block
		result2 error
	}
	getLatestBlockReturnsOnCall map[int]struct {
		result1 *node.Block
		result2 error
	}
	GetLogsStub        func(*ethereum.FilterQuery) ([]*types.Log, error)
	getLogsMutex       sync.RWMutex
	getLogsArgsForCall []struct {
		arg1 *ethereum.FilterQuery
	}
	getLogsReturns struct {
		result1 []*types.Log
		result2 error
	}
	getLogsReturnsOnCall map[int]struct {
		result1 []*types.Log
		result2 error
	}
	GetPayloadV1Stub        func(*node.PayloadID) (*engine_types.ExecutionPayload, error)
	getPayloadV1Mutex       sync.RWMutex
	getPayloadV1ArgsForCall []struct {
		arg1 *node.PayloadID
	}
	getPayloadV1Returns struct {
		result1 *engine_types.ExecutionPayload
		result2 error
	}
	getPayloadV1ReturnsOnCall map[int]struct {
		result1 *engine_types.ExecutionPayload
		result2 error
	}
	GetTransactionByHashStub        func(*common.Hash) (types.Transaction, error)
	getTransactionByHashMutex       sync.RWMutex
	getTransactionByHashArgsForCall []struct {
		arg1 *common.Hash
	}
	getTransactionByHashReturns struct {
		result1 types.Transaction
		result2 error
	}
	getTransactionByHashReturnsOnCall map[int]struct {
		result1 types.Transaction
		result2 error
	}
	NewPayloadV1Stub        func(*engine_types.ExecutionPayload) (*node.PayloadStatusV1, error)
	newPayloadV1Mutex       sync.RWMutex
	newPayloadV1ArgsForCall []struct {
		arg1 *engine_types.ExecutionPayload
	}
	newPayloadV1Returns struct {
		result1 *node.PayloadStatusV1
		result2 error
	}
	newPayloadV1ReturnsOnCall map[int]struct {
		result1 *node.PayloadStatusV1
		result2 error
	}
	SetHeaderStub        func(string, string)
	setHeaderMutex       sync.RWMutex
	setHeaderArgsForCall []struct {
		arg1 string
		arg2 string
	}
	SetJWTAuthStub        func(*[32]byte) error
	setJWTAuthMutex       sync.RWMutex
	setJWTAuthArgsForCall []struct {
		arg1 *[32]byte
	}
	setJWTAuthReturns struct {
		result1 error
	}
	setJWTAuthReturnsOnCall map[int]struct {
		result1 error
	}
	TraceTransactionStub        func(*common.Hash) (*node.TraceTransaction, error)
	traceTransactionMutex       sync.RWMutex
	traceTransactionArgsForCall []struct {
		arg1 *common.Hash
	}
	traceTransactionReturns struct {
		result1 *node.TraceTransaction
		result2 error
	}
	traceTransactionReturnsOnCall map[int]struct {
		result1 *node.TraceTransaction
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRPC) ForkchoiceUpdateV1(arg1 *engine_types.ForkChoiceState, arg2 *engine_types.PayloadAttributes) (*node.ForkchoiceUpdatedResult, error) {
	fake.forkchoiceUpdateV1Mutex.Lock()
	ret, specificReturn := fake.forkchoiceUpdateV1ReturnsOnCall[len(fake.forkchoiceUpdateV1ArgsForCall)]
	fake.forkchoiceUpdateV1ArgsForCall = append(fake.forkchoiceUpdateV1ArgsForCall, struct {
		arg1 *engine_types.ForkChoiceState
		arg2 *engine_types.PayloadAttributes
	}{arg1, arg2})
	stub := fake.ForkchoiceUpdateV1Stub
	fakeReturns := fake.forkchoiceUpdateV1Returns
	fake.recordInvocation("ForkchoiceUpdateV1", []interface{}{arg1, arg2})
	fake.forkchoiceUpdateV1Mutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRPC) ForkchoiceUpdateV1CallCount() int {
	fake.forkchoiceUpdateV1Mutex.RLock()
	defer fake.forkchoiceUpdateV1Mutex.RUnlock()
	return len(fake.forkchoiceUpdateV1ArgsForCall)
}

func (fake *FakeRPC) ForkchoiceUpdateV1Calls(stub func(*engine_types.ForkChoiceState, *engine_types.PayloadAttributes) (*node.ForkchoiceUpdatedResult, error)) {
	fake.forkchoiceUpdateV1Mutex.Lock()
	defer fake.forkchoiceUpdateV1Mutex.Unlock()
	fake.ForkchoiceUpdateV1Stub = stub
}

func (fake *FakeRPC) ForkchoiceUpdateV1ArgsForCall(i int) (*engine_types.ForkChoiceState, *engine_types.PayloadAttributes) {
	fake.forkchoiceUpdateV1Mutex.RLock()
	defer fake.forkchoiceUpdateV1Mutex.RUnlock()
	argsForCall := fake.forkchoiceUpdateV1ArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRPC) ForkchoiceUpdateV1Returns(result1 *node.ForkchoiceUpdatedResult, result2 error) {
	fake.forkchoiceUpdateV1Mutex.Lock()
	defer fake.forkchoiceUpdateV1Mutex.Unlock()
	fake.ForkchoiceUpdateV1Stub = nil
	fake.forkchoiceUpdateV1Returns = struct {
		result1 *node.ForkchoiceUpdatedResult
		result2 error
	}{result1, result2}
}

func (fake *FakeRPC) ForkchoiceUpdateV1ReturnsOnCall(i int, result1 *node.ForkchoiceUpdatedResult, result2 error) {
	fake.forkchoiceUpdateV1Mutex.Lock()
	defer fake.forkchoiceUpdateV1Mutex.Unlock()
	fake.ForkchoiceUpdateV1Stub = nil
	if fake.forkchoiceUpdateV1ReturnsOnCall == nil {
		fake.forkchoiceUpdateV1ReturnsOnCall = make(map[int]struct {
			result1 *node.ForkchoiceUpdatedResult
			result2 error
		})
	}
	fake.forkchoiceUpdateV1ReturnsOnCall[i] = struct {
		result1 *node.ForkchoiceUpdatedResult
		result2 error
	}{result1, result2}
}

func (fake *FakeRPC) GetBlockByNumber(arg1 *big.Int) (*node.Block, error) {
	fake.getBlockByNumberMutex.Lock()
	ret, specificReturn := fake.getBlockByNumberReturnsOnCall[len(fake.getBlockByNumberArgsForCall)]
	fake.getBlockByNumberArgsForCall = append(fake.getBlockByNumberArgsForCall, struct {
		arg1 *big.Int
	}{arg1})
	stub := fake.GetBlockByNumberStub
	fakeReturns := fake.getBlockByNumberReturns
	fake.recordInvocation("GetBlockByNumber", []interface{}{arg1})
	fake.getBlockByNumberMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRPC) GetBlockByNumberCallCount() int {
	fake.getBlockByNumberMutex.RLock()
	defer fake.getBlockByNumberMutex.RUnlock()
	return len(fake.getBlockByNumberArgsForCall)
}

func (fake *FakeRPC) GetBlockByNumberCalls(stub func(*big.Int) (*node.Block, error)) {
	fake.getBlockByNumberMutex.Lock()
	defer fake.getBlockByNumberMutex.Unlock()
	fake.GetBlockByNumberStub = stub
}

func (fake *FakeRPC) GetBlockByNumberArgsForCall(i int) *big.Int {
	fake.getBlockByNumberMutex.RLock()
	defer fake.getBlockByNumberMutex.RUnlock()
	argsForCall := fake.getBlockByNumberArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRPC) GetBlockByNumberReturns(result1 *node.Block, result2 error) {
	fake.getBlockByNumberMutex.Lock()
	defer fake.getBlockByNumberMutex.Unlock()
	fake.GetBlockByNumberStub = nil
	fake.getBlockByNumberReturns = struct {
		result1 *node.Block
		result2 error
	}{result1, result2}
}

func (fake *FakeRPC) GetBlockByNumberReturnsOnCall(i int, result1 *node.Block, result2 error) {
	fake.getBlockByNumberMutex.Lock()
	defer fake.getBlockByNumberMutex.Unlock()
	fake.GetBlockByNumberStub = nil
	if fake.getBlockByNumberReturnsOnCall == nil {
		fake.getBlockByNumberReturnsOnCall = make(map[int]struct {
			result1 *node.Block
			result2 error
		})
	}
	fake.getBlockByNumberReturnsOnCall[i] = struct {
		result1 *node.Block
		result2 error
	}{result1, result2}
}

func (fake *FakeRPC) GetBlockNumber() (*big.Int, error) {
	fake.getBlockNumberMutex.Lock()
	ret, specificReturn := fake.getBlockNumberReturnsOnCall[len(fake.getBlockNumberArgsForCall)]
	fake.getBlockNumberArgsForCall = append(fake.getBlockNumberArgsForCall, struct {
	}{})
	stub := fake.GetBlockNumberStub
	fakeReturns := fake.getBlockNumberReturns
	fake.recordInvocation("GetBlockNumber", []interface{}{})
	fake.getBlockNumberMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRPC) GetBlockNumberCallCount() int {
	fake.getBlockNumberMutex.RLock()
	defer fake.getBlockNumberMutex.RUnlock()
	return len(fake.getBlockNumberArgsForCall)
}

func (fake *FakeRPC) GetBlockNumberCalls(stub func() (*big.Int, error)) {
	fake.getBlockNumberMutex.Lock()
	defer fake.getBlockNumberMutex.Unlock()
	fake.GetBlockNumberStub = stub
}

func (fake *FakeRPC) GetBlockNumberReturns(result1 *big.Int, result2 error) {
	fake.getBlockNumberMutex.Lock()
	defer fake.getBlockNumberMutex.Unlock()
	fake.GetBlockNumberStub = nil
	fake.getBlockNumberReturns = struct {
		result1 *big.Int
		result2 error
	}{result1, result2}
}

func (fake *FakeRPC) GetBlockNumberReturnsOnCall(i int, result1 *big.Int, result2 error) {
	fake.getBlockNumberMutex.Lock()
	defer fake.getBlockNumberMutex.Unlock()
	fake.GetBlockNumberStub = nil
	if fake.getBlockNumberReturnsOnCall == nil {
		fake.getBlockNumberReturnsOnCall = make(map[int]struct {
			result1 *big.Int
			result2 error
		})
	}
	fake.getBlockNumberReturnsOnCall[i] = struct {
		result1 *big.Int
		result2 error
	}{result1, result2}
}

func (fake *FakeRPC) GetLatestBlock() (*node.Block, error) {
	fake.getLatestBlockMutex.Lock()
	ret, specificReturn := fake.getLatestBlockReturnsOnCall[len(fake.getLatestBlockArgsForCall)]
	fake.getLatestBlockArgsForCall = append(fake.getLatestBlockArgsForCall, struct {
	}{})
	stub := fake.GetLatestBlockStub
	fakeReturns := fake.getLatestBlockReturns
	fake.recordInvocation("GetLatestBlock", []interface{}{})
	fake.getLatestBlockMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRPC) GetLatestBlockCallCount() int {
	fake.getLatestBlockMutex.RLock()
	defer fake.getLatestBlockMutex.RUnlock()
	return len(fake.getLatestBlockArgsForCall)
}

func (fake *FakeRPC) GetLatestBlockCalls(stub func() (*node.Block, error)) {
	fake.getLatestBlockMutex.Lock()
	defer fake.getLatestBlockMutex.Unlock()
	fake.GetLatestBlockStub = stub
}

func (fake *FakeRPC) GetLatestBlockReturns(result1 *node.Block, result2 error) {
	fake.getLatestBlockMutex.Lock()
	defer fake.getLatestBlockMutex.Unlock()
	fake.GetLatestBlockStub = nil
	fake.getLatestBlockReturns = struct {
		result1 *node.Block
		result2 error
	}{result1, result2}
}

func (fake *FakeRPC) GetLatestBlockReturnsOnCall(i int, result1 *node.Block, result2 error) {
	fake.getLatestBlockMutex.Lock()
	defer fake.getLatestBlockMutex.Unlock()
	fake.GetLatestBlockStub = nil
	if fake.getLatestBlockReturnsOnCall == nil {
		fake.getLatestBlockReturnsOnCall = make(map[int]struct {
			result1 *node.Block
			result2 error
		})
	}
	fake.getLatestBlockReturnsOnCall[i] = struct {
		result1 *node.Block
		result2 error
	}{result1, result2}
}

func (fake *FakeRPC) GetLogs(arg1 *ethereum.FilterQuery) ([]*types.Log, error) {
	fake.getLogsMutex.Lock()
	ret, specificReturn := fake.getLogsReturnsOnCall[len(fake.getLogsArgsForCall)]
	fake.getLogsArgsForCall = append(fake.getLogsArgsForCall, struct {
		arg1 *ethereum.FilterQuery
	}{arg1})
	stub := fake.GetLogsStub
	fakeReturns := fake.getLogsReturns
	fake.recordInvocation("GetLogs", []interface{}{arg1})
	fake.getLogsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRPC) GetLogsCallCount() int {
	fake.getLogsMutex.RLock()
	defer fake.getLogsMutex.RUnlock()
	return len(fake.getLogsArgsForCall)
}

func (fake *FakeRPC) GetLogsCalls(stub func(*ethereum.FilterQuery) ([]*types.Log, error)) {
	fake.getLogsMutex.Lock()
	defer fake.getLogsMutex.Unlock()
	fake.GetLogsStub = stub
}

func (fake *FakeRPC) GetLogsArgsForCall(i int) *ethereum.FilterQuery {
	fake.getLogsMutex.RLock()
	defer fake.getLogsMutex.RUnlock()
	argsForCall := fake.getLogsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRPC) GetLogsReturns(result1 []*types.Log, result2 error) {
	fake.getLogsMutex.Lock()
	defer fake.getLogsMutex.Unlock()
	fake.GetLogsStub = nil
	fake.getLogsReturns = struct {
		result1 []*types.Log
		result2 error
	}{result1, result2}
}

func (fake *FakeRPC) GetLogsReturnsOnCall(i int, result1 []*types.Log, result2 error) {
	fake.getLogsMutex.Lock()
	defer fake.getLogsMutex.Unlock()
	fake.GetLogsStub = nil
	if fake.getLogsReturnsOnCall == nil {
		fake.getLogsReturnsOnCall = make(map[int]struct {
			result1 []*types.Log
			result2 error
		})
	}
	fake.getLogsReturnsOnCall[i] = struct {
		result1 []*types.Log
		result2 error
	}{result1, result2}
}

func (fake *FakeRPC) GetPayloadV1(arg1 *node.PayloadID) (*engine_types.ExecutionPayload, error) {
	fake.getPayloadV1Mutex.Lock()
	ret, specificReturn := fake.getPayloadV1ReturnsOnCall[len(fake.getPayloadV1ArgsForCall)]
	fake.getPayloadV1ArgsForCall = append(fake.getPayloadV1ArgsForCall, struct {
		arg1 *node.PayloadID
	}{arg1})
	stub := fake.GetPayloadV1Stub
	fakeReturns := fake.getPayloadV1Returns
	fake.recordInvocation("GetPayloadV1", []interface{}{arg1})
	fake.getPayloadV1Mutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRPC) GetPayloadV1CallCount() int {
	fake.getPayloadV1Mutex.RLock()
	defer fake.getPayloadV1Mutex.RUnlock()
	return len(fake.getPayloadV1ArgsForCall)
}

func (fake *FakeRPC) GetPayloadV1Calls(stub func(*node.PayloadID) (*engine_types.ExecutionPayload, error)) {
	fake.getPayloadV1Mutex.Lock()
	defer fake.getPayloadV1Mutex.Unlock()
	fake.GetPayloadV1Stub = stub
}

func (fake *FakeRPC) GetPayloadV1ArgsForCall(i int) *node.PayloadID {
	fake.getPayloadV1Mutex.RLock()
	defer fake.getPayloadV1Mutex.RUnlock()
	argsForCall := fake.getPayloadV1ArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRPC) GetPayloadV1Returns(result1 *engine_types.ExecutionPayload, result2 error) {
	fake.getPayloadV1Mutex.Lock()
	defer fake.getPayloadV1Mutex.Unlock()
	fake.GetPayloadV1Stub = nil
	fake.getPayloadV1Returns = struct {
		result1 *engine_types.ExecutionPayload
		result2 error
	}{result1, result2}
}

func (fake *FakeRPC) GetPayloadV1ReturnsOnCall(i int, result1 *engine_types.ExecutionPayload, result2 error) {
	fake.getPayloadV1Mutex.Lock()
	defer fake.getPayloadV1Mutex.Unlock()
	fake.GetPayloadV1Stub = nil
	if fake.getPayloadV1ReturnsOnCall == nil {
		fake.getPayloadV1ReturnsOnCall = make(map[int]struct {
			result1 *engine_types.ExecutionPayload
			result2 error
		})
	}
	fake.getPayloadV1ReturnsOnCall[i] = struct {
		result1 *engine_types.ExecutionPayload
		result2 error
	}{result1, result2}
}

func (fake *FakeRPC) GetTransactionByHash(arg1 *common.Hash) (types.Transaction, error) {
	fake.getTransactionByHashMutex.Lock()
	ret, specificReturn := fake.getTransactionByHashReturnsOnCall[len(fake.getTransactionByHashArgsForCall)]
	fake.getTransactionByHashArgsForCall = append(fake.getTransactionByHashArgsForCall, struct {
		arg1 *common.Hash
	}{arg1})
	stub := fake.GetTransactionByHashStub
	fakeReturns := fake.getTransactionByHashReturns
	fake.recordInvocation("GetTransactionByHash", []interface{}{arg1})
	fake.getTransactionByHashMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRPC) GetTransactionByHashCallCount() int {
	fake.getTransactionByHashMutex.RLock()
	defer fake.getTransactionByHashMutex.RUnlock()
	return len(fake.getTransactionByHashArgsForCall)
}

func (fake *FakeRPC) GetTransactionByHashCalls(stub func(*common.Hash) (types.Transaction, error)) {
	fake.getTransactionByHashMutex.Lock()
	defer fake.getTransactionByHashMutex.Unlock()
	fake.GetTransactionByHashStub = stub
}

func (fake *FakeRPC) GetTransactionByHashArgsForCall(i int) *common.Hash {
	fake.getTransactionByHashMutex.RLock()
	defer fake.getTransactionByHashMutex.RUnlock()
	argsForCall := fake.getTransactionByHashArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRPC) GetTransactionByHashReturns(result1 types.Transaction, result2 error) {
	fake.getTransactionByHashMutex.Lock()
	defer fake.getTransactionByHashMutex.Unlock()
	fake.GetTransactionByHashStub = nil
	fake.getTransactionByHashReturns = struct {
		result1 types.Transaction
		result2 error
	}{result1, result2}
}

func (fake *FakeRPC) GetTransactionByHashReturnsOnCall(i int, result1 types.Transaction, result2 error) {
	fake.getTransactionByHashMutex.Lock()
	defer fake.getTransactionByHashMutex.Unlock()
	fake.GetTransactionByHashStub = nil
	if fake.getTransactionByHashReturnsOnCall == nil {
		fake.getTransactionByHashReturnsOnCall = make(map[int]struct {
			result1 types.Transaction
			result2 error
		})
	}
	fake.getTransactionByHashReturnsOnCall[i] = struct {
		result1 types.Transaction
		result2 error
	}{result1, result2}
}

func (fake *FakeRPC) NewPayloadV1(arg1 *engine_types.ExecutionPayload) (*node.PayloadStatusV1, error) {
	fake.newPayloadV1Mutex.Lock()
	ret, specificReturn := fake.newPayloadV1ReturnsOnCall[len(fake.newPayloadV1ArgsForCall)]
	fake.newPayloadV1ArgsForCall = append(fake.newPayloadV1ArgsForCall, struct {
		arg1 *engine_types.ExecutionPayload
	}{arg1})
	stub := fake.NewPayloadV1Stub
	fakeReturns := fake.newPayloadV1Returns
	fake.recordInvocation("NewPayloadV1", []interface{}{arg1})
	fake.newPayloadV1Mutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRPC) NewPayloadV1CallCount() int {
	fake.newPayloadV1Mutex.RLock()
	defer fake.newPayloadV1Mutex.RUnlock()
	return len(fake.newPayloadV1ArgsForCall)
}

func (fake *FakeRPC) NewPayloadV1Calls(stub func(*engine_types.ExecutionPayload) (*node.PayloadStatusV1, error)) {
	fake.newPayloadV1Mutex.Lock()
	defer fake.newPayloadV1Mutex.Unlock()
	fake.NewPayloadV1Stub = stub
}

func (fake *FakeRPC) NewPayloadV1ArgsForCall(i int) *engine_types.ExecutionPayload {
	fake.newPayloadV1Mutex.RLock()
	defer fake.newPayloadV1Mutex.RUnlock()
	argsForCall := fake.newPayloadV1ArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRPC) NewPayloadV1Returns(result1 *node.PayloadStatusV1, result2 error) {
	fake.newPayloadV1Mutex.Lock()
	defer fake.newPayloadV1Mutex.Unlock()
	fake.NewPayloadV1Stub = nil
	fake.newPayloadV1Returns = struct {
		result1 *node.PayloadStatusV1
		result2 error
	}{result1, result2}
}

func (fake *FakeRPC) NewPayloadV1ReturnsOnCall(i int, result1 *node.PayloadStatusV1, result2 error) {
	fake.newPayloadV1Mutex.Lock()
	defer fake.newPayloadV1Mutex.Unlock()
	fake.NewPayloadV1Stub = nil
	if fake.newPayloadV1ReturnsOnCall == nil {
		fake.newPayloadV1ReturnsOnCall = make(map[int]struct {
			result1 *node.PayloadStatusV1
			result2 error
		})
	}
	fake.newPayloadV1ReturnsOnCall[i] = struct {
		result1 *node.PayloadStatusV1
		result2 error
	}{result1, result2}
}

func (fake *FakeRPC) SetHeader(arg1 string, arg2 string) {
	fake.setHeaderMutex.Lock()
	fake.setHeaderArgsForCall = append(fake.setHeaderArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.SetHeaderStub
	fake.recordInvocation("SetHeader", []interface{}{arg1, arg2})
	fake.setHeaderMutex.Unlock()
	if stub != nil {
		fake.SetHeaderStub(arg1, arg2)
	}
}

func (fake *FakeRPC) SetHeaderCallCount() int {
	fake.setHeaderMutex.RLock()
	defer fake.setHeaderMutex.RUnlock()
	return len(fake.setHeaderArgsForCall)
}

func (fake *FakeRPC) SetHeaderCalls(stub func(string, string)) {
	fake.setHeaderMutex.Lock()
	defer fake.setHeaderMutex.Unlock()
	fake.SetHeaderStub = stub
}

func (fake *FakeRPC) SetHeaderArgsForCall(i int) (string, string) {
	fake.setHeaderMutex.RLock()
	defer fake.setHeaderMutex.RUnlock()
	argsForCall := fake.setHeaderArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRPC) SetJWTAuth(arg1 *[32]byte) error {
	fake.setJWTAuthMutex.Lock()
	ret, specificReturn := fake.setJWTAuthReturnsOnCall[len(fake.setJWTAuthArgsForCall)]
	fake.setJWTAuthArgsForCall = append(fake.setJWTAuthArgsForCall, struct {
		arg1 *[32]byte
	}{arg1})
	stub := fake.SetJWTAuthStub
	fakeReturns := fake.setJWTAuthReturns
	fake.recordInvocation("SetJWTAuth", []interface{}{arg1})
	fake.setJWTAuthMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRPC) SetJWTAuthCallCount() int {
	fake.setJWTAuthMutex.RLock()
	defer fake.setJWTAuthMutex.RUnlock()
	return len(fake.setJWTAuthArgsForCall)
}

func (fake *FakeRPC) SetJWTAuthCalls(stub func(*[32]byte) error) {
	fake.setJWTAuthMutex.Lock()
	defer fake.setJWTAuthMutex.Unlock()
	fake.SetJWTAuthStub = stub
}

func (fake *FakeRPC) SetJWTAuthArgsForCall(i int) *[32]byte {
	fake.setJWTAuthMutex.RLock()
	defer fake.setJWTAuthMutex.RUnlock()
	argsForCall := fake.setJWTAuthArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRPC) SetJWTAuthReturns(result1 error) {
	fake.setJWTAuthMutex.Lock()
	defer fake.setJWTAuthMutex.Unlock()
	fake.SetJWTAuthStub = nil
	fake.setJWTAuthReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRPC) SetJWTAuthReturnsOnCall(i int, result1 error) {
	fake.setJWTAuthMutex.Lock()
	defer fake.setJWTAuthMutex.Unlock()
	fake.SetJWTAuthStub = nil
	if fake.setJWTAuthReturnsOnCall == nil {
		fake.setJWTAuthReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setJWTAuthReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRPC) TraceTransaction(arg1 *common.Hash) (*node.TraceTransaction, error) {
	fake.traceTransactionMutex.Lock()
	ret, specificReturn := fake.traceTransactionReturnsOnCall[len(fake.traceTransactionArgsForCall)]
	fake.traceTransactionArgsForCall = append(fake.traceTransactionArgsForCall, struct {
		arg1 *common.Hash
	}{arg1})
	stub := fake.TraceTransactionStub
	fakeReturns := fake.traceTransactionReturns
	fake.recordInvocation("TraceTransaction", []interface{}{arg1})
	fake.traceTransactionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRPC) TraceTransactionCallCount() int {
	fake.traceTransactionMutex.RLock()
	defer fake.traceTransactionMutex.RUnlock()
	return len(fake.traceTransactionArgsForCall)
}

func (fake *FakeRPC) TraceTransactionCalls(stub func(*common.Hash) (*node.TraceTransaction, error)) {
	fake.traceTransactionMutex.Lock()
	defer fake.traceTransactionMutex.Unlock()
	fake.TraceTransactionStub = stub
}

func (fake *FakeRPC) TraceTransactionArgsForCall(i int) *common.Hash {
	fake.traceTransactionMutex.RLock()
	defer fake.traceTransactionMutex.RUnlock()
	argsForCall := fake.traceTransactionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRPC) TraceTransactionReturns(result1 *node.TraceTransaction, result2 error) {
	fake.traceTransactionMutex.Lock()
	defer fake.traceTransactionMutex.Unlock()
	fake.TraceTransactionStub = nil
	fake.traceTransactionReturns = struct {
		result1 *node.TraceTransaction
		result2 error
	}{result1, result2}
}

func (fake *FakeRPC) TraceTransactionReturnsOnCall(i int, result1 *node.TraceTransaction, result2 error) {
	fake.traceTransactionMutex.Lock()
	defer fake.traceTransactionMutex.Unlock()
	fake.TraceTransactionStub = nil
	if fake.traceTransactionReturnsOnCall == nil {
		fake.traceTransactionReturnsOnCall = make(map[int]struct {
			result1 *node.TraceTransaction
			result2 error
		})
	}
	fake.traceTransactionReturnsOnCall[i] = struct {
		result1 *node.TraceTransaction
		result2 error
	}{result1, result2}
}

func (fake *FakeRPC) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.forkchoiceUpdateV1Mutex.RLock()
	defer fake.forkchoiceUpdateV1Mutex.RUnlock()
	fake.getBlockByNumberMutex.RLock()
	defer fake.getBlockByNumberMutex.RUnlock()
	fake.getBlockNumberMutex.RLock()
	defer fake.getBlockNumberMutex.RUnlock()
	fake.getLatestBlockMutex.RLock()
	defer fake.getLatestBlockMutex.RUnlock()
	fake.getLogsMutex.RLock()
	defer fake.getLogsMutex.RUnlock()
	fake.getPayloadV1Mutex.RLock()
	defer fake.getPayloadV1Mutex.RUnlock()
	fake.getTransactionByHashMutex.RLock()
	defer fake.getTransactionByHashMutex.RUnlock()
	fake.newPayloadV1Mutex.RLock()
	defer fake.newPayloadV1Mutex.RUnlock()
	fake.setHeaderMutex.RLock()
	defer fake.setHeaderMutex.RUnlock()
	fake.setJWTAuthMutex.RLock()
	defer fake.setJWTAuthMutex.RUnlock()
	fake.traceTransactionMutex.RLock()
	defer fake.traceTransactionMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRPC) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ node.RPC = new(FakeRPC)
