{
  "language": "Solidity",
  "sources": {
    "contracts/L1/L1CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { OptimismPortal } from \"./OptimismPortal.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @title L1CrossDomainMessenger\n * @notice The L1CrossDomainMessenger is a message passing interface between L1 and L2 responsible\n *         for sending and receiving data on the L1 side. Users are encouraged to use this\n *         interface instead of interacting with lower-level contracts directly.\n */\ncontract L1CrossDomainMessenger is CrossDomainMessenger, Semver {\n    /**\n     * @notice Address of the OptimismPortal.\n     */\n    OptimismPortal public immutable portal;\n\n    /**\n     * @custom:semver 0.0.1\n     *\n     * @param _portal Address of the OptimismPortal contract on this network.\n     */\n    constructor(OptimismPortal _portal) Semver(0, 0, 1) {\n        portal = _portal;\n        initialize();\n    }\n\n    /**\n     * @notice Initializer.\n     */\n    function initialize() public initializer {\n        address[] memory blockedSystemAddresses = new address[](1);\n        blockedSystemAddresses[0] = address(this);\n        __CrossDomainMessenger_init(Predeploys.L2_CROSS_DOMAIN_MESSENGER, blockedSystemAddresses);\n    }\n\n    /**\n     * @notice Sends a message via the OptimismPortal contract.\n     *\n     * @param _to       Address of the recipient on L2.\n     * @param _gasLimit Minimum gas limit that the message can be executed with.\n     * @param _value    ETH value to attach to the message and send to the recipient.\n     * @param _data     Data to attach to the message and call the recipient with.\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal override {\n        portal.depositTransaction{ value: _value }(_to, _value, _gasLimit, false, _data);\n    }\n\n    /**\n     * @notice Checks whether the message being sent from the other messenger.\n     *\n     * @return True if the message was sent from the messenger, false otherwise.\n     */\n    function _isOtherMessenger() internal view override returns (bool) {\n        return msg.sender == address(portal) && portal.l2Sender() == otherMessenger;\n    }\n}\n"
    },
    "contracts/L1/L1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @title L1StandardBridge\n * @notice The L1StandardBridge is responsible for transfering ETH and ERC20 tokens between L1 and\n *         L2. ERC20 tokens deposited into L2 are escrowed within this contract until withdrawal.\n *         ETH is transferred to and escrowed within the OptimismPortal contract.\n */\ncontract L1StandardBridge is StandardBridge, Semver {\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever a deposit of ETH from L1 into L2 is initiated.\n     *\n     * @param from      Address of the depositor.\n     * @param to        Address of the recipient on L2.\n     * @param amount    Amount of ETH deposited.\n     * @param extraData Extra data attached to the deposit.\n     */\n    event ETHDepositInitiated(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever a withdrawal of ETH from L2 to L1 is finalized.\n     *\n     * @param from      Address of the withdrawer.\n     * @param to        Address of the recipient on L1.\n     * @param amount    Amount of ETH withdrawn.\n     * @param extraData Extra data attached to the withdrawal.\n     */\n    event ETHWithdrawalFinalized(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever an ERC20 deposit is initiated.\n     *\n     * @param l1Token   Address of the token on L1.\n     * @param l2Token   Address of the corresponding token on L2.\n     * @param from      Address of the depositor.\n     * @param to        Address of the recipient on L2.\n     * @param amount    Amount of the ERC20 deposited.\n     * @param extraData Extra data attached to the deposit.\n     */\n    event ERC20DepositInitiated(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever an ERC20 withdrawal is finalized.\n     *\n     * @param l1Token   Address of the token on L1.\n     * @param l2Token   Address of the corresponding token on L2.\n     * @param from      Address of the withdrawer.\n     * @param to        Address of the recipient on L1.\n     * @param amount    Amount of the ERC20 withdrawn.\n     * @param extraData Extra data attached to the withdrawal.\n     */\n    event ERC20WithdrawalFinalized(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @custom:semver 0.0.2\n     *\n     * @param _messenger Address of the L1CrossDomainMessenger.\n     */\n    constructor(address payable _messenger)\n        Semver(0, 0, 2)\n        StandardBridge(_messenger, payable(Predeploys.L2_STANDARD_BRIDGE))\n    {}\n\n    /**\n     * @custom:legacy\n     * @notice Finalizes a withdrawal of ERC20 tokens from L2.\n     *\n     * @param _l1Token   Address of the token on L1.\n     * @param _l2Token   Address of the corresponding token on L2.\n     * @param _from      Address of the withdrawer on L2.\n     * @param _to        Address of the recipient on L1.\n     * @param _amount    Amount of ETH to withdraw.\n     * @param _extraData Optional data forwarded from L2.\n     */\n    function finalizeERC20Withdrawal(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) external onlyOtherBridge {\n        emit ERC20WithdrawalFinalized(_l1Token, _l2Token, _from, _to, _amount, _extraData);\n        finalizeBridgeERC20(_l1Token, _l2Token, _from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Deposits some amount of ETH into the sender's account on L2.\n     *\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\n     *                     execute any code on L2 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function depositETH(uint32 _minGasLimit, bytes calldata _extraData) external payable onlyEOA {\n        _initiateETHDeposit(msg.sender, msg.sender, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Deposits some amount of ETH into a target account on L2.\n     *         Note that if ETH is sent to a contract on L2 and the call fails, then that ETH will\n     *         be locked in the L2StandardBridge. ETH may be recoverable if the call can be\n     *         successfully replayed by increasing the amount of gas supplied to the call. If the\n     *         call will fail for any amount of gas, then the ETH will be locked permanently.\n     *\n     * @param _to          Address of the recipient on L2.\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\n     *                     execute any code on L2 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function depositETHTo(\n        address _to,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external payable {\n        _initiateETHDeposit(msg.sender, _to, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Deposits some amount of ERC20 tokens into the sender's account on L2.\n     *\n     * @param _l1Token     Address of the L1 token being deposited.\n     * @param _l2Token     Address of the corresponding token on L2.\n     * @param _amount      Amount of the ERC20 to deposit.\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\n     *                     execute any code on L2 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function depositERC20(\n        address _l1Token,\n        address _l2Token,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external virtual onlyEOA {\n        _initiateERC20Deposit(\n            _l1Token,\n            _l2Token,\n            msg.sender,\n            msg.sender,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Deposits some amount of ERC20 tokens into a target account on L2.\n     *\n     * @param _l1Token     Address of the L1 token being deposited.\n     * @param _l2Token     Address of the corresponding token on L2.\n     * @param _to          Address of the recipient on L2.\n     * @param _amount      Amount of the ERC20 to deposit.\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\n     *                     execute any code on L2 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external virtual {\n        _initiateERC20Deposit(\n            _l1Token,\n            _l2Token,\n            msg.sender,\n            _to,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Finalizes a withdrawal of ETH from L2.\n     *\n     * @param _from      Address of the withdrawer on L2.\n     * @param _to        Address of the recipient on L1.\n     * @param _amount    Amount of ETH to withdraw.\n     * @param _extraData Optional data forwarded from L2.\n     */\n    function finalizeETHWithdrawal(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) external payable onlyOtherBridge {\n        emit ETHWithdrawalFinalized(_from, _to, _amount, _extraData);\n        finalizeBridgeETH(_from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Retrieves the access of the corresponding L2 bridge contract.\n     *\n     * @return Address of the corresponding L2 bridge contract.\n     */\n    function l2TokenBridge() external view returns (address) {\n        return address(otherBridge);\n    }\n\n    /**\n     * @notice Internal function for initiating an ETH deposit.\n     *\n     * @param _from        Address of the sender on L1.\n     * @param _to          Address of the recipient on L2.\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\n     * @param _extraData   Optional data to forward to L2.\n     */\n    function _initiateETHDeposit(\n        address _from,\n        address _to,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal {\n        emit ETHDepositInitiated(_from, _to, msg.value, _extraData);\n        _initiateBridgeETH(_from, _to, msg.value, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @notice Internal function for initiating an ERC20 deposit.\n     *\n     * @param _l1Token     Address of the L1 token being deposited.\n     * @param _l2Token     Address of the corresponding token on L2.\n     * @param _from        Address of the sender on L1.\n     * @param _to          Address of the recipient on L2.\n     * @param _amount      Amount of the ERC20 to deposit.\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\n     * @param _extraData   Optional data to forward to L2.\n     */\n    function _initiateERC20Deposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal {\n        emit ERC20DepositInitiated(_l1Token, _l2Token, _from, _to, _amount, _extraData);\n        _initiateBridgeERC20(_l1Token, _l2Token, _from, _to, _amount, _minGasLimit, _extraData);\n    }\n}\n"
    },
    "contracts/L1/L2OutputOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { Types } from \"../libraries/Types.sol\";\n\n/**\n * @custom:proxied\n * @title L2OutputOracle\n * @notice The L2 state is committed to in this contract\n *         The payable keyword is used on proposeL2Output to save gas on the msg.value check.\n *         This contract should be deployed behind an upgradable proxy\n */\n// slither-disable-next-line locked-ether\ncontract L2OutputOracle is OwnableUpgradeable, Semver {\n    /**\n     * @notice The interval in L2 blocks at which checkpoints must be submitted.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    uint256 public immutable SUBMISSION_INTERVAL;\n\n    /**\n     * @notice The number of blocks in the chain before the first block in this contract.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    uint256 public immutable HISTORICAL_TOTAL_BLOCKS;\n\n    /**\n     * @notice The number of the first L2 block recorded in this contract.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    uint256 public immutable STARTING_BLOCK_NUMBER;\n\n    /**\n     * @notice The timestamp of the first L2 block recorded in this contract.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    uint256 public immutable STARTING_TIMESTAMP;\n\n    /**\n     * @notice The time between L2 blocks in seconds.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    uint256 public immutable L2_BLOCK_TIME;\n\n    /**\n     * @notice The address of the proposer;\n     */\n    address public proposer;\n\n    /**\n     * @notice The number of the most recent L2 block recorded in this contract.\n     */\n    uint256 public latestBlockNumber;\n\n    /**\n     * @notice A mapping from L2 block numbers to the respective output root. Note that these\n     *         outputs should not be considered finalized until the finalization period (as defined\n     *         in the Optimism Portal) has passed.\n     */\n    mapping(uint256 => Types.OutputProposal) internal l2Outputs;\n\n    /**\n     * @notice Emitted when an output is proposed.\n     *\n     * @param outputRoot    The output root.\n     * @param l1Timestamp   The L1 timestamp when proposed.\n     * @param l2BlockNumber The L2 block number of the output root.\n     */\n    event OutputProposed(\n        bytes32 indexed outputRoot,\n        uint256 indexed l1Timestamp,\n        uint256 indexed l2BlockNumber\n    );\n\n    /**\n     * @notice Emitted when an output is deleted.\n     *\n     * @param outputRoot    The output root.\n     * @param l1Timestamp   The L1 timestamp when proposed.\n     * @param l2BlockNumber The L2 block number of the output root.\n     */\n    event OutputDeleted(\n        bytes32 indexed outputRoot,\n        uint256 indexed l1Timestamp,\n        uint256 indexed l2BlockNumber\n    );\n\n    /**\n     * @notice Emitted when the proposer address is changed.\n     *\n     * @param previousProposer The previous proposer address.\n     * @param newProposer      The new proposer address.\n     */\n    event ProposerChanged(address indexed previousProposer, address indexed newProposer);\n\n    /**\n     * @notice Reverts if called by any account other than the proposer.\n     */\n    modifier onlyProposer() {\n        require(proposer == msg.sender, \"L2OutputOracle: function can only be called by proposer\");\n        _;\n    }\n\n    /**\n     * @custom:semver 0.0.1\n     *\n     * @param _submissionInterval    Interval in blocks at which checkpoints must be submitted.\n     * @param _genesisL2Output       The initial L2 output of the L2 chain.\n     * @param _historicalTotalBlocks Number of blocks preceding this L2 chain.\n     * @param _startingBlockNumber   The number of the first L2 block.\n     * @param _startingTimestamp     The timestamp of the first L2 block.\n     * @param _l2BlockTime           The time per L2 block, in seconds.\n     * @param _proposer              The address of the proposer.\n     * @param _owner                 The address of the owner.\n     */\n    constructor(\n        uint256 _submissionInterval,\n        bytes32 _genesisL2Output,\n        uint256 _historicalTotalBlocks,\n        uint256 _startingBlockNumber,\n        uint256 _startingTimestamp,\n        uint256 _l2BlockTime,\n        address _proposer,\n        address _owner\n    ) Semver(0, 0, 1) {\n        require(\n            _l2BlockTime < block.timestamp,\n            \"L2OutputOracle: initial L2 block time must be less than current time\"\n        );\n\n        SUBMISSION_INTERVAL = _submissionInterval;\n        HISTORICAL_TOTAL_BLOCKS = _historicalTotalBlocks;\n        STARTING_BLOCK_NUMBER = _startingBlockNumber;\n        STARTING_TIMESTAMP = _startingTimestamp;\n        L2_BLOCK_TIME = _l2BlockTime;\n\n        initialize(_genesisL2Output, _startingBlockNumber, _proposer, _owner);\n    }\n\n    /**\n     * @notice Deletes the most recent output. This is used to remove the most recent output in the\n     *         event that an erreneous output is submitted. It can only be called by the contract's\n     *         owner, not the proposer. Longer term, this should be replaced with a more robust\n     *         mechanism which will allow deletion of proposals shown to be invalid by a fault\n     *         proof.\n     *\n     * @param _proposal Represents the output proposal to delete\n     */\n    function deleteL2Output(Types.OutputProposal memory _proposal) external onlyOwner {\n        Types.OutputProposal memory outputToDelete = l2Outputs[latestBlockNumber];\n\n        require(\n            _proposal.outputRoot == outputToDelete.outputRoot,\n            \"L2OutputOracle: output root to delete does not match the latest output proposal\"\n        );\n\n        require(\n            _proposal.timestamp == outputToDelete.timestamp,\n            \"L2OutputOracle: timestamp to delete does not match the latest output proposal\"\n        );\n\n        emit OutputDeleted(outputToDelete.outputRoot, outputToDelete.timestamp, latestBlockNumber);\n\n        delete l2Outputs[latestBlockNumber];\n        latestBlockNumber = latestBlockNumber - SUBMISSION_INTERVAL;\n    }\n\n    /**\n     * @notice Accepts an outputRoot and the timestamp of the corresponding L2 block. The\n     *         timestamp must be equal to the current value returned by `nextTimestamp()` in order\n     *         to be accepted. This function may only be called by the Proposer.\n     *\n     * @param _outputRoot    The L2 output of the checkpoint block.\n     * @param _l2BlockNumber The L2 block number that resulted in _outputRoot.\n     * @param _l1Blockhash   A block hash which must be included in the current chain.\n     * @param _l1BlockNumber The block number with the specified block hash.\n     */\n    function proposeL2Output(\n        bytes32 _outputRoot,\n        uint256 _l2BlockNumber,\n        bytes32 _l1Blockhash,\n        uint256 _l1BlockNumber\n    ) external payable onlyProposer {\n        require(\n            _l2BlockNumber == nextBlockNumber(),\n            \"L2OutputOracle: block number must be equal to next expected block number\"\n        );\n\n        require(\n            computeL2Timestamp(_l2BlockNumber) < block.timestamp,\n            \"L2OutputOracle: cannot propose L2 output in the future\"\n        );\n\n        require(\n            _outputRoot != bytes32(0),\n            \"L2OutputOracle: L2 output proposal cannot be the zero hash\"\n        );\n\n        if (_l1Blockhash != bytes32(0)) {\n            // This check allows the proposer to propose an output based on a given L1 block,\n            // without fear that it will be reorged out.\n            // It will also revert if the blockheight provided is more than 256 blocks behind the\n            // chain tip (as the hash will return as zero). This does open the door to a griefing\n            // attack in which the proposer's submission is censored until the block is no longer\n            // retrievable, if the proposer is experiencing this attack it can simply leave out the\n            // blockhash value, and delay submission until it is confident that the L1 block is\n            // finalized.\n            require(\n                blockhash(_l1BlockNumber) == _l1Blockhash,\n                \"L2OutputOracle: blockhash does not match the hash at the expected height\"\n            );\n        }\n\n        l2Outputs[_l2BlockNumber] = Types.OutputProposal(_outputRoot, block.timestamp);\n        latestBlockNumber = _l2BlockNumber;\n\n        emit OutputProposed(_outputRoot, block.timestamp, _l2BlockNumber);\n    }\n\n    /**\n     * @notice Returns the L2 output proposal associated with a target L2 block number. If the\n     *         L2 block number provided is between checkpoints, this function will rerutn the next\n     *         proposal for the next checkpoint.\n     *         Reverts if the output proposal is either not found, or predates\n     *         the STARTING_BLOCK_NUMBER.\n     *\n     * @param _l2BlockNumber The L2 block number of the target block.\n     */\n    function getL2Output(uint256 _l2BlockNumber)\n        external\n        view\n        returns (Types.OutputProposal memory)\n    {\n        require(\n            _l2BlockNumber >= STARTING_BLOCK_NUMBER,\n            \"L2OutputOracle: block number cannot be less than the starting block number.\"\n        );\n\n        // Find the distance between _l2BlockNumber, and the checkpoint block before it.\n        uint256 offset = (_l2BlockNumber - STARTING_BLOCK_NUMBER) % SUBMISSION_INTERVAL;\n\n        // If the offset is zero, then the _l2BlockNumber should be checkpointed.\n        // Otherwise, we'll look up the next block that will be checkpointed.\n        uint256 lookupBlockNumber = offset == 0\n            ? _l2BlockNumber\n            : _l2BlockNumber + (SUBMISSION_INTERVAL - offset);\n\n        Types.OutputProposal memory output = l2Outputs[lookupBlockNumber];\n        require(\n            output.outputRoot != bytes32(0),\n            \"L2OutputOracle: No output found for that block number.\"\n        );\n        return output;\n    }\n\n    /**\n     * @notice Initializer.\n     *\n     * @param _genesisL2Output     The initial L2 output of the L2 chain.\n     * @param _startingBlockNumber The timestamp to start L2 block at.\n     * @param _proposer            The address of the proposer.\n     * @param _owner               The address of the owner.\n     */\n    function initialize(\n        bytes32 _genesisL2Output,\n        uint256 _startingBlockNumber,\n        address _proposer,\n        address _owner\n    ) public initializer {\n        l2Outputs[_startingBlockNumber] = Types.OutputProposal(_genesisL2Output, block.timestamp);\n        latestBlockNumber = _startingBlockNumber;\n        __Ownable_init();\n        changeProposer(_proposer);\n        _transferOwnership(_owner);\n    }\n\n    /**\n     * @notice Transfers the proposer role to a new account (`newProposer`).\n     *         Can only be called by the current owner.\n     */\n    function changeProposer(address _newProposer) public onlyOwner {\n        require(\n            _newProposer != address(0),\n            \"L2OutputOracle: new proposer cannot be the zero address\"\n        );\n\n        require(\n            _newProposer != owner(),\n            \"L2OutputOracle: proposer cannot be the same as the owner\"\n        );\n\n        emit ProposerChanged(proposer, _newProposer);\n        proposer = _newProposer;\n    }\n\n    /**\n     * @notice Computes the block number of the next L2 block that needs to be checkpointed.\n     */\n    function nextBlockNumber() public view returns (uint256) {\n        return latestBlockNumber + SUBMISSION_INTERVAL;\n    }\n\n    /**\n     * @notice Returns the L2 timestamp corresponding to a given L2 block number.\n     *         Returns a null output proposal if none is found.\n     *\n     * @param _l2BlockNumber The L2 block number of the target block.\n     */\n    function computeL2Timestamp(uint256 _l2BlockNumber) public view returns (uint256) {\n        require(\n            _l2BlockNumber >= STARTING_BLOCK_NUMBER,\n            \"L2OutputOracle: block number must be greater than or equal to starting block number\"\n        );\n\n        return STARTING_TIMESTAMP + ((_l2BlockNumber - STARTING_BLOCK_NUMBER) * L2_BLOCK_TIME);\n    }\n}\n"
    },
    "contracts/L1/OptimismPortal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { L2OutputOracle } from \"./L2OutputOracle.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { SecureMerkleTrie } from \"../libraries/trie/SecureMerkleTrie.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { ResourceMetering } from \"./ResourceMetering.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @title OptimismPortal\n * @notice The OptimismPortal is a low-level contract responsible for passing messages between L1\n *         and L2. Messages sent directly to the OptimismPortal have no form of replayability.\n *         Users are encouraged to use the L1CrossDomainMessenger for a higher-level interface.\n */\ncontract OptimismPortal is Initializable, ResourceMetering, Semver {\n    /**\n     * @notice Version of the deposit event.\n     */\n    uint256 internal constant DEPOSIT_VERSION = 0;\n\n    /**\n     * @notice Value used to reset the l2Sender, this is more efficient than setting it to zero.\n     */\n    address internal constant DEFAULT_L2_SENDER = 0x000000000000000000000000000000000000dEaD;\n\n    /**\n     * @notice Minimum time (in seconds) that must elapse before a withdrawal can be finalized.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    uint256 public immutable FINALIZATION_PERIOD_SECONDS;\n\n    /**\n     * @notice Address of the L2OutputOracle.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    L2OutputOracle public immutable L2_ORACLE;\n\n    /**\n     * @notice Address of the L2 account which initiated a withdrawal in this transaction. If the\n     *         of this variable is the default L2 sender address, then we are NOT inside of a call\n     *         to finalizeWithdrawalTransaction.\n     */\n    address public l2Sender;\n\n    /**\n     * @notice The L2 gas limit set when eth is deposited using the receive() function.\n     */\n    uint64 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\n\n    /**\n     * @notice Additional gas reserved for clean up after finalizing a transaction withdrawal.\n     */\n    uint256 internal constant FINALIZE_GAS_BUFFER = 20_000;\n\n    /**\n     * @notice A list of withdrawal hashes which have been successfully finalized.\n     */\n    mapping(bytes32 => bool) public finalizedWithdrawals;\n\n    /**\n     * @notice Reserve extra slots (to to a total of 50) in the storage layout for future upgrades.\n     */\n    uint256[48] private __gap;\n\n    /**\n     * @notice Emitted when a transaction is deposited from L1 to L2. The parameters of this event\n     *         are read by the rollup node and used to derive deposit transactions on L2.\n     *\n     * @param from       Address that triggered the deposit transaction.\n     * @param to         Address that the deposit transaction is directed to.\n     * @param version    Version of this deposit transaction event.\n     * @param opaqueData ABI encoded deposit data to be parsed off-chain.\n     */\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 indexed version,\n        bytes opaqueData\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is finalized.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     * @param success        Whether the withdrawal transaction was successful.\n     */\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\n\n    /**\n     * @custom:semver 0.0.1\n     *\n     * @param _l2Oracle                  Address of the L2OutputOracle contract.\n     * @param _finalizationPeriodSeconds Output finalization time in seconds.\n     */\n    constructor(L2OutputOracle _l2Oracle, uint256 _finalizationPeriodSeconds) Semver(0, 0, 1) {\n        L2_ORACLE = _l2Oracle;\n        FINALIZATION_PERIOD_SECONDS = _finalizationPeriodSeconds;\n        initialize();\n    }\n\n    /**\n     * @notice Accepts value so that users can send ETH directly to this contract and have the\n     *         funds be deposited to their address on L2. This is intended as a convenience\n     *         function for EOAs. Contracts should call the depositTransaction() function directly\n     *         otherwise any deposited funds will be lost due to address aliasing.\n     */\n    receive() external payable {\n        depositTransaction(msg.sender, msg.value, RECEIVE_DEFAULT_GAS_LIMIT, false, bytes(\"\"));\n    }\n\n    /**\n     * @notice Finalizes a withdrawal transaction.\n     *\n     * @param _tx              Withdrawal transaction to finalize.\n     * @param _l2BlockNumber   L2 block number of the outputRoot.\n     * @param _outputRootProof Inclusion proof of the withdrawer contracts storage root.\n     * @param _withdrawalProof Inclusion proof for the given withdrawal in the withdrawer contract.\n     */\n    function finalizeWithdrawalTransaction(\n        Types.WithdrawalTransaction memory _tx,\n        uint256 _l2BlockNumber,\n        Types.OutputRootProof calldata _outputRootProof,\n        bytes calldata _withdrawalProof\n    ) external payable {\n        // Prevent nested withdrawals within withdrawals.\n        require(\n            l2Sender == DEFAULT_L2_SENDER,\n            \"OptimismPortal: can only trigger one withdrawal per transaction\"\n        );\n\n        // Prevent users from creating a deposit transaction where this address is the message\n        // sender on L2.\n        // In the context of the proxy delegate calling to this implementation,\n        // address(this) will return the address of the proxy.\n        require(\n            _tx.target != address(this),\n            \"OptimismPortal: you cannot send messages to the portal contract\"\n        );\n\n        // Get the output root. This will fail if there is no\n        // output root for the given block number.\n        Types.OutputProposal memory proposal = L2_ORACLE.getL2Output(_l2BlockNumber);\n\n        // Ensure that enough time has passed since the proposal was submitted before allowing a\n        // withdrawal. Under the assumption that the fault proof mechanism is operating correctly,\n        // we can infer that any withdrawal that has passed the finalization period must be valid\n        // and can therefore be operated on.\n        require(_isOutputFinalized(proposal), \"OptimismPortal: proposal is not yet finalized\");\n\n        // Verify that the output root can be generated with the elements in the proof.\n        require(\n            proposal.outputRoot == Hashing.hashOutputRootProof(_outputRootProof),\n            \"OptimismPortal: invalid output root proof\"\n        );\n\n        // All withdrawals have a unique hash, we'll use this as the identifier for the withdrawal\n        // and to prevent replay attacks.\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(_tx);\n\n        // Verify that the hash of this withdrawal was stored in the withdrawal contract on L2. If\n        // this is true, then we know that this withdrawal was actually triggered on L2 can can\n        // therefore be relayed on L1.\n        require(\n            _verifyWithdrawalInclusion(\n                withdrawalHash,\n                _outputRootProof.withdrawerStorageRoot,\n                _withdrawalProof\n            ),\n            \"OptimismPortal: invalid withdrawal inclusion proof\"\n        );\n\n        // Check that this withdrawal has not already been finalized, this is replay protection.\n        require(\n            finalizedWithdrawals[withdrawalHash] == false,\n            \"OptimismPortal: withdrawal has already been finalized\"\n        );\n\n        // Mark the withdrawal as finalized so it can't be replayed.\n        finalizedWithdrawals[withdrawalHash] = true;\n\n        // We want to maintain the property that the amount of gas supplied to the call to the\n        // target contract is at least the gas limit specified by the user. We can do this by\n        // enforcing that, at this point in time, we still have gaslimit + buffer gas available.\n        require(\n            gasleft() >= _tx.gasLimit + FINALIZE_GAS_BUFFER,\n            \"OptimismPortal: insufficient gas to finalize withdrawal\"\n        );\n\n        // Set the l2Sender so contracts know who triggered this withdrawal on L2.\n        l2Sender = _tx.sender;\n\n        // Trigger the call to the target contract. We use SafeCall because we don't\n        // care about the returndata and we don't want target contracts to be able to force this\n        // call to run out of gas via a returndata bomb.\n        bool success = SafeCall.call(_tx.target, _tx.gasLimit, _tx.value, _tx.data);\n\n        // Reset the l2Sender back to the default value.\n        l2Sender = DEFAULT_L2_SENDER;\n\n        // All withdrawals are immediately finalized. Replayability can\n        // be achieved through contracts built on top of this contract\n        emit WithdrawalFinalized(withdrawalHash, success);\n    }\n\n    /**\n     * @notice Determine if a given block number is finalized. Reverts if the call to\n     *         L2_ORACLE.getL2Output reverts. Returns a boolean otherwise.\n     *\n     * @param _l2BlockNumber The number of the L2 block.\n     */\n    function isBlockFinalized(uint256 _l2BlockNumber) external view returns (bool) {\n        Types.OutputProposal memory proposal = L2_ORACLE.getL2Output(_l2BlockNumber);\n        return _isOutputFinalized(proposal);\n    }\n\n    /**\n     * @notice Initializer;\n     */\n    function initialize() public initializer {\n        l2Sender = DEFAULT_L2_SENDER;\n        __ResourceMetering_init();\n    }\n\n    /**\n     * @notice Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in\n     *         deriving deposit transactions. Note that if a deposit is made by a contract, its\n     *         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider\n     *         using the CrossDomainMessenger contracts for a simpler developer experience.\n     *\n     * @param _to         Target address on L2.\n     * @param _value      ETH value to send to the recipient.\n     * @param _gasLimit   Minimum L2 gas limit (can be greater than or equal to this value).\n     * @param _isCreation Whether or not the transaction is a contract creation.\n     * @param _data       Data to trigger the recipient with.\n     */\n    function depositTransaction(\n        address _to,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) public payable metered(_gasLimit) {\n        // Just to be safe, make sure that people specify address(0) as the target when doing\n        // contract creations.\n        if (_isCreation) {\n            require(\n                _to == address(0),\n                \"OptimismPortal: must send to address(0) when creating a contract\"\n            );\n        }\n\n        // Transform the from-address to its alias if the caller is a contract.\n        address from = msg.sender;\n        if (msg.sender != tx.origin) {\n            from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        bytes memory opaqueData = abi.encodePacked(\n            msg.value,\n            _value,\n            _gasLimit,\n            _isCreation,\n            _data\n        );\n\n        // Emit a TransactionDeposited event so that the rollup node can derive a deposit\n        // transaction for this deposit.\n        emit TransactionDeposited(from, _to, DEPOSIT_VERSION, opaqueData);\n    }\n\n    /**\n     * @notice Determine if an L2 Output is finalized.\n     *\n     * @param _proposal The output proposal to check.\n     */\n    function _isOutputFinalized(Types.OutputProposal memory _proposal)\n        internal\n        view\n        returns (bool)\n    {\n        return block.timestamp > _proposal.timestamp + FINALIZATION_PERIOD_SECONDS;\n    }\n\n    /**\n     * @notice Verifies a Merkle Trie inclusion proof that a given withdrawal hash is present in\n     *         the storage of the L2ToL1MessagePasser contract.\n     *\n     * @param _withdrawalHash Hash of the withdrawal to verify.\n     * @param _storageRoot    Root of the storage of the L2ToL1MessagePasser contract.\n     * @param _proof          Inclusion proof of the withdrawal hash in the storage root.\n     */\n    function _verifyWithdrawalInclusion(\n        bytes32 _withdrawalHash,\n        bytes32 _storageRoot,\n        bytes memory _proof\n    ) internal pure returns (bool) {\n        bytes32 storageKey = keccak256(\n            abi.encode(\n                _withdrawalHash,\n                uint256(0) // The withdrawals mapping is at the first slot in the layout.\n            )\n        );\n\n        return\n            SecureMerkleTrie.verifyInclusionProof(\n                abi.encode(storageKey),\n                hex\"01\",\n                _proof,\n                _storageRoot\n            );\n    }\n}\n"
    },
    "contracts/L1/ResourceMetering.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SignedMath } from \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport { FixedPointMathLib } from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport { Burn } from \"../libraries/Burn.sol\";\n\n/**\n * @title ResourceMetering\n * @notice ResourceMetering implements an EIP-1559 style resource metering system where pricing\n *         updates automatically based on current demand.\n */\nabstract contract ResourceMetering is Initializable {\n    /**\n     * @notice Represents the various parameters that control the way in which resources are\n     *         metered. Corresponds to the EIP-1559 resource metering system.\n     */\n    struct ResourceParams {\n        uint128 prevBaseFee;\n        uint64 prevBoughtGas;\n        uint64 prevBlockNum;\n    }\n\n    /**\n     * @notice Maximum amount of the resource that can be used within this block.\n     */\n    int256 public constant MAX_RESOURCE_LIMIT = 8_000_000;\n\n    /**\n     * @notice Along with the resource limit, determines the target resource limit.\n     */\n    int256 public constant ELASTICITY_MULTIPLIER = 4;\n\n    /**\n     * @notice Target amount of the resource that should be used within this block.\n     */\n    int256 public constant TARGET_RESOURCE_LIMIT = MAX_RESOURCE_LIMIT / ELASTICITY_MULTIPLIER;\n\n    /**\n     * @notice Denominator that determines max change on fee per block.\n     */\n    int256 public constant BASE_FEE_MAX_CHANGE_DENOMINATOR = 8;\n\n    /**\n     * @notice Minimum base fee value, cannot go lower than this.\n     */\n    int256 public constant MINIMUM_BASE_FEE = 10_000;\n\n    /**\n     * @notice Initial base fee value.\n     */\n    uint128 public constant INITIAL_BASE_FEE = 1_000_000_000;\n\n    /**\n     * @notice EIP-1559 style gas parameters.\n     */\n    ResourceParams public params;\n\n    /**\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n     */\n    uint256[49] private __gap;\n\n    /**\n     * @notice Meters access to a function based an amount of a requested resource.\n     *\n     * @param _amount Amount of the resource requested.\n     */\n    modifier metered(uint64 _amount) {\n        // Record initial gas amount so we can refund for it later.\n        uint256 initialGas = gasleft();\n\n        // Run the underlying function.\n        _;\n\n        // Update block number and base fee if necessary.\n        uint256 blockDiff = block.number - params.prevBlockNum;\n        if (blockDiff > 0) {\n            // Handle updating EIP-1559 style gas parameters. We use EIP-1559 to restrict the rate\n            // at which deposits can be created and therefore limit the potential for deposits to\n            // spam the L2 system. Fee scheme is very similar to EIP-1559 with minor changes.\n            int256 gasUsedDelta = int256(uint256(params.prevBoughtGas)) - TARGET_RESOURCE_LIMIT;\n            int256 baseFeeDelta = (int256(uint256(params.prevBaseFee)) * gasUsedDelta) /\n                TARGET_RESOURCE_LIMIT /\n                BASE_FEE_MAX_CHANGE_DENOMINATOR;\n\n            // Update base fee by adding the base fee delta and clamp the resulting value between\n            // min and max.\n            int256 newBaseFee = SignedMath.min(\n                SignedMath.max(\n                    int256(uint256(params.prevBaseFee)) + baseFeeDelta,\n                    int256(MINIMUM_BASE_FEE)\n                ),\n                int256(uint256(type(uint128).max))\n            );\n\n            // If we skipped more than one block, we also need to account for every empty block.\n            // Empty block means there was no demand for deposits in that block, so we should\n            // reflect this lack of demand in the fee.\n            if (blockDiff > 1) {\n                // Update the base fee by repeatedly applying the exponent 1-(1/change_denominator)\n                // blockDiff - 1 times. Simulates multiple empty blocks. Clamp the resulting value\n                // between min and max.\n                newBaseFee = SignedMath.min(\n                    SignedMath.max(\n                        int256(\n                            (newBaseFee *\n                                (\n                                    FixedPointMathLib.powWad(\n                                        1e18 - (1e18 / BASE_FEE_MAX_CHANGE_DENOMINATOR),\n                                        int256((blockDiff - 1) * 1e18)\n                                    )\n                                )) / 1e18\n                        ),\n                        int256(MINIMUM_BASE_FEE)\n                    ),\n                    int256(uint256(type(uint128).max))\n                );\n            }\n\n            // Update new base fee, reset bought gas, and update block number.\n            params.prevBaseFee = uint128(uint256(newBaseFee));\n            params.prevBoughtGas = 0;\n            params.prevBlockNum = uint64(block.number);\n        }\n\n        // Make sure we can actually buy the resource amount requested by the user.\n        params.prevBoughtGas += _amount;\n        require(\n            int256(uint256(params.prevBoughtGas)) <= MAX_RESOURCE_LIMIT,\n            \"ResourceMetering: cannot buy more gas than available gas limit\"\n        );\n\n        // Determine the amount of ETH to be paid.\n        uint256 resourceCost = _amount * params.prevBaseFee;\n\n        // We currently charge for this ETH amount as an L1 gas burn, so we convert the ETH amount\n        // into gas by dividing by the L1 base fee. We assume a minimum base fee of 1 gwei to avoid\n        // division by zero for L1s that don't support 1559 or to avoid excessive gas burns during\n        // periods of extremely low L1 demand. One-day average gas fee hasn't dipped below 1 gwei\n        // during any 1 day period in the last 5 years, so should be fine.\n        uint256 gasCost = resourceCost / Math.max(block.basefee, 1000000000);\n\n        // Give the user a refund based on the amount of gas they used to do all of the work up to\n        // this point. Since we're at the end of the modifier, this should be pretty accurate. Acts\n        // effectively like a dynamic stipend (with a minimum value).\n        uint256 usedGas = initialGas - gasleft();\n        if (gasCost > usedGas) {\n            Burn.gas(gasCost - usedGas);\n        }\n    }\n\n    /**\n     * @notice Sets initial resource parameter values. This function must either be called by the\n     *         initializer function of an upgradeable child contract.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __ResourceMetering_init() internal onlyInitializing {\n        params = ResourceParams({\n            prevBaseFee: INITIAL_BASE_FEE,\n            prevBoughtGas: 0,\n            prevBlockNum: uint64(block.number)\n        });\n    }\n}\n"
    },
    "contracts/L2/GasPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Semver } from \"../universal/Semver.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x420000000000000000000000000000000000000F\n * @title GasPriceOracle\n * @notice This contract maintains the variables responsible for computing the L1 portion of the\n *         total fee charged on L2. The values stored in the contract are looked up as part of the\n *         L2 state transition function and used to compute the total fee paid by the user. The\n *         contract exposes an API that is useful for knowing how large the L1 portion of their\n *         transaction fee will be.\n */\ncontract GasPriceOracle is Ownable, Semver {\n    /**\n     * @custom:legacy\n     * @notice Spacer for backwards compatibility.\n     */\n    uint256 internal spacer0;\n\n    /**\n     * @custom:legacy\n     * @notice Spacer for backwards compatibility.\n     */\n    uint256 internal spacer1;\n\n    /**\n     * @notice Constant L1 gas overhead per transaction.\n     */\n    uint256 public overhead;\n\n    /**\n     * @notice Dynamic L1 gas overhead per transaction.\n     */\n    uint256 public scalar;\n\n    /**\n     * @notice Number of decimals used in the scalar.\n     */\n    uint256 public decimals;\n\n    /**\n     * @notice Emitted when the overhead value is updated.\n     */\n    event OverheadUpdated(uint256 overhead);\n\n    /**\n     * @notice Emitted when the scalar value is updated.\n     */\n    event ScalarUpdated(uint256 scalar);\n\n    /**\n     * @notice Emitted when the decimals value is updated.\n     */\n    event DecimalsUpdated(uint256 decimals);\n\n    /**\n     * @custom:semver 0.0.1\n     *\n     * @param _owner Address that will initially own this contract.\n     */\n    constructor(address _owner) Ownable() Semver(0, 0, 1) {\n        transferOwnership(_owner);\n    }\n\n    /**\n     * @notice Allows the owner to modify the overhead.\n     *\n     * @param _overhead New overhead value.\n     */\n    function setOverhead(uint256 _overhead) external onlyOwner {\n        overhead = _overhead;\n        emit OverheadUpdated(_overhead);\n    }\n\n    /**\n     * @notice Allows the owner to modify the scalar.\n     *\n     * @param _scalar New scalar value.\n     */\n    function setScalar(uint256 _scalar) external onlyOwner {\n        scalar = _scalar;\n        emit ScalarUpdated(_scalar);\n    }\n\n    /**\n     * @notice Allows the owner to modify the decimals.\n     *\n     * @param _decimals New decimals value.\n     */\n    function setDecimals(uint256 _decimals) external onlyOwner {\n        decimals = _decimals;\n        emit DecimalsUpdated(_decimals);\n    }\n\n    /**\n     * @notice Computes the L1 portion of the fee based on the size of the rlp encoded input\n     *         transaction, the current L1 base fee, and the various dynamic parameters.\n     *\n     * @param _data Unsigned fully RLP-encoded transaction to get the L1 fee for.\n     *\n     * @return L1 fee that should be paid for the tx\n     */\n    function getL1Fee(bytes memory _data) external view returns (uint256) {\n        uint256 l1GasUsed = getL1GasUsed(_data);\n        uint256 l1Fee = l1GasUsed * l1BaseFee();\n        uint256 divisor = 10**decimals;\n        uint256 unscaled = l1Fee * scalar;\n        uint256 scaled = unscaled / divisor;\n        return scaled;\n    }\n\n    /**\n     * @notice Retrieves the current gas price (base fee).\n     *\n     * @return Current L2 gas price (base fee).\n     */\n    function gasPrice() public view returns (uint256) {\n        return block.basefee;\n    }\n\n    /**\n     * @notice Retrieves the current base fee.\n     *\n     * @return Current L2 base fee.\n     */\n    function baseFee() public view returns (uint256) {\n        return block.basefee;\n    }\n\n    /**\n     * @notice Retrieves the latest known L1 base fee.\n     *\n     * @return Latest known L1 base fee.\n     */\n    function l1BaseFee() public view returns (uint256) {\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).basefee();\n    }\n\n    /**\n     * @notice Computes the amount of L1 gas used for a transaction. Adds the overhead which\n     *         represents the per-transaction gas overhead of posting the transaction and state\n     *         roots to L1. Adds 68 bytes of padding to account for the fact that the input does\n     *         not have a signature.\n     *\n     * @param _data Unsigned fully RLP-encoded transaction to get the L1 gas for.\n     *\n     * @return Amount of L1 gas used to publish the transaction.\n     */\n    function getL1GasUsed(bytes memory _data) public view returns (uint256) {\n        uint256 total = 0;\n        uint256 length = _data.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (_data[i] == 0) {\n                total += 4;\n            } else {\n                total += 16;\n            }\n        }\n        uint256 unsigned = total + overhead;\n        return unsigned + (68 * 16);\n    }\n}\n"
    },
    "contracts/L2/L1Block.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000015\n * @title L1Block\n * @notice The L1Block predeploy gives users access to information about the last known L1 block.\n *         Values within this contract are updated once per epoch (every L1 block) and can only be\n *         set by the \"depositor\" account, a special system address. Depositor account transactions\n *         are created by the protocol whenever we move to a new epoch.\n */\ncontract L1Block is Semver {\n    /**\n     * @notice Address of the special depositor account.\n     */\n    address public constant DEPOSITOR_ACCOUNT = 0xDeaDDEaDDeAdDeAdDEAdDEaddeAddEAdDEAd0001;\n\n    /**\n     * @notice The latest L1 block number known by the L2 system.\n     */\n    uint64 public number;\n\n    /**\n     * @notice The latest L1 timestamp known by the L2 system.\n     */\n    uint64 public timestamp;\n\n    /**\n     * @notice The latest L1 basefee.\n     */\n    uint256 public basefee;\n\n    /**\n     * @notice The latest L1 blockhash.\n     */\n    bytes32 public hash;\n\n    /**\n     * @notice The number of L2 blocks in the same epoch.\n     */\n    uint64 public sequenceNumber;\n\n    /**\n     * @custom:semver 0.0.1\n     */\n    constructor() Semver(0, 0, 1) {}\n\n    /**\n     * @notice Updates the L1 block values.\n     *\n     * @param _number         L1 blocknumber.\n     * @param _timestamp      L1 timestamp.\n     * @param _basefee        L1 basefee.\n     * @param _hash           L1 blockhash.\n     * @param _sequenceNumber Number of L2 blocks since epoch start.\n     */\n    function setL1BlockValues(\n        uint64 _number,\n        uint64 _timestamp,\n        uint256 _basefee,\n        bytes32 _hash,\n        uint64 _sequenceNumber\n    ) external {\n        require(\n            msg.sender == DEPOSITOR_ACCOUNT,\n            \"L1Block: only the depositor account can set L1 block values\"\n        );\n\n        number = _number;\n        timestamp = _timestamp;\n        basefee = _basefee;\n        hash = _hash;\n        sequenceNumber = _sequenceNumber;\n    }\n}\n"
    },
    "contracts/L2/L2CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { L2ToL1MessagePasser } from \"./L2ToL1MessagePasser.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000007\n * @title L2CrossDomainMessenger\n * @notice The L2CrossDomainMessenger is a high-level interface for message passing between L1 and\n *         L2 on the L2 side. Users are generally encouraged to use this contract instead of lower\n *         level message passing contracts.\n */\ncontract L2CrossDomainMessenger is CrossDomainMessenger, Semver {\n    /**\n     * @custom:semver 0.0.1\n     *\n     * @param _l1CrossDomainMessenger Address of the L1CrossDomainMessenger contract.\n     */\n    constructor(address _l1CrossDomainMessenger) Semver(0, 0, 1) {\n        initialize(_l1CrossDomainMessenger);\n    }\n\n    /**\n     * @notice Initializer.\n     *\n     * @param _l1CrossDomainMessenger Address of the L1CrossDomainMessenger contract.\n     */\n    function initialize(address _l1CrossDomainMessenger) public initializer {\n        address[] memory blockedSystemAddresses = new address[](2);\n        blockedSystemAddresses[0] = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        blockedSystemAddresses[1] = Predeploys.L2_TO_L1_MESSAGE_PASSER;\n        __CrossDomainMessenger_init(_l1CrossDomainMessenger, blockedSystemAddresses);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Legacy getter for the remote messenger. Use otherMessenger going forward.\n     *\n     * @return Address of the L1CrossDomainMessenger contract.\n     */\n    function l1CrossDomainMessenger() public view returns (address) {\n        return otherMessenger;\n    }\n\n    /**\n     * @notice Sends a message from L2 to L1.\n     *\n     * @param _to       Address to send the message to.\n     * @param _gasLimit Minimum gas limit to execute the message with.\n     * @param _value    ETH value to send with the message.\n     * @param _data     Data to trigger the recipient with.\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal override {\n        L2ToL1MessagePasser(payable(Predeploys.L2_TO_L1_MESSAGE_PASSER)).initiateWithdrawal{\n            value: _value\n        }(_to, _gasLimit, _data);\n    }\n\n    /**\n     * @notice Checks that the message sender is the L1CrossDomainMessenger on L1.\n     *\n     * @return True if the message sender is the L1CrossDomainMessenger on L1.\n     */\n    function _isOtherMessenger() internal view override returns (bool) {\n        return AddressAliasHelper.undoL1ToL2Alias(msg.sender) == otherMessenger;\n    }\n}\n"
    },
    "contracts/L2/L2StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { OptimismMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000010\n * @title L2StandardBridge\n * @notice The L2StandardBridge is responsible for transfering ETH and ERC20 tokens between L1 and\n *         L2. ERC20 tokens sent to L1 are escrowed within this contract.\n *         Note that this contract is not intended to support all variations of ERC20 tokens.\n *         Examples of some token types that may not be properly supported by this contract include,\n *         but are not limited to: tokens with transfer fees, rebasing tokens, and\n *         tokens with blocklists.\n */\ncontract L2StandardBridge is StandardBridge, Semver {\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever a withdrawal from L2 to L1 is initiated.\n     *\n     * @param l1Token   Address of the token on L1.\n     * @param l2Token   Address of the corresponding token on L2.\n     * @param from      Address of the withdrawer.\n     * @param to        Address of the recipient on L1.\n     * @param amount    Amount of the ERC20 withdrawn.\n     * @param extraData Extra data attached to the withdrawal.\n     */\n    event WithdrawalInitiated(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever an ERC20 deposit is finalized.\n     *\n     * @param l1Token   Address of the token on L1.\n     * @param l2Token   Address of the corresponding token on L2.\n     * @param from      Address of the depositor.\n     * @param to        Address of the recipient on L2.\n     * @param amount    Amount of the ERC20 deposited.\n     * @param extraData Extra data attached to the deposit.\n     */\n    event DepositFinalized(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever a deposit fails.\n     *\n     * @param l1Token   Address of the token on L1.\n     * @param l2Token   Address of the corresponding token on L2.\n     * @param from      Address of the depositor.\n     * @param to        Address of the recipient on L2.\n     * @param amount    Amount of the ERC20 deposited.\n     * @param extraData Extra data attached to the deposit.\n     */\n    event DepositFailed(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @custom:semver 0.0.2\n     *\n     * @param _otherBridge Address of the L1StandardBridge.\n     */\n    constructor(address payable _otherBridge)\n        Semver(0, 0, 2)\n        StandardBridge(payable(Predeploys.L2_CROSS_DOMAIN_MESSENGER), _otherBridge)\n    {}\n\n    /**\n     * @custom:legacy\n     * @notice Initiates a withdrawal from L2 to L1.\n     *\n     * @param _l2Token     Address of the L2 token to withdraw.\n     * @param _amount      Amount of the L2 token to withdraw.\n     * @param _minGasLimit Minimum gas limit to use for the transaction.\n     * @param _extraData   Extra data attached to the withdrawal.\n     */\n    function withdraw(\n        address _l2Token,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external payable virtual onlyEOA {\n        _initiateWithdrawal(_l2Token, msg.sender, msg.sender, _amount, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Initiates a withdrawal from L2 to L1 to a target account on L1.\n     *         Note that if ETH is sent to a contract on L1 and the call fails, then that ETH will\n     *         be locked in the L1StandardBridge. ETH may be recoverable if the call can be\n     *         successfully replayed by increasing the amount of gas supplied to the call. If the\n     *         call will fail for any amount of gas, then the ETH will be locked permanently.\n     *\n     * @param _l2Token     Address of the L2 token to withdraw.\n     * @param _to          Recipient account on L1.\n     * @param _amount      Amount of the L2 token to withdraw.\n     * @param _minGasLimit Minimum gas limit to use for the transaction.\n     * @param _extraData   Extra data attached to the withdrawal.\n     */\n    function withdrawTo(\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external payable virtual {\n        _initiateWithdrawal(_l2Token, msg.sender, _to, _amount, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Finalizes a deposit from L1 to L2.\n     *\n     * @param _l1Token   Address of the L1 token to deposit.\n     * @param _l2Token   Address of the corresponding L2 token.\n     * @param _from      Address of the depositor.\n     * @param _to        Address of the recipient.\n     * @param _amount    Amount of the tokens being deposited.\n     * @param _extraData Extra data attached to the deposit.\n     */\n    function finalizeDeposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) external payable virtual {\n        if (_l1Token == address(0) && _l2Token == Predeploys.LEGACY_ERC20_ETH) {\n            finalizeBridgeETH(_from, _to, _amount, _extraData);\n        } else {\n            finalizeBridgeERC20(_l2Token, _l1Token, _from, _to, _amount, _extraData);\n        }\n        emit DepositFinalized(_l1Token, _l2Token, _from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Internal function to a withdrawal from L2 to L1 to a target account on L1.\n     *\n     * @param _l2Token     Address of the L2 token to withdraw.\n     * @param _from        Address of the withdrawer.\n     * @param _to          Recipient account on L1.\n     * @param _amount      Amount of the L2 token to withdraw.\n     * @param _minGasLimit Minimum gas limit to use for the transaction.\n     * @param _extraData   Extra data attached to the withdrawal.\n     */\n    function _initiateWithdrawal(\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal {\n        address l1Token = OptimismMintableERC20(_l2Token).l1Token();\n        if (_l2Token == Predeploys.LEGACY_ERC20_ETH) {\n            require(\n                msg.value == _amount,\n                \"L2StandardBridge: ETH withdrawals must include sufficient ETH value\"\n            );\n\n            _initiateBridgeETH(_from, _to, _amount, _minGasLimit, _extraData);\n        } else {\n            _initiateBridgeERC20(_l2Token, l1Token, _from, _to, _amount, _minGasLimit, _extraData);\n        }\n        emit WithdrawalInitiated(l1Token, _l2Token, _from, _to, _amount, _extraData);\n    }\n}\n"
    },
    "contracts/L2/L2ToL1MessagePasser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Types } from \"../libraries/Types.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Burn } from \"../libraries/Burn.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000000\n * @title L2ToL1MessagePasser\n * @notice The L2ToL1MessagePasser is a dedicated contract where messages that are being sent from\n *         L2 to L1 can be stored. The storage root of this contract is pulled up to the top level\n *         of the L2 output to reduce the cost of proving the existence of sent messages.\n */\ncontract L2ToL1MessagePasser is Semver {\n    /**\n     * @notice The L1 gas limit set when eth is withdrawn using the receive() function.\n     */\n    uint256 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\n\n    /**\n     * @notice Includes the message hashes for all withdrawals\n     */\n    mapping(bytes32 => bool) public sentMessages;\n\n    /**\n     * @notice A unique value hashed with each withdrawal.\n     */\n    uint256 public nonce;\n\n    /**\n     * @notice Emitted any time a withdrawal is initiated.\n     *\n     * @param nonce    Unique value corresponding to each withdrawal.\n     * @param sender   The L2 account address which initiated the withdrawal.\n     * @param target   The L1 account address the call will be send to.\n     * @param value    The ETH value submitted for withdrawal, to be forwarded to the target.\n     * @param gasLimit The minimum amount of gas that must be provided when withdrawing on L1.\n     * @param data     The data to be forwarded to the target on L1.\n     */\n    event WithdrawalInitiated(\n        uint256 indexed nonce,\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /**\n     * @notice Emitted any time a withdrawal is initiated. An extension to\n     *         WithdrawalInitiated so that the interface is maintained.\n     *\n     * @param hash The hash of the withdrawal\n     */\n    event WithdrawalInitiatedExtension1(bytes32 indexed hash);\n\n    /**\n     * @notice Emitted when the balance of this contract is burned.\n     *\n     * @param amount Amount of ETh that was burned.\n     */\n    event WithdrawerBalanceBurnt(uint256 indexed amount);\n\n    /**\n     * @custom:semver 0.0.1\n     */\n    constructor() Semver(0, 0, 1) {}\n\n    /**\n     * @notice Allows users to withdraw ETH by sending directly to this contract.\n     */\n    receive() external payable {\n        initiateWithdrawal(msg.sender, RECEIVE_DEFAULT_GAS_LIMIT, bytes(\"\"));\n    }\n\n    /**\n     * @notice Removes all ETH held by this contract from the state. Used to prevent the amount of\n     *         ETH on L2 inflating when ETH is withdrawn. Currently only way to do this is to\n     *         create a contract and self-destruct it to itself. Anyone can call this function. Not\n     *         incentivized since this function is very cheap.\n     */\n    function burn() external {\n        uint256 balance = address(this).balance;\n        Burn.eth(balance);\n        emit WithdrawerBalanceBurnt(balance);\n    }\n\n    /**\n     * @notice Sends a message from L2 to L1.\n     *\n     * @param _target   Address to call on L1 execution.\n     * @param _gasLimit Minimum gas limit for executing the message on L1.\n     * @param _data     Data to forward to L1 target.\n     */\n    function initiateWithdrawal(\n        address _target,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) public payable {\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction({\n                nonce: nonce,\n                sender: msg.sender,\n                target: _target,\n                value: msg.value,\n                gasLimit: _gasLimit,\n                data: _data\n            })\n        );\n\n        sentMessages[withdrawalHash] = true;\n\n        emit WithdrawalInitiated(nonce, msg.sender, _target, msg.value, _gasLimit, _data);\n        emit WithdrawalInitiatedExtension1(withdrawalHash);\n\n        unchecked {\n            ++nonce;\n        }\n    }\n}\n"
    },
    "contracts/L2/SequencerFeeVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Semver } from \"../universal/Semver.sol\";\nimport { L2StandardBridge } from \"./L2StandardBridge.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000011\n * @title SequencerFeeVault\n * @notice The SequencerFeeVault is the contract that holds any fees paid to the Sequencer during\n *         transaction processing and block production.\n */\ncontract SequencerFeeVault is Semver {\n    /**\n     * @notice Minimum balance before a withdrawal can be triggered.\n     */\n    uint256 public constant MIN_WITHDRAWAL_AMOUNT = 15 ether;\n\n    /**\n     * @notice Wallet that will receive the fees on L1.\n     */\n    address public l1FeeWallet;\n\n    /**\n     * @custom:semver 0.0.1\n     */\n    constructor() Semver(0, 0, 1) {}\n\n    /**\n     * @notice Allow the contract to receive ETH.\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Triggers a withdrawal of funds to the L1 fee wallet.\n     */\n    function withdraw() external {\n        require(\n            address(this).balance >= MIN_WITHDRAWAL_AMOUNT,\n            \"SequencerFeeVault: withdrawal amount must be greater than minimum withdrawal amount\"\n        );\n\n        L2StandardBridge(payable(Predeploys.L2_STANDARD_BRIDGE)).withdrawTo{\n            value: address(this).balance\n        }(Predeploys.LEGACY_ERC20_ETH, l1FeeWallet, address(this).balance, 0, bytes(\"\"));\n    }\n}\n"
    },
    "contracts/legacy/AddressManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @custom:legacy\n * @title AddressManager\n * @notice AddressManager is a legacy contract that was used in the old version of the Optimism\n *         system to manage a registry of string names to addresses. We now use a more standard\n *         proxy system instead, but this contract is still necessary for backwards compatibility\n *         with several older contracts.\n */\ncontract AddressManager is Ownable {\n    /**\n     * @notice Mapping of the hashes of string names to addresses.\n     */\n    mapping(bytes32 => address) private addresses;\n\n    /**\n     * @notice Emitted when an address is modified in the registry.\n     *\n     * @param name       String name being set in the registry.\n     * @param newAddress Address set for the given name.\n     * @param oldAddress Address that was previously set for the given name.\n     */\n    event AddressSet(string indexed name, address newAddress, address oldAddress);\n\n    /**\n     * @notice Changes the address associated with a particular name.\n     *\n     * @param _name    String name to associate an address with.\n     * @param _address Address to associate with the name.\n     */\n    function setAddress(string memory _name, address _address) external onlyOwner {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(_name, _address, oldAddress);\n    }\n\n    /**\n     * @notice Retrieves the address associated with a given name.\n     *\n     * @param _name Name to retrieve an address for.\n     *\n     * @return Address associated with the given name.\n     */\n    function getAddress(string memory _name) external view returns (address) {\n        return addresses[_getNameHash(_name)];\n    }\n\n    /**\n     * @notice Computes the hash of a name.\n     *\n     * @param _name Name to compute a hash for.\n     *\n     * @return Hash of the given name.\n     */\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_name));\n    }\n}\n"
    },
    "contracts/legacy/DeployerWhitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:legacy\n * @custom:proxied\n * @custom:predeployed 0x4200000000000000000000000000000000000002\n * @title DeployerWhitelist\n * @notice DeployerWhitelist is a legacy contract that was originally used to act as a whitelist of\n *         addresses allowed to the Optimism network. The DeployerWhitelist has since been\n *         disabled, but the code is kept in state for the sake of full backwards compatibility.\n *         As of the Bedrock upgrade, the DeployerWhitelist is completely unused by the Optimism\n *         system and could, in theory, be removed entirely.\n */\ncontract DeployerWhitelist is Semver {\n    /**\n     * @notice Address of the owner of this contract. Note that when this address is set to\n     *         address(0), the whitelist is disabled.\n     */\n    address public owner;\n\n    /**\n     * @notice Mapping of deployer addresses to boolean whitelist status.\n     */\n    mapping(address => bool) public whitelist;\n\n    /**\n     * @notice Emitted when the owner of this contract changes.\n     *\n     * @param oldOwner Address of the previous owner.\n     * @param newOwner Address of the new owner.\n     */\n    event OwnerChanged(address oldOwner, address newOwner);\n\n    /**\n     * @notice Emitted when the whitelist status of a deployer changes.\n     *\n     * @param deployer    Address of the deployer.\n     * @param whitelisted Boolean indicating whether the deployer is whitelisted.\n     */\n    event WhitelistStatusChanged(address deployer, bool whitelisted);\n\n    /**\n     * @notice Emitted when the whitelist is disabled.\n     *\n     * @param oldOwner Address of the final owner of the whitelist.\n     */\n    event WhitelistDisabled(address oldOwner);\n\n    /**\n     * @notice Blocks functions to anyone except the contract owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == owner,\n            \"DeployerWhitelist: function can only be called by the owner of this contract\"\n        );\n        _;\n    }\n\n    /**\n     * @custom:semver 0.0.1\n     */\n    constructor() Semver(0, 0, 1) {}\n\n    /**\n     * @notice Adds or removes an address from the deployment whitelist.\n     *\n     * @param _deployer      Address to update permissions for.\n     * @param _isWhitelisted Whether or not the address is whitelisted.\n     */\n    function setWhitelistedDeployer(address _deployer, bool _isWhitelisted) external onlyOwner {\n        whitelist[_deployer] = _isWhitelisted;\n        emit WhitelistStatusChanged(_deployer, _isWhitelisted);\n    }\n\n    /**\n     * @notice Updates the owner of this contract.\n     *\n     * @param _owner Address of the new owner.\n     */\n    function setOwner(address _owner) external onlyOwner {\n        // Prevent users from setting the whitelist owner to address(0) except via\n        // enableArbitraryContractDeployment. If you want to burn the whitelist owner, send it to\n        // any other address that doesn't have a corresponding knowable private key.\n        require(\n            _owner != address(0),\n            \"DeployerWhitelist: can only be disabled via enableArbitraryContractDeployment\"\n        );\n\n        emit OwnerChanged(owner, _owner);\n        owner = _owner;\n    }\n\n    /**\n     * @notice Permanently enables arbitrary contract deployment and deletes the owner.\n     */\n    function enableArbitraryContractDeployment() external onlyOwner {\n        emit WhitelistDisabled(owner);\n        owner = address(0);\n    }\n\n    /**\n     * @notice Checks whether an address is allowed to deploy contracts.\n     *\n     * @param _deployer Address to check.\n     *\n     * @return Whether or not the address can deploy contracts.\n     */\n    function isDeployerAllowed(address _deployer) external view returns (bool) {\n        return (owner == address(0) || whitelist[_deployer]);\n    }\n}\n"
    },
    "contracts/legacy/L1BlockNumber.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { L1Block } from \"../L2/L1Block.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\n\n/**\n * @custom:legacy\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000013\n * @title L1BlockNumber\n * @notice L1BlockNumber is a legacy contract that fills the roll of the OVM_L1BlockNumber contract\n *         in the old version of the Optimism system. Only necessary for backwards compatibility.\n *         If you want to access the L1 block number going forward, you should use the L1Block\n *         contract instead.\n */\ncontract L1BlockNumber is Semver {\n    /**\n     * @custom:semver 0.0.1\n     */\n    constructor() Semver(0, 0, 1) {}\n\n    /**\n     * @notice Returns the L1 block number.\n     */\n    receive() external payable {\n        uint256 l1BlockNumber = getL1BlockNumber();\n        assembly {\n            mstore(0, l1BlockNumber)\n            return(0, 32)\n        }\n    }\n\n    /**\n     * @notice Returns the L1 block number.\n     */\n    // solhint-disable-next-line no-complex-fallback\n    fallback() external payable {\n        uint256 l1BlockNumber = getL1BlockNumber();\n        assembly {\n            mstore(0, l1BlockNumber)\n            return(0, 32)\n        }\n    }\n\n    /**\n     * @notice Retrieves the latest L1 block number.\n     *\n     * @return Latest L1 block number.\n     */\n    function getL1BlockNumber() public view returns (uint256) {\n        return L1Block(Predeploys.L1_BLOCK_ATTRIBUTES).number();\n    }\n}\n"
    },
    "contracts/legacy/L1ChugSplashProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title IL1ChugSplashDeployer\n */\ninterface IL1ChugSplashDeployer {\n    function isUpgrading() external view returns (bool);\n}\n\n/**\n * @custom:legacy\n * @title L1ChugSplashProxy\n * @notice Basic ChugSplash proxy contract for L1. Very close to being a normal proxy but has added\n *         functions `setCode` and `setStorage` for changing the code or storage of the contract.\n *\n *         Note for future developers: do NOT make anything in this contract 'public' unless you\n *         know what you're doing. Anything public can potentially have a function signature that\n *         conflicts with a signature attached to the implementation contract. Public functions\n *         SHOULD always have the `proxyCallIfNotOwner` modifier unless there's some *really* good\n *         reason not to have that modifier. And there almost certainly is not a good reason to not\n *         have that modifier. Beware!\n */\ncontract L1ChugSplashProxy {\n    /**\n     * @notice \"Magic\" prefix. When prepended to some arbitrary bytecode and used to create a\n     *         contract, the appended bytecode will be deployed as given.\n     */\n    bytes13 internal constant DEPLOY_CODE_PREFIX = 0x600D380380600D6000396000f3;\n\n    /**\n     * @notice bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n     */\n    bytes32 internal constant IMPLEMENTATION_KEY =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @notice bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\n     */\n    bytes32 internal constant OWNER_KEY =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @notice Blocks a function from being called when the parent signals that the system should\n     *         be paused via an isUpgrading function.\n     */\n    modifier onlyWhenNotPaused() {\n        address owner = _getOwner();\n\n        // We do a low-level call because there's no guarantee that the owner actually *is* an\n        // L1ChugSplashDeployer contract and Solidity will throw errors if we do a normal call and\n        // it turns out that it isn't the right type of contract.\n        (bool success, bytes memory returndata) = owner.staticcall(\n            abi.encodeWithSelector(IL1ChugSplashDeployer.isUpgrading.selector)\n        );\n\n        // If the call was unsuccessful then we assume that there's no \"isUpgrading\" method and we\n        // can just continue as normal. We also expect that the return value is exactly 32 bytes\n        // long. If this isn't the case then we can safely ignore the result.\n        if (success && returndata.length == 32) {\n            // Although the expected value is a *boolean*, it's safer to decode as a uint256 in the\n            // case that the isUpgrading function returned something other than 0 or 1. But we only\n            // really care about the case where this value is 0 (= false).\n            uint256 ret = abi.decode(returndata, (uint256));\n            require(ret == 0, \"L1ChugSplashProxy: system is currently being upgraded\");\n        }\n\n        _;\n    }\n\n    /**\n     * @notice Makes a proxy call instead of triggering the given function when the caller is\n     *         either the owner or the zero address. Caller can only ever be the zero address if\n     *         this function is being called off-chain via eth_call, which is totally fine and can\n     *         be convenient for client-side tooling. Avoids situations where the proxy and\n     *         implementation share a sighash and the proxy function ends up being called instead\n     *         of the implementation one.\n     *\n     *         Note: msg.sender == address(0) can ONLY be triggered off-chain via eth_call. If\n     *         there's a way for someone to send a transaction with msg.sender == address(0) in any\n     *         real context then we have much bigger problems. Primary reason to include this\n     *         additional allowed sender is because the owner address can be changed dynamically\n     *         and we do not want clients to have to keep track of the current owner in order to\n     *         make an eth_call that doesn't trigger the proxied contract.\n     */\n    // slither-disable-next-line incorrect-modifier\n    modifier proxyCallIfNotOwner() {\n        if (msg.sender == _getOwner() || msg.sender == address(0)) {\n            _;\n        } else {\n            // This WILL halt the call frame on completion.\n            _doProxyCall();\n        }\n    }\n\n    /**\n     * @param _owner Address of the initial contract owner.\n     */\n    constructor(address _owner) {\n        _setOwner(_owner);\n    }\n\n    // slither-disable-next-line locked-ether\n    receive() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    // slither-disable-next-line locked-ether\n    fallback() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    /**\n     * @notice Sets the code that should be running behind this proxy.\n     *\n     *         Note: This scheme is a bit different from the standard proxy scheme where one would\n     *         typically deploy the code separately and then set the implementation address. We're\n     *         doing it this way because it gives us a lot more freedom on the client side. Can\n     *         only be triggered by the contract owner.\n     *\n     * @param _code New contract code to run inside this contract.\n     */\n    function setCode(bytes memory _code) external proxyCallIfNotOwner {\n        // Get the code hash of the current implementation.\n        address implementation = _getImplementation();\n\n        // If the code hash matches the new implementation then we return early.\n        if (keccak256(_code) == _getAccountCodeHash(implementation)) {\n            return;\n        }\n\n        // Create the deploycode by appending the magic prefix.\n        bytes memory deploycode = abi.encodePacked(DEPLOY_CODE_PREFIX, _code);\n\n        // Deploy the code and set the new implementation address.\n        address newImplementation;\n        assembly {\n            newImplementation := create(0x0, add(deploycode, 0x20), mload(deploycode))\n        }\n\n        // Check that the code was actually deployed correctly. I'm not sure if you can ever\n        // actually fail this check. Should only happen if the contract creation from above runs\n        // out of gas but this parent execution thread does NOT run out of gas. Seems like we\n        // should be doing this check anyway though.\n        require(\n            _getAccountCodeHash(newImplementation) == keccak256(_code),\n            \"L1ChugSplashProxy: code was not correctly deployed\"\n        );\n\n        _setImplementation(newImplementation);\n    }\n\n    /**\n     * @notice Modifies some storage slot within the proxy contract. Gives us a lot of power to\n     *         perform upgrades in a more transparent way. Only callable by the owner.\n     *\n     * @param _key   Storage key to modify.\n     * @param _value New value for the storage key.\n     */\n    function setStorage(bytes32 _key, bytes32 _value) external proxyCallIfNotOwner {\n        assembly {\n            sstore(_key, _value)\n        }\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract. Only callable by the owner.\n     *\n     * @param _owner New owner of the proxy contract.\n     */\n    function setOwner(address _owner) external proxyCallIfNotOwner {\n        _setOwner(_owner);\n    }\n\n    /**\n     * @notice Queries the owner of the proxy contract. Can only be called by the owner OR by\n     *         making an eth_call and setting the \"from\" address to address(0).\n     *\n     * @return Owner address.\n     */\n    function getOwner() external proxyCallIfNotOwner returns (address) {\n        return _getOwner();\n    }\n\n    /**\n     * @notice Queries the implementation address. Can only be called by the owner OR by making an\n     *         eth_call and setting the \"from\" address to address(0).\n     *\n     * @return Implementation address.\n     */\n    function getImplementation() external proxyCallIfNotOwner returns (address) {\n        return _getImplementation();\n    }\n\n    /**\n     * @notice Sets the implementation address.\n     *\n     * @param _implementation New implementation address.\n     */\n    function _setImplementation(address _implementation) internal {\n        assembly {\n            sstore(IMPLEMENTATION_KEY, _implementation)\n        }\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract.\n     *\n     * @param _owner New owner of the proxy contract.\n     */\n    function _setOwner(address _owner) internal {\n        assembly {\n            sstore(OWNER_KEY, _owner)\n        }\n    }\n\n    /**\n     * @notice Performs the proxy call via a delegatecall.\n     */\n    function _doProxyCall() internal onlyWhenNotPaused {\n        address implementation = _getImplementation();\n\n        require(implementation != address(0), \"L1ChugSplashProxy: implementation is not set yet\");\n\n        assembly {\n            // Copy calldata into memory at 0x0....calldatasize.\n            calldatacopy(0x0, 0x0, calldatasize())\n\n            // Perform the delegatecall, make sure to pass all available gas.\n            let success := delegatecall(gas(), implementation, 0x0, calldatasize(), 0x0, 0x0)\n\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\n            // overwrite the calldata that we just copied into memory but that doesn't really\n            // matter because we'll be returning in a second anyway.\n            returndatacopy(0x0, 0x0, returndatasize())\n\n            // Success == 0 means a revert. We'll revert too and pass the data up.\n            if iszero(success) {\n                revert(0x0, returndatasize())\n            }\n\n            // Otherwise we'll just return and pass the data up.\n            return(0x0, returndatasize())\n        }\n    }\n\n    /**\n     * @notice Queries the implementation address.\n     *\n     * @return Implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        address implementation;\n        assembly {\n            implementation := sload(IMPLEMENTATION_KEY)\n        }\n        return implementation;\n    }\n\n    /**\n     * @notice Queries the owner of the proxy contract.\n     *\n     * @return Owner address.\n     */\n    function _getOwner() internal view returns (address) {\n        address owner;\n        assembly {\n            owner := sload(OWNER_KEY)\n        }\n        return owner;\n    }\n\n    /**\n     * @notice Gets the code hash for a given account.\n     *\n     * @param _account Address of the account to get a code hash for.\n     *\n     * @return Code hash for the account.\n     */\n    function _getAccountCodeHash(address _account) internal view returns (bytes32) {\n        bytes32 codeHash;\n        assembly {\n            codeHash := extcodehash(_account)\n        }\n        return codeHash;\n    }\n}\n"
    },
    "contracts/legacy/LegacyERC20ETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { OptimismMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\n\n/**\n * @custom:legacy\n * @custom:proxied\n * @custom:predeploy 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000\n * @title LegacyERC20ETH\n * @notice LegacyERC20ETH is a legacy contract that held ETH balances before the Bedrock upgrade.\n *         All ETH balances held within this contract were migrated to the state trie as part of\n *         the Bedrock upgrade. Functions within this contract that mutate state were already\n *         disabled as part of the EVM equivalence upgrade.\n */\ncontract LegacyERC20ETH is OptimismMintableERC20 {\n    /**\n     * @notice Initializes the contract as an Optimism Mintable ERC20.\n     */\n    constructor()\n        OptimismMintableERC20(Predeploys.L2_STANDARD_BRIDGE, address(0), \"Ether\", \"ETH\")\n    {}\n\n    /**\n     * @custom:blocked\n     * @notice Mints some amount of ETH.\n     */\n    function mint(address, uint256) public virtual override {\n        revert(\"LegacyERC20ETH: mint is disabled\");\n    }\n\n    /**\n     * @custom:blocked\n     * @notice Burns some amount of ETH.\n     */\n    function burn(address, uint256) public virtual override {\n        revert(\"LegacyERC20ETH: burn is disabled\");\n    }\n\n    /**\n     * @custom:blocked\n     * @notice Transfers some amount of ETH.\n     */\n    function transfer(address, uint256) public virtual override returns (bool) {\n        revert(\"LegacyERC20ETH: transfer is disabled\");\n    }\n\n    /**\n     * @custom:blocked\n     * @notice Approves a spender to spend some amount of ETH.\n     */\n    function approve(address, uint256) public virtual override returns (bool) {\n        revert(\"LegacyERC20ETH: approve is disabled\");\n    }\n\n    /**\n     * @custom:blocked\n     * @notice Transfers funds from some sender account.\n     */\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual override returns (bool) {\n        revert(\"LegacyERC20ETH: transferFrom is disabled\");\n    }\n\n    /**\n     * @custom:blocked\n     * @notice Increases the allowance of a spender.\n     */\n    function increaseAllowance(address, uint256) public virtual override returns (bool) {\n        revert(\"LegacyERC20ETH: increaseAllowance is disabled\");\n    }\n\n    /**\n     * @custom:blocked\n     * @notice Decreases the allowance of a spender.\n     */\n    function decreaseAllowance(address, uint256) public virtual override returns (bool) {\n        revert(\"LegacyERC20ETH: decreaseAllowance is disabled\");\n    }\n}\n"
    },
    "contracts/legacy/ResolvedDelegateProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { AddressManager } from \"./AddressManager.sol\";\n\n/**\n * @custom:legacy\n * @title ResolvedDelegateProxy\n * @notice ResolvedDelegateProxy is a legacy proxy contract that makes use of the AddressManager to\n *         resolve the implementation address. We're maintaining this contract for backwards\n *         compatibility so we can manage all legacy proxies where necessary.\n */\ncontract ResolvedDelegateProxy {\n    /**\n     * @notice Mapping used to store the implementation name that corresponds to this contract. A\n     *         mapping was originally used as a way to bypass the same issue normally solved by\n     *         storing the implementation address in a specific storage slot that does not conflict\n     *         with any other storage slot. Generally NOT a safe solution but works as long as the\n     *         implementation does not also keep a mapping in the first storage slot.\n     */\n    mapping(address => string) private implementationName;\n\n    /**\n     * @notice Mapping used to store the address of the AddressManager contract where the\n     *         implementation address will be resolved from. Same concept here as with the above\n     *         mapping. Also generally unsafe but fine if the implementation doesn't keep a mapping\n     *         in the second storage slot.\n     */\n    mapping(address => AddressManager) private addressManager;\n\n    /**\n     * @param _addressManager  Address of the AddressManager.\n     * @param _implementationName implementationName of the contract to proxy to.\n     */\n    constructor(AddressManager _addressManager, string memory _implementationName) {\n        addressManager[address(this)] = _addressManager;\n        implementationName[address(this)] = _implementationName;\n    }\n\n    /**\n     * @notice Fallback, performs a delegatecall to the resolved implementation address.\n     */\n    // solhint-disable-next-line no-complex-fallback\n    fallback() external payable {\n        address target = addressManager[address(this)].getAddress(\n            (implementationName[address(this)])\n        );\n\n        require(target != address(0), \"ResolvedDelegateProxy: target address must be initialized\");\n\n        // slither-disable-next-line controlled-delegatecall\n        (bool success, bytes memory returndata) = target.delegatecall(msg.data);\n\n        if (success == true) {\n            assembly {\n                return(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            assembly {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/Burn.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title Burn\n * @notice Utilities for burning stuff.\n */\nlibrary Burn {\n    /**\n     * Burns a given amount of ETH.\n     *\n     * @param _amount Amount of ETH to burn.\n     */\n    function eth(uint256 _amount) internal {\n        new Burner{ value: _amount }();\n    }\n\n    /**\n     * Burns a given amount of gas.\n     *\n     * @param _amount Amount of gas to burn.\n     */\n    function gas(uint256 _amount) internal view {\n        uint256 i = 0;\n        uint256 initialGas = gasleft();\n        while (initialGas - gasleft() < _amount) {\n            ++i;\n        }\n    }\n}\n\n/**\n * @title Burner\n * @notice Burner self-destructs on creation and sends all ETH to itself, removing all ETH given to\n *         the contract from the circulating supply. Self-destructing is the only way to remove ETH\n *         from the circulating supply.\n */\ncontract Burner {\n    constructor() payable {\n        selfdestruct(payable(address(this)));\n    }\n}\n"
    },
    "contracts/libraries/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Bytes\n * @notice Bytes is a library for manipulating byte arrays.\n */\nlibrary Bytes {\n    /**\n     * @custom:attribution https://github.com/GNSPS/solidity-bytes-utils\n     * @notice Slices a byte array with a given starting index and length. Returns a new byte array\n     *         as opposed to a pointer to the original array. Will throw if trying to slice more\n     *         bytes than exist in the array.\n     *\n     * @param _bytes Byte array to slice.\n     * @param _start Starting index of the slice.\n     * @param _length Length of the slice.\n     *\n     * @return Slice of the input byte array.\n     */\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        unchecked {\n            require(_length + 31 >= _length, \"slice_overflow\");\n            require(_start + _length >= _start, \"slice_overflow\");\n            require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n        }\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    /**\n     * @notice Slices a byte array with a given starting index up to the end of the original byte\n     *         array. Returns a new array rathern than a pointer to the original.\n     *\n     * @param _bytes Byte array to slice.\n     * @param _start Starting index of the slice.\n     *\n     * @return Slice of the input byte array.\n     */\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\n        if (_start >= _bytes.length) {\n            return bytes(\"\");\n        }\n        return slice(_bytes, _start, _bytes.length - _start);\n    }\n\n    /**\n     * @notice Converts a byte array into a nibble array by splitting each byte into two nibbles.\n     *         Resulting nibble array will be exactly twice as long as the input byte array.\n     *\n     * @param _bytes Input byte array to convert.\n     *\n     * @return Resulting nibble array.\n     */\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\n        bytes memory nibbles = new bytes(_bytes.length * 2);\n        for (uint256 i = 0; i < _bytes.length; i++) {\n            nibbles[i * 2] = _bytes[i] >> 4;\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\n        }\n        return nibbles;\n    }\n\n    /**\n     * @notice Generates a byte array from a nibble array by joining each set of two nibbles into a\n     *         single byte. Resulting byte array will be half as long as the input byte array.\n     *\n     * @param _bytes Input nibble array to convert.\n     *\n     * @return Resulting byte array.\n     */\n    function fromNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\n        bytes memory ret = new bytes(_bytes.length / 2);\n        for (uint256 i = 0; i < ret.length; i++) {\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\n        }\n        return ret;\n    }\n\n    /**\n     * @notice Compares two byte arrays by comparing their keccak256 hashes.\n     *\n     * @param _bytes First byte array to compare.\n     * @param _other Second byte array to compare.\n     *\n     * @return True if the two byte arrays are equal, false otherwise.\n     */\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\n        return keccak256(_bytes) == keccak256(_other);\n    }\n}\n"
    },
    "contracts/libraries/Encoding.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Types } from \"./Types.sol\";\nimport { Hashing } from \"./Hashing.sol\";\nimport { RLPWriter } from \"./rlp/RLPWriter.sol\";\n\n/**\n * @title Encoding\n * @notice Encoding handles Optimism's various different encoding schemes.\n */\nlibrary Encoding {\n    /**\n     * @notice RLP encodes the L2 transaction that would be generated when a given deposit is sent\n     *         to the L2 system. Useful for searching for a deposit in the L2 system.\n     *         This currently only supports user deposits and not system\n     *         transactions.\n     *\n     * @param _tx User deposit transaction to encode.\n     *\n     * @return RLP encoded L2 deposit transaction.\n     */\n    function encodeDepositTransaction(Types.UserDepositTransaction memory _tx)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes32 source = Hashing.hashDepositSource(_tx.l1BlockHash, _tx.logIndex);\n        bytes[] memory raw = new bytes[](8);\n        raw[0] = RLPWriter.writeBytes(abi.encodePacked(source));\n        raw[1] = RLPWriter.writeAddress(_tx.from);\n        raw[2] = _tx.isCreation ? RLPWriter.writeBytes(\"\") : RLPWriter.writeAddress(_tx.to);\n        raw[3] = RLPWriter.writeUint(_tx.mint);\n        raw[4] = RLPWriter.writeUint(_tx.value);\n        raw[5] = RLPWriter.writeUint(uint256(_tx.gasLimit));\n        raw[6] = RLPWriter.writeBool(false);\n        raw[7] = RLPWriter.writeBytes(_tx.data);\n        return abi.encodePacked(uint8(0x7e), RLPWriter.writeList(raw));\n    }\n\n    /**\n     * @notice Encodes the cross domain message based on the version that is encoded into the\n     *         message nonce.\n     *\n     * @param _nonce    Message nonce with version encoded into the first two bytes.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _value    ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Encoded cross domain message.\n     */\n    function encodeCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes memory) {\n        (, uint16 version) = decodeVersionedNonce(_nonce);\n        if (version == 0) {\n            return encodeCrossDomainMessageV0(_target, _sender, _data, _nonce);\n        } else if (version == 1) {\n            return encodeCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data);\n        } else {\n            revert(\"Encoding: unknown cross domain message version\");\n        }\n    }\n\n    /**\n     * @notice Encodes a cross domain message based on the V0 (legacy) encoding.\n     *\n     * @param _target Address of the target of the message.\n     * @param _sender Address of the sender of the message.\n     * @param _data   Data to send with the message.\n     * @param _nonce  Message nonce.\n     *\n     * @return Encoded cross domain message.\n     */\n    function encodeCrossDomainMessageV0(\n        address _target,\n        address _sender,\n        bytes memory _data,\n        uint256 _nonce\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                \"relayMessage(address,address,bytes,uint256)\",\n                _target,\n                _sender,\n                _data,\n                _nonce\n            );\n    }\n\n    /**\n     * @notice Encodes a cross domain message based on the V1 (current) encoding.\n     *\n     * @param _nonce    Message nonce.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _value    ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Encoded cross domain message.\n     */\n    function encodeCrossDomainMessageV1(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                \"relayMessage(uint256,address,address,uint256,uint256,bytes)\",\n                _nonce,\n                _sender,\n                _target,\n                _value,\n                _gasLimit,\n                _data\n            );\n    }\n\n    /**\n     * @notice Adds a version number into the first two bytes of a message nonce.\n     *\n     * @param _nonce   Message nonce to encode into.\n     * @param _version Version number to encode into the message nonce.\n     *\n     * @return Message nonce with version encoded into the first two bytes.\n     */\n    function encodeVersionedNonce(uint240 _nonce, uint16 _version) internal pure returns (uint256) {\n        uint256 nonce;\n        assembly {\n            nonce := or(shl(240, _version), _nonce)\n        }\n        return nonce;\n    }\n\n    /**\n     * @notice Pulls the version out of a version-encoded nonce.\n     *\n     * @param _nonce Message nonce with version encoded into the first two bytes.\n     *\n     * @return Nonce without encoded version.\n     * @return Version of the message.\n     */\n    function decodeVersionedNonce(uint256 _nonce) internal pure returns (uint240, uint16) {\n        uint240 nonce;\n        uint16 version;\n        assembly {\n            nonce := and(_nonce, 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            version := shr(240, _nonce)\n        }\n        return (nonce, version);\n    }\n}\n"
    },
    "contracts/libraries/Hashing.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Types } from \"./Types.sol\";\nimport { Encoding } from \"./Encoding.sol\";\n\n/**\n * @title Hashing\n * @notice Hashing handles Optimism's various different hashing schemes.\n */\nlibrary Hashing {\n    /**\n     * @notice Computes the hash of the RLP encoded L2 transaction that would be generated when a\n     *         given deposit is sent to the L2 system. Useful for searching for a deposit in the L2\n     *         system.\n     *\n     * @param _tx User deposit transaction to hash.\n     *\n     * @return Hash of the RLP encoded L2 deposit transaction.\n     */\n    function hashDepositTransaction(Types.UserDepositTransaction memory _tx)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(Encoding.encodeDepositTransaction(_tx));\n    }\n\n    /**\n     * @notice Computes the deposit transaction's \"source hash\", a value that guarantees the hash\n     *         of the L2 transaction that corresponds to a deposit is unique and is\n     *         deterministically generated from L1 transaction data.\n     *\n     * @param _l1BlockHash Hash of the L1 block where the deposit was included.\n     * @param _logIndex    The index of the log that created the deposit transaction.\n     *\n     * @return Hash of the deposit transaction's \"source hash\".\n     */\n    function hashDepositSource(bytes32 _l1BlockHash, uint256 _logIndex)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 depositId = keccak256(abi.encode(_l1BlockHash, _logIndex));\n        return keccak256(abi.encode(bytes32(0), depositId));\n    }\n\n    /**\n     * @notice Hashes the cross domain message based on the version that is encoded into the\n     *         message nonce.\n     *\n     * @param _nonce    Message nonce with version encoded into the first two bytes.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _value    ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Hashed cross domain message.\n     */\n    function hashCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes32) {\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\n        if (version == 0) {\n            return hashCrossDomainMessageV0(_target, _sender, _data, _nonce);\n        } else if (version == 1) {\n            return hashCrossDomainMessageV1(_nonce, _sender, _target, _value, _gasLimit, _data);\n        } else {\n            revert(\"Hashing: unknown cross domain message version\");\n        }\n    }\n\n    /**\n     * @notice Hashes a cross domain message based on the V0 (legacy) encoding.\n     *\n     * @param _target Address of the target of the message.\n     * @param _sender Address of the sender of the message.\n     * @param _data   Data to send with the message.\n     * @param _nonce  Message nonce.\n     *\n     * @return Hashed cross domain message.\n     */\n    function hashCrossDomainMessageV0(\n        address _target,\n        address _sender,\n        bytes memory _data,\n        uint256 _nonce\n    ) internal pure returns (bytes32) {\n        return keccak256(Encoding.encodeCrossDomainMessageV0(_target, _sender, _data, _nonce));\n    }\n\n    /**\n     * @notice Hashes a cross domain message based on the V1 (current) encoding.\n     *\n     * @param _nonce    Message nonce.\n     * @param _sender   Address of the sender of the message.\n     * @param _target   Address of the target of the message.\n     * @param _value    ETH value to send to the target.\n     * @param _gasLimit Gas limit to use for the message.\n     * @param _data     Data to send with the message.\n     *\n     * @return Hashed cross domain message.\n     */\n    function hashCrossDomainMessageV1(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes32) {\n        return\n            keccak256(\n                Encoding.encodeCrossDomainMessageV1(\n                    _nonce,\n                    _sender,\n                    _target,\n                    _value,\n                    _gasLimit,\n                    _data\n                )\n            );\n    }\n\n    /**\n     * @notice Derives the withdrawal hash according to the encoding in the L2 Withdrawer contract\n     *\n     * @param _tx Withdrawal transaction to hash.\n     *\n     * @return Hashed withdrawal transaction.\n     */\n    function hashWithdrawal(Types.WithdrawalTransaction memory _tx)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(_tx.nonce, _tx.sender, _tx.target, _tx.value, _tx.gasLimit, _tx.data)\n            );\n    }\n\n    /**\n     * @notice Hashes the various elements of an output root proof into an output root hash which\n     *         can be used to check if the proof is valid.\n     *\n     * @param _outputRootProof Output root proof which should hash to an output root.\n     *\n     * @return Hashed output root proof.\n     */\n    function hashOutputRootProof(Types.OutputRootProof memory _outputRootProof)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    _outputRootProof.version,\n                    _outputRootProof.stateRoot,\n                    _outputRootProof.withdrawerStorageRoot,\n                    _outputRootProof.latestBlockhash\n                )\n            );\n    }\n}\n"
    },
    "contracts/libraries/Predeploys.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Predeploys\n * @notice Contains constant addresses for contracts that are pre-deployed to the L2 system.\n */\nlibrary Predeploys {\n    /**\n     * @notice Address of the L2ToL1MessagePasser predeploy.\n     */\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\n\n    /**\n     * @notice Address of the L2CrossDomainMessenger predeploy.\n     */\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\n        0x4200000000000000000000000000000000000007;\n\n    /**\n     * @notice Address of the L2StandardBridge predeploy.\n     */\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\n\n    /**\n     * @notice Address of the SequencerFeeWallet predeploy.\n     */\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\n\n    /**\n     * @notice Address of the OptimismMintableERC20Factory predeploy.\n     */\n    address internal constant OPTIMISM_MINTABLE_ERC20_FACTORY =\n        0x4200000000000000000000000000000000000012;\n\n    /**\n     * @notice Address of the L1Block predeploy.\n     */\n    address internal constant L1_BLOCK_ATTRIBUTES = 0x4200000000000000000000000000000000000015;\n\n    /**\n     * @custom:legacy\n     * @notice Address of the L1MessageSender predeploy. Deprecated. Use L2CrossDomainMessenger\n     *         or access tx.origin (or msg.sender) in a L1 to L2 transaction instead.\n     */\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\n\n    /**\n     * @custom:legacy\n     * @notice Address of the DeployerWhitelist predeploy. No longer active.\n     */\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\n\n    /**\n     * @custom:legacy\n     * @notice Address of the LegacyERC20ETH predeploy. Deprecated. Balances are migrated to the\n     *         state trie as of the Bedrock upgrade. Contract has been locked and write functions\n     *         can no longer be accessed.\n     */\n    address internal constant LEGACY_ERC20_ETH = 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000;\n\n    /**\n     * @custom:legacy\n     * @notice Address of the L1BlockNumber predeploy. Deprecated. Use the L1Block predeploy\n     *         instead, which exposes more information about the L1 state.\n     */\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\n\n    /**\n     * @notice Address of the GasPriceOracle predeploy. Includes fee information\n     *         and helpers for computing the L1 portion of the transaction fee.\n     */\n    address internal constant GAS_PRICE_ORACLE = 0x420000000000000000000000000000000000000F;\n}\n"
    },
    "contracts/libraries/SafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title SafeCall\n * @notice Perform low level safe calls\n */\nlibrary SafeCall {\n    /**\n     * @notice Perform a low level call without copying any returndata\n     *\n     * @param _target   Address to call\n     * @param _gas      Amount of gas to pass to the call\n     * @param _value    Amount of value to pass to the call\n     * @param _calldata Calldata to pass to the call\n     */\n    function call(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        bytes memory _calldata\n    ) internal returns (bool) {\n        bool _success;\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n        }\n        return _success;\n    }\n}\n"
    },
    "contracts/libraries/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Types\n * @notice Contains various types used throughout the Optimism contract system.\n */\nlibrary Types {\n    /**\n     * @notice OutputProposal represents a commitment to the L2 state. The timestamp is the L1\n     *         timestamp that the output root is posted. This timestamp is used to verify that the\n     *         finalization period has passed since the output root was submitted.\n     */\n    struct OutputProposal {\n        bytes32 outputRoot;\n        uint256 timestamp;\n    }\n\n    /**\n     * @notice Struct representing the elements that are hashed together to generate an output root\n     *         which itself represents a snapshot of the L2 state.\n     */\n    struct OutputRootProof {\n        bytes32 version;\n        bytes32 stateRoot;\n        bytes32 withdrawerStorageRoot;\n        bytes32 latestBlockhash;\n    }\n\n    /**\n     * @notice Struct representing a deposit transaction (L1 => L2 transaction) created by an end\n     *         user (as opposed to a system deposit transaction generated by the system).\n     */\n    struct UserDepositTransaction {\n        address from;\n        address to;\n        bool isCreation;\n        uint256 value;\n        uint256 mint;\n        uint64 gasLimit;\n        bytes data;\n        bytes32 l1BlockHash;\n        uint256 logIndex;\n    }\n\n    /**\n     * @notice Struct representing a withdrawal transaction.\n     */\n    struct WithdrawalTransaction {\n        uint256 nonce;\n        address sender;\n        address target;\n        uint256 value;\n        uint256 gasLimit;\n        bytes data;\n    }\n}\n"
    },
    "contracts/libraries/rlp/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @custom:attribution https://github.com/hamdiallam/Solidity-RLP\n * @title RLPReader\n * @notice RLPReader is a library for parsing RLP-encoded byte arrays into Solidity types. Adapted\n *         from Solidity-RLP (https://github.com/hamdiallam/Solidity-RLP) by Hamdi Allam with\n *         various tweaks to improve readability.\n */\nlibrary RLPReader {\n    /**\n     * @notice RLP item types.\n     *\n     * @custom:value DATA_ITEM Represents an RLP data item (NOT a list).\n     * @custom:value LIST_ITEM Represents an RLP list item.\n     */\n    enum RLPItemType {\n        DATA_ITEM,\n        LIST_ITEM\n    }\n\n    /**\n     * @notice Struct representing an RLP item.\n     */\n    struct RLPItem {\n        uint256 length;\n        uint256 ptr;\n    }\n\n    /**\n     * @notice Max list length that this library will accept.\n     */\n    uint256 internal constant MAX_LIST_LENGTH = 32;\n\n    /**\n     * @notice Converts bytes to a reference to memory position and length.\n     *\n     * @param _in Input bytes to convert.\n     *\n     * @return Output memory reference.\n     */\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {\n        uint256 ptr;\n        assembly {\n            ptr := add(_in, 32)\n        }\n\n        return RLPItem({ length: _in.length, ptr: ptr });\n    }\n\n    /**\n     * @notice Reads an RLP list value into a list of RLP items.\n     *\n     * @param _in RLP list value.\n     *\n     * @return Decoded RLP list items.\n     */\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {\n        (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.LIST_ITEM, \"RLPReader: invalid RLP list value\");\n\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\n        // writing to the length. Since we can't know the number of RLP items without looping over\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\n        // simply set a reasonable maximum list length and decrease the size before we finish.\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\n\n        uint256 itemCount = 0;\n        uint256 offset = listOffset;\n        while (offset < _in.length) {\n            require(\n                itemCount < MAX_LIST_LENGTH,\n                \"RLPReader: provided RLP list exceeds max list length\"\n            );\n\n            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(\n                RLPItem({ length: _in.length - offset, ptr: _in.ptr + offset })\n            );\n\n            out[itemCount] = RLPItem({ length: itemLength + itemOffset, ptr: _in.ptr + offset });\n\n            itemCount += 1;\n            offset += itemOffset + itemLength;\n        }\n\n        // Decrease the array size to match the actual item count.\n        assembly {\n            mstore(out, itemCount)\n        }\n\n        return out;\n    }\n\n    /**\n     * @notice Reads an RLP list value into a list of RLP items.\n     *\n     * @param _in RLP list value.\n     *\n     * @return Decoded RLP list items.\n     */\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {\n        return readList(toRLPItem(_in));\n    }\n\n    /**\n     * @notice Reads an RLP bytes value into bytes.\n     *\n     * @param _in RLP bytes value.\n     *\n     * @return Decoded bytes.\n     */\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.DATA_ITEM, \"RLPReader: invalid RLP bytes value\");\n\n        return _copy(_in.ptr, itemOffset, itemLength);\n    }\n\n    /**\n     * @notice Reads an RLP bytes value into bytes.\n     *\n     * @param _in RLP bytes value.\n     *\n     * @return Decoded bytes.\n     */\n    function readBytes(bytes memory _in) internal pure returns (bytes memory) {\n        return readBytes(toRLPItem(_in));\n    }\n\n    /**\n     * @notice Reads an RLP string value into a string.\n     *\n     * @param _in RLP string value.\n     *\n     * @return Decoded string.\n     */\n    function readString(RLPItem memory _in) internal pure returns (string memory) {\n        return string(readBytes(_in));\n    }\n\n    /**\n     * @notice Reads an RLP string value into a string.\n     *\n     * @param _in RLP string value.\n     *\n     * @return Decoded string.\n     */\n    function readString(bytes memory _in) internal pure returns (string memory) {\n        return readString(toRLPItem(_in));\n    }\n\n    /**\n     * @notice Reads an RLP bytes32 value into a bytes32.\n     *\n     * @param _in RLP bytes32 value.\n     *\n     * @return Decoded bytes32.\n     */\n    function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {\n        require(_in.length <= 33, \"RLPReader: invalid RLP bytes32 value\");\n\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.DATA_ITEM, \"RLPReader: invalid RLP bytes32 value\");\n\n        uint256 ptr = _in.ptr + itemOffset;\n        bytes32 out;\n        assembly {\n            out := mload(ptr)\n\n            // Shift the bytes over to match the item size.\n            if lt(itemLength, 32) {\n                out := div(out, exp(256, sub(32, itemLength)))\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * @notice Reads an RLP bytes32 value into a bytes32.\n     *\n     * @param _in RLP bytes32 value.\n     *\n     * @return Decoded bytes32.\n     */\n    function readBytes32(bytes memory _in) internal pure returns (bytes32) {\n        return readBytes32(toRLPItem(_in));\n    }\n\n    /**\n     * @notice Reads an RLP uint256 value into a uint256.\n     *\n     * @param _in RLP uint256 value.\n     *\n     * @return Decoded uint256.\n     */\n    function readUint256(RLPItem memory _in) internal pure returns (uint256) {\n        return uint256(readBytes32(_in));\n    }\n\n    /**\n     * @notice Reads an RLP uint256 value into a uint256.\n     *\n     * @param _in RLP uint256 value.\n     *\n     * @return Decoded uint256.\n     */\n    function readUint256(bytes memory _in) internal pure returns (uint256) {\n        return readUint256(toRLPItem(_in));\n    }\n\n    /**\n     * @notice Reads an RLP bool value into a bool.\n     *\n     * @param _in RLP bool value.\n     *\n     * @return Decoded bool.\n     */\n    function readBool(RLPItem memory _in) internal pure returns (bool) {\n        require(_in.length == 1, \"RLPReader: invalid RLP boolean value\");\n\n        uint256 ptr = _in.ptr;\n        uint256 out;\n        assembly {\n            out := byte(0, mload(ptr))\n        }\n\n        require(out == 0 || out == 1, \"RLPReader: invalid RLP boolean value, must be 0 or 1\");\n\n        return out != 0;\n    }\n\n    /**\n     * @notice Reads an RLP bool value into a bool.\n     *\n     * @param _in RLP bool value.\n     *\n     * @return Decoded bool.\n     */\n    function readBool(bytes memory _in) internal pure returns (bool) {\n        return readBool(toRLPItem(_in));\n    }\n\n    /**\n     * @notice Reads an RLP address value into a address.\n     *\n     * @param _in RLP address value.\n     *\n     * @return Decoded address.\n     */\n    function readAddress(RLPItem memory _in) internal pure returns (address) {\n        if (_in.length == 1) {\n            return address(0);\n        }\n\n        require(_in.length == 21, \"RLPReader: invalid RLP address value\");\n\n        return address(uint160(readUint256(_in)));\n    }\n\n    /**\n     * @notice Reads an RLP address value into a address.\n     *\n     * @param _in RLP address value.\n     *\n     * @return Decoded address.\n     */\n    function readAddress(bytes memory _in) internal pure returns (address) {\n        return readAddress(toRLPItem(_in));\n    }\n\n    /**\n     * @notice Reads the raw bytes of an RLP item.\n     *\n     * @param _in RLP item to read.\n     *\n     * @return Raw RLP bytes.\n     */\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {\n        return _copy(_in);\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * @notice Decodes the length of an RLP item.\n     *\n     * @param _in RLP item to decode.\n     *\n     * @return Offset of the encoded data.\n     * @return Length of the encoded data.\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\n     */\n    function _decodeLength(RLPItem memory _in)\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            RLPItemType\n        )\n    {\n        require(_in.length > 0, \"RLPReader: RLP item cannot be null\");\n\n        uint256 ptr = _in.ptr;\n        uint256 prefix;\n        assembly {\n            prefix := byte(0, mload(ptr))\n        }\n\n        if (prefix <= 0x7f) {\n            // Single byte.\n\n            return (0, 1, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xb7) {\n            // Short string.\n\n            // slither-disable-next-line variable-scope\n            uint256 strLen = prefix - 0x80;\n\n            require(_in.length > strLen, \"RLPReader: invalid RLP short string\");\n\n            return (1, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xbf) {\n            // Long string.\n            uint256 lenOfStrLen = prefix - 0xb7;\n\n            require(_in.length > lenOfStrLen, \"RLPReader: invalid RLP long string length\");\n\n            uint256 strLen;\n            assembly {\n                // Pick out the string length.\n                strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))\n            }\n\n            require(_in.length > lenOfStrLen + strLen, \"RLPReader: invalid RLP long string\");\n\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xf7) {\n            // Short list.\n            // slither-disable-next-line variable-scope\n            uint256 listLen = prefix - 0xc0;\n\n            require(_in.length > listLen, \"RLPReader: invalid RLP short list\");\n\n            return (1, listLen, RLPItemType.LIST_ITEM);\n        } else {\n            // Long list.\n            uint256 lenOfListLen = prefix - 0xf7;\n\n            require(_in.length > lenOfListLen, \"RLPReader: invalid RLP long list length\");\n\n            uint256 listLen;\n            assembly {\n                // Pick out the list length.\n                listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))\n            }\n\n            require(_in.length > lenOfListLen + listLen, \"RLPReader: invalid RLP long list\");\n\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\n        }\n    }\n\n    /**\n     * @notice Copies the bytes from a memory location.\n     *\n     * @param _src    Pointer to the location to read from.\n     * @param _offset Offset to start reading from.\n     * @param _length Number of bytes to read.\n     *\n     * @return Copied bytes.\n     */\n    function _copy(\n        uint256 _src,\n        uint256 _offset,\n        uint256 _length\n    ) private pure returns (bytes memory) {\n        bytes memory out = new bytes(_length);\n        if (out.length == 0) {\n            return out;\n        }\n\n        uint256 src = _src + _offset;\n        uint256 dest;\n        assembly {\n            dest := add(out, 32)\n        }\n\n        // Copy over as many complete words as we can.\n        for (uint256 i = 0; i < _length / 32; i++) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += 32;\n            dest += 32;\n        }\n\n        // Pick out the remaining bytes.\n        uint256 mask;\n        unchecked {\n            mask = 256**(32 - (_length % 32)) - 1;\n        }\n\n        assembly {\n            mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\n        }\n        return out;\n    }\n\n    /**\n     * @notice Copies an RLP item into bytes.\n     *\n     * @param _in RLP item to copy.\n     *\n     * @return Copied bytes.\n     */\n    function _copy(RLPItem memory _in) private pure returns (bytes memory) {\n        return _copy(_in.ptr, 0, _in.length);\n    }\n}\n"
    },
    "contracts/libraries/rlp/RLPWriter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @custom:attribution https://github.com/bakaoh/solidity-rlp-encode\n * @title RLPWriter\n * @author RLPWriter is a library for encoding Solidity types to RLP bytes. Adapted from Bakaoh's\n *         RLPEncode library (https://github.com/bakaoh/solidity-rlp-encode) with minor\n *         modifications to improve legibility.\n */\nlibrary RLPWriter {\n    /**\n     * @notice RLP encodes a byte string.\n     *\n     * @param _in The byte string to encode.\n     *\n     * @return The RLP encoded string in bytes.\n     */\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\n            encoded = _in;\n        } else {\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\n        }\n\n        return encoded;\n    }\n\n    /**\n     * @notice RLP encodes a list of RLP encoded byte byte strings.\n     *\n     * @param _in The list of RLP encoded byte strings.\n     *\n     * @return The RLP encoded list of items in bytes.\n     */\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\n        bytes memory list = _flatten(_in);\n        return abi.encodePacked(_writeLength(list.length, 192), list);\n    }\n\n    /**\n     * @notice RLP encodes a string.\n     *\n     * @param _in The string to encode.\n     *\n     * @return The RLP encoded string in bytes.\n     */\n    function writeString(string memory _in) internal pure returns (bytes memory) {\n        return writeBytes(bytes(_in));\n    }\n\n    /**\n     * @notice RLP encodes an address.\n     *\n     * @param _in The address to encode.\n     *\n     * @return The RLP encoded address in bytes.\n     */\n    function writeAddress(address _in) internal pure returns (bytes memory) {\n        return writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * @notice RLP encodes a uint.\n     *\n     * @param _in The uint256 to encode.\n     *\n     * @return The RLP encoded uint256 in bytes.\n     */\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\n        return writeBytes(_toBinary(_in));\n    }\n\n    /**\n     * @notice RLP encodes a bool.\n     *\n     * @param _in The bool to encode.\n     *\n     * @return The RLP encoded bool in bytes.\n     */\n    function writeBool(bool _in) internal pure returns (bytes memory) {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\n        return encoded;\n    }\n\n    /**\n     * @notice Encode the first byte and then the `len` in binary form if `length` is more than 55.\n     *\n     * @param _len    The length of the string or the payload.\n     * @param _offset 128 if item is string, 192 if item is list.\n     *\n     * @return RLP encoded bytes.\n     */\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\n        } else {\n            uint256 lenLen;\n            uint256 i = 1;\n            while (_len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\n            for (i = 1; i <= lenLen; i++) {\n                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\n            }\n        }\n\n        return encoded;\n    }\n\n    /**\n     * @notice Encode integer in big endian binary form with no leading zeroes.\n     *\n     * @param _x The integer to encode.\n     *\n     * @return RLP encoded bytes.\n     */\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\n        bytes memory b = abi.encodePacked(_x);\n\n        uint256 i = 0;\n        for (; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n\n        bytes memory res = new bytes(32 - i);\n        for (uint256 j = 0; j < res.length; j++) {\n            res[j] = b[i++];\n        }\n\n        return res;\n    }\n\n    /**\n     * @custom:attribution https://github.com/Arachnid/solidity-stringutils\n     * @notice Copies a piece of memory to another location.\n     *\n     * @param _dest Destination location.\n     * @param _src  Source location.\n     * @param _len  Length of memory to copy.\n     */\n    function _memcpy(\n        uint256 _dest,\n        uint256 _src,\n        uint256 _len\n    ) private pure {\n        uint256 dest = _dest;\n        uint256 src = _src;\n        uint256 len = _len;\n\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint256 mask;\n        unchecked {\n            mask = 256**(32 - len) - 1;\n        }\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * @custom:attribution https://github.com/sammayo/solidity-rlp-encoder\n     * @notice Flattens a list of byte strings into one byte string.\n     *\n     * @param _list List of byte strings to flatten.\n     *\n     * @return The flattened byte string.\n     */\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 len;\n        uint256 i = 0;\n        for (; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint256 flattenedPtr;\n        assembly {\n            flattenedPtr := add(flattened, 0x20)\n        }\n\n        for (i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n\n            uint256 listPtr;\n            assembly {\n                listPtr := add(item, 0x20)\n            }\n\n            _memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += _list[i].length;\n        }\n\n        return flattened;\n    }\n}\n"
    },
    "contracts/libraries/trie/MerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Bytes } from \"../Bytes.sol\";\nimport { RLPReader } from \"../rlp/RLPReader.sol\";\nimport { RLPWriter } from \"../rlp/RLPWriter.sol\";\n\n/**\n * @title MerkleTrie\n * @notice MerkleTrie is a small library for verifying standard Ethereum Merkle-Patricia trie\n *         inclusion proofs. By default, this library assumes a hexary trie. One can change the\n *         trie radix constant to support other trie radixes.\n */\nlibrary MerkleTrie {\n    /**\n     * @notice Struct representing a node in the trie.\n     */\n    struct TrieNode {\n        bytes encoded;\n        RLPReader.RLPItem[] decoded;\n    }\n\n    /**\n     * @notice Determines the number of elements per branch node.\n     */\n    uint256 internal constant TREE_RADIX = 16;\n\n    /**\n     * @notice Branch nodes have TREE_RADIX elements and one value element.\n     */\n    uint256 internal constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\n\n    /**\n     * @notice Leaf nodes and extension nodes have two elements, a `path` and a `value`.\n     */\n    uint256 internal constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\n\n    /**\n     * @notice Prefix for even-nibbled extension node paths.\n     */\n    uint8 internal constant PREFIX_EXTENSION_EVEN = 0;\n\n    /**\n     * @notice Prefix for odd-nibbled extension node paths.\n     */\n    uint8 internal constant PREFIX_EXTENSION_ODD = 1;\n\n    /**\n     * @notice Prefix for even-nibbled leaf node paths.\n     */\n    uint8 internal constant PREFIX_LEAF_EVEN = 2;\n\n    /**\n     * @notice Prefix for odd-nibbled leaf node paths.\n     */\n    uint8 internal constant PREFIX_LEAF_ODD = 3;\n\n    /**\n     * @notice RLP representation of `NULL`.\n     */\n    bytes1 internal constant RLP_NULL = bytes1(0x80);\n\n    /**\n     * @notice Verifies a proof that a given key/value pair is present in the trie.\n     *\n     * @param _key   Key of the node to search for, as a hex string.\n     * @param _value Value of the node to search for, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike traditional Merkle\n     *               trees, this proof is executed top-down and consists of a list of RLP-encoded\n     *               nodes that make a path down to the target node.\n     * @param _root  Known root of the Merkle trie. Used to verify that the included proof is\n     *               correctly constructed.\n     *\n     * @return Whether or not the proof is valid.\n     */\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool) {\n        (bool exists, bytes memory value) = get(_key, _proof, _root);\n        return (exists && Bytes.equal(_value, value));\n    }\n\n    /**\n     * @notice Retrieves the value associated with a given key.\n     *\n     * @param _key   Key to search for, as hex bytes.\n     * @param _proof Merkle trie inclusion proof for the key.\n     * @param _root  Known root of the Merkle trie.\n     *\n     * @return Whether or not the key exists.\n     * @return Value of the key if it exists.\n     */\n    function get(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool, bytes memory) {\n        TrieNode[] memory proof = _parseProof(_proof);\n        (uint256 pathLength, bytes memory keyRemainder, bool isFinalNode) = _walkNodePath(\n            proof,\n            _key,\n            _root\n        );\n\n        bool exists = keyRemainder.length == 0;\n\n        require(exists || isFinalNode, \"MerkleTrie: provided proof is invalid\");\n\n        bytes memory value = exists ? _getNodeValue(proof[pathLength - 1]) : bytes(\"\");\n\n        return (exists, value);\n    }\n\n    /**\n     * @notice Walks through a proof using a provided key.\n     *\n     * @param _proof Inclusion proof to walk through.\n     * @param _key   Key to use for the walk.\n     * @param _root  Known root of the trie.\n     *\n     * @return Length of the final path\n     * @return Portion of the key remaining after the walk.\n     * @return Whether or not we've hit a dead end.\n     */\n    // solhint-disable-next-line code-complexity\n    function _walkNodePath(\n        TrieNode[] memory _proof,\n        bytes memory _key,\n        bytes32 _root\n    )\n        private\n        pure\n        returns (\n            uint256,\n            bytes memory,\n            bool\n        )\n    {\n        uint256 pathLength = 0;\n        bytes memory key = Bytes.toNibbles(_key);\n\n        bytes32 currentNodeID = _root;\n        uint256 currentKeyIndex = 0;\n        uint256 currentKeyIncrement = 0;\n        TrieNode memory currentNode;\n\n        // Proof is top-down, so we start at the first element (root).\n        for (uint256 i = 0; i < _proof.length; i++) {\n            currentNode = _proof[i];\n            currentKeyIndex += currentKeyIncrement;\n\n            // Keep track of the proof elements we actually need.\n            // It's expensive to resize arrays, so this simply reduces gas costs.\n            pathLength += 1;\n\n            if (currentKeyIndex == 0) {\n                // First proof element is always the root node.\n                require(\n                    keccak256(currentNode.encoded) == currentNodeID,\n                    \"MerkleTrie: invalid root hash\"\n                );\n            } else if (currentNode.encoded.length >= 32) {\n                // Nodes 32 bytes or larger are hashed inside branch nodes.\n                require(\n                    keccak256(currentNode.encoded) == currentNodeID,\n                    \"MerkleTrie: invalid large internal hash\"\n                );\n            } else {\n                // Nodes smaller than 31 bytes aren't hashed.\n                require(\n                    bytes32(currentNode.encoded) == currentNodeID,\n                    \"MerkleTrie: invalid internal node hash\"\n                );\n            }\n\n            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {\n                if (currentKeyIndex == key.length) {\n                    // We've hit the end of the key\n                    // meaning the value should be within this branch node.\n                    break;\n                } else {\n                    // We're not at the end of the key yet.\n                    // Figure out what the next node ID should be and continue.\n                    uint8 branchKey = uint8(key[currentKeyIndex]);\n                    RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];\n                    currentNodeID = _getNodeID(nextNode);\n                    currentKeyIncrement = 1;\n                    continue;\n                }\n            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\n                bytes memory path = _getNodePath(currentNode);\n                uint8 prefix = uint8(path[0]);\n                uint8 offset = 2 - (prefix % 2);\n                bytes memory pathRemainder = Bytes.slice(path, offset);\n                bytes memory keyRemainder = Bytes.slice(key, currentKeyIndex);\n                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);\n\n                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\n                    if (\n                        pathRemainder.length == sharedNibbleLength &&\n                        keyRemainder.length == sharedNibbleLength\n                    ) {\n                        // The key within this leaf matches our key exactly.\n                        // Increment the key index to reflect that we have no remainder.\n                        currentKeyIndex += sharedNibbleLength;\n                    }\n\n                    // We've hit a leaf node, so our next node should be NULL.\n                    currentNodeID = bytes32(RLP_NULL);\n                    break;\n                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\n                    if (sharedNibbleLength != pathRemainder.length) {\n                        // Our extension node is not identical to the remainder.\n                        // We've hit the end of this path\n                        // updates will need to modify this extension.\n                        currentNodeID = bytes32(RLP_NULL);\n                        break;\n                    } else {\n                        // Our extension shares some nibbles.\n                        // Carry on to the next node.\n                        currentNodeID = _getNodeID(currentNode.decoded[1]);\n                        currentKeyIncrement = sharedNibbleLength;\n                        continue;\n                    }\n                } else {\n                    revert(\"MerkleTrie: received a node with an unknown prefix\");\n                }\n            } else {\n                revert(\"MerkleTrie: received an unparseable node\");\n            }\n        }\n\n        // If our node ID is NULL, then we're at a dead end.\n        bool isFinalNode = currentNodeID == bytes32(RLP_NULL);\n        return (pathLength, Bytes.slice(key, currentKeyIndex), isFinalNode);\n    }\n\n    /**\n     * @notice Parses an RLP-encoded proof into something more useful.\n     *\n     * @param _proof RLP-encoded proof to parse.\n     *\n     * @return Proof parsed into easily accessible structs.\n     */\n    function _parseProof(bytes memory _proof) private pure returns (TrieNode[] memory) {\n        RLPReader.RLPItem[] memory nodes = RLPReader.readList(_proof);\n        TrieNode[] memory proof = new TrieNode[](nodes.length);\n\n        for (uint256 i = 0; i < nodes.length; i++) {\n            bytes memory encoded = RLPReader.readBytes(nodes[i]);\n            proof[i] = TrieNode({ encoded: encoded, decoded: RLPReader.readList(encoded) });\n        }\n\n        return proof;\n    }\n\n    /**\n     * @notice Picks out the ID for a node. Node ID is referred to as the \"hash\" within the\n     *         specification, but nodes < 32 bytes are not actually hashed.\n     *\n     * @param _node Node to pull an ID for.\n     *\n     * @return ID for the node, depending on the size of its contents.\n     */\n    function _getNodeID(RLPReader.RLPItem memory _node) private pure returns (bytes32) {\n        bytes memory nodeID;\n\n        if (_node.length < 32) {\n            // Nodes smaller than 32 bytes are RLP encoded.\n            nodeID = RLPReader.readRawBytes(_node);\n        } else {\n            // Nodes 32 bytes or larger are hashed.\n            nodeID = RLPReader.readBytes(_node);\n        }\n\n        return bytes32(nodeID);\n    }\n\n    /**\n     * @notice Gets the path for a leaf or extension node.\n     *\n     * @param _node Node to get a path for.\n     *\n     * @return Node path, converted to an array of nibbles.\n     */\n    function _getNodePath(TrieNode memory _node) private pure returns (bytes memory) {\n        return Bytes.toNibbles(RLPReader.readBytes(_node.decoded[0]));\n    }\n\n    /**\n     * @notice Gets the path for a node.\n     *\n     * @param _node Node to get a value for.\n     *\n     * @return Node value, as hex bytes.\n     */\n    function _getNodeValue(TrieNode memory _node) private pure returns (bytes memory) {\n        return RLPReader.readBytes(_node.decoded[_node.decoded.length - 1]);\n    }\n\n    /**\n     * @notice Utility; determines the number of nibbles shared between two nibble arrays.\n     *\n     * @param _a First nibble array.\n     * @param _b Second nibble array.\n     *\n     * @return Number of shared nibbles.\n     */\n    function _getSharedNibbleLength(bytes memory _a, bytes memory _b)\n        private\n        pure\n        returns (uint256)\n    {\n        uint256 i = 0;\n        while (_a.length > i && _b.length > i && _a[i] == _b[i]) {\n            i++;\n        }\n        return i;\n    }\n}\n"
    },
    "contracts/libraries/trie/SecureMerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/* Library Imports */\nimport { MerkleTrie } from \"./MerkleTrie.sol\";\n\n/**\n * @title SecureMerkleTrie\n * @notice SecureMerkleTrie is a thin wrapper around the MerkleTrie library that hashes the input\n *         keys. Ethereum's state trie hashes input keys before storing them.\n */\nlibrary SecureMerkleTrie {\n    /**\n     * @notice Verifies a proof that a given key/value pair is present in the Merkle trie.\n     *\n     * @param _key   Key of the node to search for, as a hex string.\n     * @param _value Value of the node to search for, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike traditional Merkle\n     *               trees, this proof is executed top-down and consists of a list of RLP-encoded\n     *               nodes that make a path down to the target node.\n     * @param _root  Known root of the Merkle trie. Used to verify that the included proof is\n     *               correctly constructed.\n     *\n     * @return Whether or not the proof is valid.\n     */\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool) {\n        bytes memory key = _getSecureKey(_key);\n        return MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\n    }\n\n    /**\n     * @notice Retrieves the value associated with a given key.\n     *\n     * @param _key   Key to search for, as hex bytes.\n     * @param _proof Merkle trie inclusion proof for the key.\n     * @param _root  Known root of the Merkle trie.\n     *\n     * @return Whether or not the key exists.\n     * @return Value of the key if it exists.\n     */\n    function get(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool, bytes memory) {\n        bytes memory key = _getSecureKey(_key);\n        return MerkleTrie.get(key, _proof, _root);\n    }\n\n    /**\n     * @notice Computes the hashed version of the input key.\n     *\n     * @param _key Key to hash.\n     *\n     * @return Hashed version of the key.\n     */\n    function _getSecureKey(bytes memory _key) private pure returns (bytes memory) {\n        return abi.encodePacked(keccak256(_key));\n    }\n}\n"
    },
    "contracts/test/BenchmarkTest.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/* Testing utilities */\nimport { Test } from \"forge-std/Test.sol\";\nimport { Vm } from \"forge-std/Vm.sol\";\nimport \"./CommonTest.t.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\n\nuint128 constant INITIAL_BASE_FEE = 1_000_000_000;\n\n// Free function for setting the prevBaseFee param in the OptimismPortal.\nfunction setPrevBaseFee(\n    Vm _vm,\n    address _op,\n    uint128 _prevBaseFee\n) {\n    _vm.store(\n        address(_op),\n        bytes32(uint256(1)),\n        bytes32(\n            abi.encode(\n                ResourceMetering.ResourceParams({\n                    prevBaseFee: _prevBaseFee,\n                    prevBoughtGas: 0,\n                    prevBlockNum: uint64(block.number)\n                })\n            )\n        )\n    );\n}\n\n// Tests for obtaining pure gas cost estimates for commonly used functions.\n// The objective with these benchmarks is to strip down the actual test functions\n// so that they are nothing more than the call we want measure the gas cost of.\n// In order to achieve this we make no assertions, and handle everything else in the setUp()\n// function.\ncontract GasBenchMark_OptimismPortal is Portal_Initializer {\n    function test_depositTransaction_benchmark() external {\n        op.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    function test_depositTransaction_benchmark_1() external {\n        setPrevBaseFee(vm, address(op), INITIAL_BASE_FEE);\n        op.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n}\n\ncontract GasBenchMark_L1CrossDomainMessenger is Messenger_Initializer {\n    function test_L1MessengerSendMessage_benchmark_0() external {\n        // The amount of data typically sent during a bridge deposit.\n        bytes\n            memory data = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n        L1Messenger.sendMessage(bob, data, uint32(100));\n    }\n\n    function test_L1MessengerSendMessage_benchmark_1() external {\n        setPrevBaseFee(vm, address(op), INITIAL_BASE_FEE);\n        // The amount of data typically sent during a bridge deposit.\n        bytes\n            memory data = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n        L1Messenger.sendMessage(bob, data, uint32(100));\n    }\n}\n\ncontract GasBenchMark_L1StandardBridge_Deposit is Bridge_Initializer {\n    function setUp() public virtual override {\n        super.setUp();\n        deal(address(L1Token), alice, 100000, true);\n        vm.startPrank(alice, alice);\n    }\n\n    function test_depositETH_benchmark_0() external {\n        L1Bridge.depositETH{ value: 500 }(50000, hex\"\");\n    }\n\n    function test_depositETH_benchmark_1() external {\n        setPrevBaseFee(vm, address(op), INITIAL_BASE_FEE);\n        L1Bridge.depositETH{ value: 500 }(50000, hex\"\");\n    }\n\n    function test_depositERC20_benchmark_0() external {\n        L1Bridge.depositETH{ value: 500 }(50000, hex\"\");\n    }\n\n    function test_depositERC20_benchmark_1() external {\n        setPrevBaseFee(vm, address(op), INITIAL_BASE_FEE);\n        L1Bridge.depositETH{ value: 500 }(50000, hex\"\");\n    }\n}\n\ncontract GasBenchMark_L1StandardBridge_Finalize is Bridge_Initializer {\n    function setUp() public virtual override {\n        super.setUp();\n        deal(address(L1Token), address(L1Bridge), 100, true);\n        vm.mockCall(\n            address(L1Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.otherBridge()))\n        );\n        vm.startPrank(address(L1Bridge.messenger()));\n        vm.deal(address(L1Bridge.messenger()), 100);\n    }\n\n    function test_finalizeETHWithdrawal_benchmark() external {\n        // TODO: Make this more accurate. It is underestimating the cost because it pranks\n        // the call coming from the messenger, which bypasses the portal\n        // and oracle.\n        L1Bridge.finalizeETHWithdrawal{ value: 100 }(alice, alice, 100, hex\"\");\n    }\n}\n\ncontract GasBenchMark_L2OutputOracle is L2OutputOracle_Initializer {\n    uint256 nextBlockNumber;\n\n    function setUp() public override {\n        super.setUp();\n        nextBlockNumber = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber);\n        vm.startPrank(proposer);\n    }\n\n    function test_proposeL2Output_benchmark() external {\n        oracle.proposeL2Output(nonZeroHash, nextBlockNumber, 0, 0);\n    }\n}\n"
    },
    "contracts/test/CommonTest.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/* Testing utilities */\nimport { Test } from \"forge-std/Test.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { L1StandardBridge } from \"../L1/L1StandardBridge.sol\";\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\nimport { OptimismMintableERC20Factory } from \"../universal/OptimismMintableERC20Factory.sol\";\nimport { OptimismMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\nimport { OptimismPortal } from \"../L1/OptimismPortal.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { L2CrossDomainMessenger } from \"../L2/L2CrossDomainMessenger.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { LegacyERC20ETH } from \"../legacy/LegacyERC20ETH.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport { ResolvedDelegateProxy } from \"../legacy/ResolvedDelegateProxy.sol\";\nimport { AddressManager } from \"../legacy/AddressManager.sol\";\nimport { L1ChugSplashProxy } from \"../legacy/L1ChugSplashProxy.sol\";\nimport { IL1ChugSplashDeployer } from \"../legacy/L1ChugSplashProxy.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract CommonTest is Test {\n    address alice = address(128);\n    address bob = address(256);\n    address multisig = address(512);\n\n    address immutable ZERO_ADDRESS = address(0);\n    address immutable NON_ZERO_ADDRESS = address(1);\n    uint256 immutable NON_ZERO_VALUE = 100;\n    uint256 immutable ZERO_VALUE = 0;\n    uint64 immutable NON_ZERO_GASLIMIT = 50000;\n    bytes32 nonZeroHash = keccak256(abi.encode(\"NON_ZERO\"));\n    bytes NON_ZERO_DATA = hex\"0000111122223333444455556666777788889999aaaabbbbccccddddeeeeffff0000\";\n\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 indexed version,\n        bytes opaqueData\n    );\n\n    FFIInterface ffi;\n\n    function _setUp() public {\n        // Give alice and bob some ETH\n        vm.deal(alice, 1 << 16);\n        vm.deal(bob, 1 << 16);\n        vm.deal(multisig, 1 << 16);\n\n        vm.label(alice, \"alice\");\n        vm.label(bob, \"bob\");\n        vm.label(multisig, \"multisig\");\n\n        // Make sure we have a non-zero base fee\n        vm.fee(1000000000);\n\n        ffi = new FFIInterface();\n    }\n\n    function emitTransactionDeposited(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) internal {\n        emit TransactionDeposited(\n            _from,\n            _to,\n            0,\n            abi.encodePacked(_mint, _value, _gasLimit, _isCreation, _data)\n        );\n    }\n}\n\ncontract L2OutputOracle_Initializer is CommonTest {\n    // Test target\n    L2OutputOracle oracle;\n    L2OutputOracle oracleImpl;\n\n    L2ToL1MessagePasser messagePasser =\n        L2ToL1MessagePasser(payable(Predeploys.L2_TO_L1_MESSAGE_PASSER));\n\n    // Constructor arguments\n    address proposer = 0x000000000000000000000000000000000000AbBa;\n    address owner = 0x000000000000000000000000000000000000ACDC;\n    uint256 submissionInterval = 1800;\n    uint256 l2BlockTime = 2;\n    bytes32 genesisL2Output = keccak256(abi.encode(0));\n    uint256 historicalTotalBlocks = 199;\n    uint256 startingBlockNumber = 200;\n    uint256 startingTimestamp = 1000;\n\n    // Test data\n    uint256 initL1Time;\n\n    // Advance the evm's time to meet the L2OutputOracle's requirements for proposeL2Output\n    function warpToProposeTime(uint256 _nextBlockNumber) public {\n        vm.warp(oracle.computeL2Timestamp(_nextBlockNumber) + 1);\n    }\n\n    function setUp() public virtual {\n        _setUp();\n\n        // By default the first block has timestamp and number zero, which will cause underflows in the\n        // tests, so we'll move forward to these block values.\n        initL1Time = startingTimestamp + 1;\n        vm.warp(initL1Time);\n        vm.roll(startingBlockNumber);\n        // Deploy the L2OutputOracle and transfer owernship to the proposer\n        oracleImpl = new L2OutputOracle(\n            submissionInterval,\n            genesisL2Output,\n            historicalTotalBlocks,\n            startingBlockNumber,\n            startingTimestamp,\n            l2BlockTime,\n            proposer,\n            owner\n        );\n        Proxy proxy = new Proxy(multisig);\n        vm.prank(multisig);\n        proxy.upgradeToAndCall(\n            address(oracleImpl),\n            abi.encodeWithSelector(\n                L2OutputOracle.initialize.selector,\n                genesisL2Output,\n                startingBlockNumber,\n                proposer,\n                owner\n            )\n        );\n        oracle = L2OutputOracle(address(proxy));\n        vm.label(address(oracle), \"L2OutputOracle\");\n\n        // Set the L2ToL1MessagePasser at the correct address\n        vm.etch(\n            Predeploys.L2_TO_L1_MESSAGE_PASSER,\n            address(new L2ToL1MessagePasser()).code\n        );\n\n        vm.label(Predeploys.L2_TO_L1_MESSAGE_PASSER, \"L2ToL1MessagePasser\");\n    }\n}\n\ncontract Portal_Initializer is L2OutputOracle_Initializer {\n    // Test target\n    OptimismPortal opImpl;\n    OptimismPortal op;\n\n    function setUp() public virtual override {\n        L2OutputOracle_Initializer.setUp();\n\n        opImpl = new OptimismPortal(oracle, 7 days);\n        Proxy proxy = new Proxy(multisig);\n        vm.prank(multisig);\n        proxy.upgradeToAndCall(\n            address(opImpl),\n            abi.encodeWithSelector(OptimismPortal.initialize.selector)\n        );\n        op = OptimismPortal(payable(address(proxy)));\n    }\n}\n\ncontract Messenger_Initializer is L2OutputOracle_Initializer {\n    OptimismPortal op;\n    AddressManager addressManager;\n    L1CrossDomainMessenger L1Messenger;\n    L2CrossDomainMessenger L2Messenger =\n        L2CrossDomainMessenger(Predeploys.L2_CROSS_DOMAIN_MESSENGER);\n\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n\n    event SentMessageExtension1(\n        address indexed sender,\n        uint256 value\n    );\n\n    event WithdrawalInitiated(\n        uint256 indexed nonce,\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    event RelayedMessage(bytes32 indexed msgHash);\n\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 mint,\n        uint256 value,\n        uint64 gasLimit,\n        bool isCreation,\n        bytes data\n    );\n\n    event WithdrawalFinalized(bytes32 indexed, bool success);\n\n    event WhatHappened(bool success, bytes returndata);\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        // Deploy the OptimismPortal\n        op = new OptimismPortal(oracle, 7 days);\n        vm.label(address(op), \"OptimismPortal\");\n\n        // Deploy the address manager\n        vm.prank(multisig);\n        addressManager = new AddressManager();\n\n        // Setup implementation\n        L1CrossDomainMessenger L1MessengerImpl = new L1CrossDomainMessenger(op);\n\n        // Setup the address manager and proxy\n        vm.prank(multisig);\n        addressManager.setAddress(\"OVM_L1CrossDomainMessenger\", address(L1MessengerImpl));\n        ResolvedDelegateProxy proxy = new ResolvedDelegateProxy(\n            addressManager,\n            \"OVM_L1CrossDomainMessenger\"\n        );\n        L1Messenger = L1CrossDomainMessenger(address(proxy));\n        L1Messenger.initialize();\n\n        vm.etch(\n            Predeploys.L2_CROSS_DOMAIN_MESSENGER,\n            address(new L2CrossDomainMessenger(address(L1Messenger))).code\n        );\n\n        L2Messenger.initialize(address(L1Messenger));\n\n        // Label addresses\n        vm.label(address(addressManager), \"AddressManager\");\n        vm.label(address(L1MessengerImpl), \"L1CrossDomainMessenger_Impl\");\n        vm.label(address(L1Messenger), \"L1CrossDomainMessenger_Proxy\");\n        vm.label(Predeploys.LEGACY_ERC20_ETH, \"LegacyERC20ETH\");\n        vm.label(Predeploys.L2_CROSS_DOMAIN_MESSENGER, \"L2CrossDomainMessenger\");\n\n        vm.label(\n            AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)),\n            \"L1CrossDomainMessenger_aliased\"\n        );\n    }\n}\n\ncontract Bridge_Initializer is Messenger_Initializer {\n    L1StandardBridge L1Bridge;\n    L2StandardBridge L2Bridge;\n    OptimismMintableERC20Factory L2TokenFactory;\n    OptimismMintableERC20Factory L1TokenFactory;\n    ERC20 L1Token;\n    ERC20 BadL1Token;\n    OptimismMintableERC20 L2Token;\n    ERC20 NativeL2Token;\n    ERC20 BadL2Token;\n    OptimismMintableERC20 RemoteL1Token;\n\n    event ETHDepositInitiated(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data\n    );\n\n    event ETHWithdrawalFinalized(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data\n    );\n\n    event ERC20DepositInitiated(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    event ERC20WithdrawalFinalized(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    event WithdrawalInitiated(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    event DepositFinalized(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    event DepositFailed(\n        address indexed l1Token,\n        address indexed l2Token,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    event ETHBridgeInitiated(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data\n    );\n\n    event ETHBridgeFinalized(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data\n    );\n\n    event ERC20BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    event ERC20BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    event ERC20BridgeFailed(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes data\n    );\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        vm.label(Predeploys.L2_STANDARD_BRIDGE, \"L2StandardBridge\");\n        vm.label(Predeploys.OPTIMISM_MINTABLE_ERC20_FACTORY, \"OptimismMintableERC20Factory\");\n\n        // Deploy the L1 bridge and initialize it with the address of the\n        // L1CrossDomainMessenger\n        L1ChugSplashProxy proxy = new L1ChugSplashProxy(multisig);\n        vm.mockCall(\n            multisig,\n            abi.encodeWithSelector(IL1ChugSplashDeployer.isUpgrading.selector),\n            abi.encode(true)\n        );\n        vm.startPrank(multisig);\n        proxy.setCode(address(new L1StandardBridge(payable(address(L1Messenger)))).code);\n        vm.clearMockedCalls();\n        address L1Bridge_Impl = proxy.getImplementation();\n        vm.stopPrank();\n\n        L1Bridge = L1StandardBridge(payable(address(proxy)));\n\n        vm.label(address(proxy), \"L1StandardBridge_Proxy\");\n        vm.label(address(L1Bridge_Impl), \"L1StandardBridge_Impl\");\n\n        // Deploy the L2StandardBridge, move it to the correct predeploy\n        // address and then initialize it\n        L2StandardBridge l2B = new L2StandardBridge(payable(proxy));\n        vm.etch(Predeploys.L2_STANDARD_BRIDGE, address(l2B).code);\n        L2Bridge = L2StandardBridge(payable(Predeploys.L2_STANDARD_BRIDGE));\n\n        // Set up the L2 mintable token factory\n        OptimismMintableERC20Factory factory = new OptimismMintableERC20Factory(\n            Predeploys.L2_STANDARD_BRIDGE\n        );\n        vm.etch(Predeploys.OPTIMISM_MINTABLE_ERC20_FACTORY, address(factory).code);\n        L2TokenFactory = OptimismMintableERC20Factory(\n            Predeploys.OPTIMISM_MINTABLE_ERC20_FACTORY\n        );\n\n        vm.etch(Predeploys.LEGACY_ERC20_ETH, address(new LegacyERC20ETH()).code);\n\n        L1Token = new ERC20(\"Native L1 Token\", \"L1T\");\n\n        // Deploy the L2 ERC20 now\n        L2Token = OptimismMintableERC20(\n            L2TokenFactory.createStandardL2Token(\n                address(L1Token),\n                string(abi.encodePacked(\"L2-\", L1Token.name())),\n                string(abi.encodePacked(\"L2-\", L1Token.symbol()))\n            )\n        );\n\n        BadL2Token = OptimismMintableERC20(\n            L2TokenFactory.createStandardL2Token(\n                address(1),\n                string(abi.encodePacked(\"L2-\", L1Token.name())),\n                string(abi.encodePacked(\"L2-\", L1Token.symbol()))\n            )\n        );\n\n        NativeL2Token = new ERC20(\"Native L2 Token\", \"L2T\");\n        L1TokenFactory = new OptimismMintableERC20Factory(address(L1Bridge));\n\n        RemoteL1Token = OptimismMintableERC20(\n            L1TokenFactory.createStandardL2Token(\n                address(NativeL2Token),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.name())),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.symbol()))\n            )\n        );\n\n        BadL1Token = OptimismMintableERC20(\n            L1TokenFactory.createStandardL2Token(\n                address(1),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.name())),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.symbol()))\n            )\n        );\n    }\n}\n\ncontract FFIInterface is Test {\n    function getFinalizeWithdrawalTransactionInputs(Types.WithdrawalTransaction memory _tx)\n        external\n        returns (\n            bytes32,\n            bytes32,\n            bytes32,\n            bytes32,\n            bytes memory\n        )\n    {\n        string[] memory cmds = new string[](9);\n        cmds[0] = \"node\";\n        cmds[1] = \"dist/scripts/differential-testing.js\";\n        cmds[2] = \"getFinalizeWithdrawalTransactionInputs\";\n        cmds[3] = vm.toString(_tx.nonce);\n        cmds[4] = vm.toString(_tx.sender);\n        cmds[5] = vm.toString(_tx.target);\n        cmds[6] = vm.toString(_tx.value);\n        cmds[7] = vm.toString(_tx.gasLimit);\n        cmds[8] = vm.toString(_tx.data);\n\n        bytes memory result = vm.ffi(cmds);\n        (\n            bytes32 stateRoot,\n            bytes32 storageRoot,\n            bytes32 outputRoot,\n            bytes32 withdrawalHash,\n            bytes memory withdrawalProof\n        ) = abi.decode(result, (bytes32, bytes32, bytes32, bytes32, bytes));\n\n        return (stateRoot, storageRoot, outputRoot, withdrawalHash, withdrawalProof);\n    }\n\n    function hashCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](9);\n        cmds[0] = \"node\";\n        cmds[1] = \"dist/scripts/differential-testing.js\";\n        cmds[2] = \"hashCrossDomainMessage\";\n        cmds[3] = vm.toString(_nonce);\n        cmds[4] = vm.toString(_sender);\n        cmds[5] = vm.toString(_target);\n        cmds[6] = vm.toString(_value);\n        cmds[7] = vm.toString(_gasLimit);\n        cmds[8] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function hashWithdrawal(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](9);\n        cmds[0] = \"node\";\n        cmds[1] = \"dist/scripts/differential-testing.js\";\n        cmds[2] = \"hashWithdrawal\";\n        cmds[3] = vm.toString(_nonce);\n        cmds[4] = vm.toString(_sender);\n        cmds[5] = vm.toString(_target);\n        cmds[6] = vm.toString(_value);\n        cmds[7] = vm.toString(_gasLimit);\n        cmds[8] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function hashOutputRootProof(\n        bytes32 _version,\n        bytes32 _stateRoot,\n        bytes32 _withdrawerStorageRoot,\n        bytes32 _latestBlockhash\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](7);\n        cmds[0] = \"node\";\n        cmds[1] = \"dist/scripts/differential-testing.js\";\n        cmds[2] = \"hashOutputRootProof\";\n        cmds[3] = Strings.toHexString(uint256(_version));\n        cmds[4] = Strings.toHexString(uint256(_stateRoot));\n        cmds[5] = Strings.toHexString(uint256(_withdrawerStorageRoot));\n        cmds[6] = Strings.toHexString(uint256(_latestBlockhash));\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function hashDepositTransaction(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gas,\n        bytes memory _data,\n        uint256 _logIndex\n    ) external returns (bytes32) {\n        string[] memory cmds = new string[](11);\n        cmds[0] = \"node\";\n        cmds[1] = \"dist/scripts/differential-testing.js\";\n        cmds[2] = \"hashDepositTransaction\";\n        cmds[3] = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n        cmds[4] = vm.toString(_logIndex);\n        cmds[5] = vm.toString(_from);\n        cmds[6] = vm.toString(_to);\n        cmds[7] = vm.toString(_mint);\n        cmds[8] = vm.toString(_value);\n        cmds[9] = vm.toString(_gas);\n        cmds[10] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes32));\n    }\n\n    function encodeDepositTransaction(\n        Types.UserDepositTransaction calldata txn\n    ) external returns (bytes memory) {\n        string[] memory cmds = new string[](12);\n        cmds[0] = \"node\";\n        cmds[1] = \"dist/scripts/differential-testing.js\";\n        cmds[2] = \"encodeDepositTransaction\";\n        cmds[3] = vm.toString(txn.from);\n        cmds[4] = vm.toString(txn.to);\n        cmds[5] = vm.toString(txn.value);\n        cmds[6] = vm.toString(txn.mint);\n        cmds[7] = vm.toString(txn.gasLimit);\n        cmds[8] = vm.toString(txn.isCreation);\n        cmds[9] = vm.toString(txn.data);\n        cmds[10] = vm.toString(txn.l1BlockHash);\n        cmds[11] = vm.toString(txn.logIndex);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes));\n    }\n\n    function encodeCrossDomainMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external returns (bytes memory) {\n        string[] memory cmds = new string[](9);\n        cmds[0] = \"node\";\n        cmds[1] = \"dist/scripts/differential-testing.js\";\n        cmds[2] = \"encodeCrossDomainMessage\";\n        cmds[3] = vm.toString(_nonce);\n        cmds[4] = vm.toString(_sender);\n        cmds[5] = vm.toString(_target);\n        cmds[6] = vm.toString(_value);\n        cmds[7] = vm.toString(_gasLimit);\n        cmds[8] = vm.toString(_data);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (bytes));\n    }\n\n    function decodeVersionedNonce(uint256 nonce) external returns (uint256, uint256) {\n        string[] memory cmds = new string[](4);\n        cmds[0] = \"node\";\n        cmds[1] = \"dist/scripts/differential-testing.js\";\n        cmds[2] = \"decodeVersionedNonce\";\n        cmds[3] = vm.toString(nonce);\n\n        bytes memory result = vm.ffi(cmds);\n        return abi.decode(result, (uint256, uint256));\n    }\n}\n\n// Used for testing a future upgrade beyond the current implementations.\n// We include some variables so that we can sanity check accessing storage values after an upgrade.\ncontract NextImpl is Initializable {\n    // Initializable occupies the zero-th slot.\n    bytes32 slot1;\n    bytes32[19] __gap;\n    bytes32 slot21;\n    bytes32 public constant slot21Init = bytes32(hex\"1337\");\n\n    function initialize() public reinitializer(2) {\n        // Slot21 is unused by an of our upgradeable contracts.\n        // This is used to verify that we can access this value after an upgrade.\n        slot21 = slot21Init;\n    }\n}\n\ncontract Reverter {\n    fallback() external {\n        revert();\n    }\n}\n\n// Useful for testing reentrancy guards\ncontract CallerCaller {\n    event WhatHappened(\n        bool success,\n        bytes returndata\n    );\n\n    fallback() external {\n        (bool success, bytes memory returndata) = msg.sender.call(msg.data);\n        emit WhatHappened(success, returndata);\n        assembly {\n            switch success\n            case 0 { revert(add(returndata, 0x20), mload(returndata)) }\n            default { return(add(returndata, 0x20), mload(returndata)) }\n        }\n    }\n}\n"
    },
    "contracts/test/DeployerWhitelist.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { DeployerWhitelist } from \"../legacy/DeployerWhitelist.sol\";\n\ncontract DeployerWhitelist_Test is CommonTest {\n    DeployerWhitelist list;\n\n    function setUp() external {\n        list = new DeployerWhitelist();\n    }\n\n    // The owner should be address(0)\n    function test_owner() external {\n        assertEq(list.owner(), address(0));\n    }\n\n    // The storage slot for the owner must be the same\n    function test_storageSlots() external {\n        vm.prank(list.owner());\n        list.setOwner(address(1));\n\n        assertEq(\n            bytes32(uint256(1)),\n            vm.load(address(list), bytes32(uint256(0)))\n        );\n    }\n}\n"
    },
    "contracts/test/Encoding.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\n\ncontract Encoding_Test is CommonTest {\n    function setUp() external {\n        _setUp();\n    }\n\n    function test_nonceVersioning(uint240 _nonce, uint16 _version) external {\n        (uint240 nonce, uint16 version) = Encoding.decodeVersionedNonce(\n            Encoding.encodeVersionedNonce(_nonce, _version)\n        );\n        assertEq(version, _version);\n        assertEq(nonce, _nonce);\n    }\n\n    function test_decodeVersionedNonce_differential(uint240 _nonce, uint16 _version) external {\n        uint256 nonce = uint256(Encoding.encodeVersionedNonce(_nonce, _version));\n        (uint256 decodedNonce, uint256 decodedVersion) = ffi.decodeVersionedNonce(nonce);\n\n        assertEq(\n            _version,\n            uint16(decodedVersion)\n        );\n\n        assertEq(\n            _nonce,\n            uint240(decodedNonce)\n        );\n    }\n\n    function test_encodeCrossDomainMessage_differential(\n        uint240 _nonce,\n        uint8 _version,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        uint8 version = _version % 2;\n        uint256 nonce = Encoding.encodeVersionedNonce(_nonce, version);\n\n        bytes memory encoding = Encoding.encodeCrossDomainMessage(\n            nonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n\n        bytes memory _encoding = ffi.encodeCrossDomainMessage(\n            nonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n\n        assertEq(encoding, _encoding);\n    }\n\n    function test_encodeDepositTransaction_differential(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gas,\n        bool isCreate,\n        bytes memory _data,\n        uint256 _logIndex\n    ) external {\n        Types.UserDepositTransaction memory t = Types.UserDepositTransaction(\n            _from,\n            _to,\n            isCreate,\n            _value,\n            _mint,\n            _gas,\n            _data,\n            bytes32(uint256(0)),\n            _logIndex\n        );\n\n        bytes memory txn = Encoding.encodeDepositTransaction(t);\n        bytes memory _txn = ffi.encodeDepositTransaction(t);\n\n        assertEq(\n            txn,\n            _txn\n        );\n    }\n}\n"
    },
    "contracts/test/GasPriceOracle.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { GasPriceOracle } from \"../L2/GasPriceOracle.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\n\ncontract GasPriceOracle_Test is CommonTest {\n\n    event OverheadUpdated(uint256);\n    event ScalarUpdated(uint256);\n    event DecimalsUpdated(uint256);\n\n    GasPriceOracle gasOracle;\n    L1Block l1Block;\n    address depositor;\n\n    function setUp() external {\n        // place the L1Block contract at the predeploy address\n        vm.etch(\n            Predeploys.L1_BLOCK_ATTRIBUTES,\n            address(new L1Block()).code\n        );\n\n        l1Block = L1Block(Predeploys.L1_BLOCK_ATTRIBUTES);\n        depositor = l1Block.DEPOSITOR_ACCOUNT();\n\n        // We are not setting the gas oracle at its predeploy\n        // address for simplicity purposes. Nothing in this test\n        // requires it to be at a particular address\n        gasOracle = new GasPriceOracle(alice);\n\n        // set the initial L1 context values\n        uint64 number = 10;\n        uint64 timestamp = 11;\n        uint256 basefee = 100;\n        bytes32 hash = bytes32(uint256(64));\n        uint64 sequenceNumber = 0;\n\n        vm.prank(depositor);\n        l1Block.setL1BlockValues(\n            number,\n            timestamp,\n            basefee,\n            hash,\n            sequenceNumber\n        );\n    }\n\n    function test_owner() external {\n        // alice is passed into the constructor of the gasOracle\n        assertEq(gasOracle.owner(), alice);\n    }\n\n    function test_storageLayout() external {\n        // the overhead is at slot 3\n        vm.prank(gasOracle.owner());\n        gasOracle.setOverhead(456);\n        assertEq(\n            456,\n            uint256(vm.load(address(gasOracle), bytes32(uint256(3))))\n        );\n\n        // scalar is at slot 4\n        vm.prank(gasOracle.owner());\n        gasOracle.setScalar(333);\n        assertEq(\n            333,\n            uint256(vm.load(address(gasOracle), bytes32(uint256(4))))\n        );\n\n        // decimals is at slot 5\n        vm.prank(gasOracle.owner());\n        gasOracle.setDecimals(222);\n        assertEq(\n            222,\n            uint256(vm.load(address(gasOracle), bytes32(uint256(5))))\n        );\n    }\n\n    function test_l1BaseFee() external {\n        uint256 l1BaseFee = gasOracle.l1BaseFee();\n        assertEq(l1BaseFee, 100);\n    }\n\n    function test_gasPrice() external {\n        vm.fee(100);\n        uint256 gasPrice = gasOracle.gasPrice();\n        assertEq(gasPrice, 100);\n    }\n\n    function test_baseFee() external {\n        vm.fee(64);\n        uint256 gasPrice = gasOracle.baseFee();\n        assertEq(gasPrice, 64);\n    }\n\n    function test_setGasPriceReverts() external {\n        vm.prank(gasOracle.owner());\n        (bool success, bytes memory returndata) = address(gasOracle).call(\n            abi.encodeWithSignature(\n                \"setGasPrice(uint256)\",\n                1\n            )\n        );\n\n        assertEq(success, false);\n        assertEq(returndata, hex\"\");\n    }\n\n    function test_setL1BaseFeeReverts() external {\n        vm.prank(gasOracle.owner());\n        (bool success, bytes memory returndata) = address(gasOracle).call(\n            abi.encodeWithSignature(\n                \"setL1BaseFee(uint256)\",\n                1\n            )\n        );\n\n        assertEq(success, false);\n        assertEq(returndata, hex\"\");\n    }\n\n    function test_setOverhead() external {\n        vm.expectEmit(true, true, true, true);\n        emit OverheadUpdated(1234);\n\n        vm.prank(gasOracle.owner());\n        gasOracle.setOverhead(1234);\n        assertEq(gasOracle.overhead(), 1234);\n    }\n\n    function test_onlyOwnerSetOverhead() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        gasOracle.setOverhead(0);\n    }\n\n    function test_setScalar() external {\n        vm.expectEmit(true, true, true, true);\n        emit ScalarUpdated(666);\n\n        vm.prank(gasOracle.owner());\n        gasOracle.setScalar(666);\n        assertEq(gasOracle.scalar(), 666);\n    }\n\n    function test_onlyOwnerSetScalar() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        gasOracle.setScalar(0);\n    }\n\n    function test_setDecimals() external {\n        vm.expectEmit(true, true, true, true);\n        emit DecimalsUpdated(18);\n\n        vm.prank(gasOracle.owner());\n        gasOracle.setDecimals(18);\n        assertEq(gasOracle.decimals(), 18);\n    }\n\n    function test_onlyOwnerSetDecimals() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        gasOracle.setDecimals(0);\n    }\n}\n"
    },
    "contracts/test/Hashing.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\n\ncontract Hashing_Test is CommonTest {\n    function setUp() external {\n        _setUp();\n    }\n\n    function test_hashDepositSource() external {\n        bytes32 sourceHash = Hashing.hashDepositSource(\n            0xd25df7858efc1778118fb133ac561b138845361626dfb976699c5287ed0f4959,\n            0x1\n        );\n\n        assertEq(\n            sourceHash,\n            0xf923fb07134d7d287cb52c770cc619e17e82606c21a875c92f4c63b65280a5cc\n        );\n    }\n\n    function test_hashCrossDomainMessage_differential(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        // Discard any fuzz tests with an invalid version\n        (, uint16 version) = Encoding.decodeVersionedNonce(_nonce);\n        vm.assume(version < 2);\n\n        bytes32 _hash = ffi.hashCrossDomainMessage(\n            _nonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            _nonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n\n        assertEq(hash, _hash);\n    }\n\n    function test_hashWithdrawal_differential(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        bytes32 hash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction(\n                _nonce,\n                _sender,\n                _target,\n                _value,\n                _gasLimit,\n                _data\n            )\n        );\n\n        bytes32 _hash = ffi.hashWithdrawal(\n            _nonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n\n        assertEq(hash, _hash);\n    }\n\n    function test_hashOutputRootProof_differential(\n        bytes32 _version,\n        bytes32 _stateRoot,\n        bytes32 _withdrawerStorageRoot,\n        bytes32 _latestBlockhash\n    ) external {\n        Types.OutputRootProof memory proof = Types.OutputRootProof({\n            version: _version,\n            stateRoot: _stateRoot,\n            withdrawerStorageRoot: _withdrawerStorageRoot,\n            latestBlockhash: _latestBlockhash\n        });\n\n        bytes32 hash = Hashing.hashOutputRootProof(proof);\n\n        bytes32 _hash = ffi.hashOutputRootProof(\n            _version,\n            _stateRoot,\n            _withdrawerStorageRoot,\n            _latestBlockhash\n        );\n\n        assertEq(hash, _hash);\n    }\n\n    // TODO(tynes): foundry bug cannot serialize\n    // bytes32 as strings with vm.toString\n    function test_hashDepositTransaction_differential(\n        address _from,\n        address _to,\n        uint256 _mint,\n        uint256 _value,\n        uint64 _gas,\n        bytes memory _data,\n        uint256 _logIndex\n    ) external {\n        bytes32 hash = Hashing.hashDepositTransaction(\n            Types.UserDepositTransaction(\n                _from,\n                _to,\n                false, // isCreate\n                _value,\n                _mint,\n                _gas,\n                _data,\n                bytes32(uint256(0)),\n                _logIndex\n            )\n        );\n\n        bytes32 _hash = ffi.hashDepositTransaction(\n            _from,\n            _to,\n            _mint,\n            _value,\n            _gas,\n            _data,\n            _logIndex\n        );\n\n        assertEq(hash, _hash);\n    }\n}\n"
    },
    "contracts/test/L1Block.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\n\ncontract L1BlockTest is CommonTest {\n    L1Block lb;\n    address depositor;\n    bytes32 immutable NON_ZERO_HASH = keccak256(abi.encode(1));\n\n    function setUp() external {\n        lb = new L1Block();\n        depositor = lb.DEPOSITOR_ACCOUNT();\n        vm.prank(depositor);\n        lb.setL1BlockValues(uint64(1), uint64(2), 3, NON_ZERO_HASH, uint64(4));\n    }\n\n    function test_updatesValues(uint64 n, uint64 t, uint256 b, bytes32 h, uint64 s) external {\n        vm.prank(depositor);\n        lb.setL1BlockValues(n, t, b, h, s);\n        assertEq(lb.number(), n);\n        assertEq(lb.timestamp(), t);\n        assertEq(lb.basefee(), b);\n        assertEq(lb.hash(), h);\n        assertEq(lb.sequenceNumber(), s);\n    }\n\n    function test_number() external {\n        assertEq(lb.number(), uint64(1));\n    }\n\n    function test_timestamp() external {\n        assertEq(lb.timestamp(), uint64(2));\n    }\n\n    function test_basefee() external {\n        assertEq(lb.basefee(), 3);\n    }\n\n    function test_hash() external {\n        assertEq(lb.hash(), NON_ZERO_HASH);\n    }\n\n    function test_sequenceNumber() external {\n        assertEq(lb.sequenceNumber(), uint64(4));\n    }\n\n    function test_updateValues() external {\n        vm.prank(depositor);\n        lb.setL1BlockValues(type(uint64).max, type(uint64).max, type(uint256).max, keccak256(abi.encode(1)), type(uint64).max);\n    }\n}\n"
    },
    "contracts/test/L1BlockNumber.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\nimport { L1BlockNumber } from \"../legacy/L1BlockNumber.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\n\ncontract L1BlockNumberTest is Test {\n    L1Block lb;\n    L1BlockNumber bn;\n\n    function setUp() external {\n        vm.etch(Predeploys.L1_BLOCK_ATTRIBUTES, address(new L1Block()).code);\n        lb = L1Block(Predeploys.L1_BLOCK_ATTRIBUTES);\n        bn = new L1BlockNumber();\n        vm.prank(lb.DEPOSITOR_ACCOUNT());\n        lb.setL1BlockValues(uint64(999), uint64(2), 3, keccak256(abi.encode(1)), uint64(4));\n    }\n\n    function test_getL1BlockNumber() external {\n        assertEq(bn.getL1BlockNumber(), 999);\n    }\n\n    function test_fallback() external {\n        (bool success, bytes memory ret) = address(bn).call(hex\"\");\n        assertEq(success, true);\n        assertEq(ret, abi.encode(999));\n    }\n\n    function test_receive() external {\n        (bool success, bytes memory ret) = address(bn).call{ value: 1 }(hex\"\");\n        assertEq(success, true);\n        assertEq(ret, abi.encode(999));\n    }\n}\n"
    },
    "contracts/test/L1CrossDomainMessenger.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/* Testing utilities */\nimport { Messenger_Initializer, Reverter, CallerCaller } from \"./CommonTest.t.sol\";\nimport { L2OutputOracle_Initializer } from \"./L2OutputOracle.t.sol\";\n\n/* Libraries */\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\n\n/* Target contract dependencies */\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { OptimismPortal } from \"../L1/OptimismPortal.sol\";\n\n/* Target contract */\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\n\ncontract L1CrossDomainMessenger_Test is Messenger_Initializer {\n    // Receiver address for testing\n    address recipient = address(0xabbaacdc);\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    // pause: should pause the contract when called by the current owner\n    function test_L1MessengerPause() external {\n        L1Messenger.pause();\n        assert(L1Messenger.paused());\n    }\n\n    // pause: should not pause the contract when called by account other than the owner\n    function testCannot_L1MessengerPause() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(0xABBA));\n        L1Messenger.pause();\n    }\n\n    // unpause: should unpause the contract when called by the current owner\n    function test_L1MessengerUnpause() external {\n        L1Messenger.pause();\n        assert(L1Messenger.paused());\n        L1Messenger.unpause();\n        assert(!L1Messenger.paused());\n    }\n\n    // unpause: should not unpause the contract when called by account other than the owner\n    function testCannot_L1MessengerUnpause() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(0xABBA));\n        L1Messenger.unpause();\n    }\n\n    // the version is encoded in the nonce\n    function test_L1MessengerMessageVersion() external {\n        (, uint16 version) = Encoding.decodeVersionedNonce(L1Messenger.messageNonce());\n        assertEq(version, L1Messenger.MESSAGE_VERSION());\n    }\n\n    // sendMessage: should be able to send a single message\n    // TODO: this same test needs to be done with the legacy message type\n    // by setting the message version to 0\n    function test_L1MessengerSendMessage() external {\n        // deposit transaction on the optimism portal should be called\n        vm.expectCall(\n            address(op),\n            abi.encodeWithSelector(\n                OptimismPortal.depositTransaction.selector,\n                Predeploys.L2_CROSS_DOMAIN_MESSENGER,\n                0,\n                L1Messenger.baseGas(hex\"ff\", 100),\n                false,\n                Encoding.encodeCrossDomainMessage(\n                    L1Messenger.messageNonce(),\n                    alice,\n                    recipient,\n                    0,\n                    100,\n                    hex\"ff\"\n                )\n            )\n        );\n\n        // TransactionDeposited event\n        vm.expectEmit(true, true, true, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)),\n            Predeploys.L2_CROSS_DOMAIN_MESSENGER,\n            0,\n            0,\n            L1Messenger.baseGas(hex\"ff\", 100),\n            false,\n            Encoding.encodeCrossDomainMessage(\n                L1Messenger.messageNonce(),\n                alice,\n                recipient,\n                0,\n                100,\n                hex\"ff\"\n            )\n        );\n\n        // SentMessage event\n        vm.expectEmit(true, true, true, true);\n        emit SentMessage(recipient, alice, hex\"ff\", L1Messenger.messageNonce(), 100);\n\n        // SentMessageExtension1 event\n        vm.expectEmit(true, true, true, true);\n        emit SentMessageExtension1(alice, 0);\n\n        vm.prank(alice);\n        L1Messenger.sendMessage(recipient, hex\"ff\", uint32(100));\n    }\n\n    // sendMessage: should be able to send the same message twice\n    function test_L1MessengerTwiceSendMessage() external {\n        uint256 nonce = L1Messenger.messageNonce();\n        L1Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        L1Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        // the nonce increments for each message sent\n        assertEq(nonce + 2, L1Messenger.messageNonce());\n    }\n\n    function test_L1MessengerXDomainSenderReverts() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n    }\n\n    // xDomainMessageSender: should return the xDomainMsgSender address\n    // TODO: might need a test contract\n    // function test_xDomainSenderSetCorrectly() external {}\n\n    // relayMessage: should send a successful call to the target contract\n    function test_L1MessengerRelayMessageSucceeds() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        vm.expectCall(target, hex\"1111\");\n\n        // set the value of op.l2Sender() to be the L2 Cross Domain Messenger.\n        uint256 senderSlotIndex = 51;\n        vm.store(address(op), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.prank(address(op));\n\n        vm.expectEmit(true, true, true, true);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(0, sender, target, 0, 0, hex\"1111\");\n\n        emit RelayedMessage(hash);\n\n        L1Messenger.relayMessage(\n            0, // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n\n        // the message hash is in the successfulMessages mapping\n        assert(L1Messenger.successfulMessages(hash));\n        // it is not in the received messages mapping\n        assertEq(L1Messenger.receivedMessages(hash), false);\n    }\n\n    // relayMessage: should revert if attempting to relay a message sent to an L1 system contract\n    function test_L1MessengerRelayMessageToSystemContract() external {\n        // set the target to be the OptimismPortal\n        address target = address(op);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        bytes memory message = hex\"1111\";\n\n        vm.prank(address(op));\n        vm.expectRevert(\"CrossDomainMessenger: message cannot be replayed\");\n        L1Messenger.relayMessage(0, sender, target, 0, 0, message);\n\n        vm.store(address(op), 0, bytes32(abi.encode(sender)));\n        vm.expectRevert(\"CrossDomainMessenger: message cannot be replayed\");\n        L1Messenger.relayMessage(0, sender, target, 0, 0, message);\n    }\n\n    // relayMessage: should revert if eth is sent from a contract other than the standard bridge\n    function test_L1MessengerReplayMessageWithValue() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        bytes memory message = hex\"1111\";\n\n        vm.expectRevert(\n            \"CrossDomainMessenger: value must be zero unless message is from a system address\"\n        );\n        L1Messenger.relayMessage{ value: 100 }(0, sender, target, 0, 0, message);\n    }\n\n    // relayMessage: the xDomainMessageSender is reset to the original value\n    function test_L1MessengerxDomainMessageSenderResets() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n\n        uint256 senderSlotIndex = 51;\n\n        vm.store(address(op), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.prank(address(op));\n        L1Messenger.relayMessage(0, address(0), address(0), 0, 0, hex\"\");\n\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n    }\n\n    // relayMessage: should revert if paused\n    function test_L1MessengerRelayShouldRevertIfPaused() external {\n        vm.prank(L1Messenger.owner());\n        L1Messenger.pause();\n\n        vm.expectRevert(\"Pausable: paused\");\n        L1Messenger.relayMessage(0, address(0), address(0), 0, 0, hex\"\");\n    }\n\n    // relayMessage: should send a successful call to the target contract after the first message\n    // fails and ETH gets stuck, but the second message succeeds\n    function test_L1MessengerRelayMessageFirstStuckSecondSucceeds() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        uint256 value = 100;\n\n        vm.expectCall(target, hex\"1111\");\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(0, sender, target, value, 0, hex\"1111\");\n\n        uint256 senderSlotIndex = 51;\n        vm.store(address(op), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.etch(target, address(new Reverter()).code);\n        vm.deal(address(op), value);\n        vm.prank(address(op));\n        L1Messenger.relayMessage{value: value}(\n            0, // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L1Messenger).balance, value);\n        assertEq(address(target).balance, 0);\n        assertEq(L1Messenger.successfulMessages(hash), false);\n        assertEq(L1Messenger.receivedMessages(hash), true);\n\n        vm.expectEmit(true, true, true, true);\n\n        emit RelayedMessage(hash);\n\n        vm.etch(target, address(0).code);\n        vm.prank(address(sender));\n        L1Messenger.relayMessage(\n            0, // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L1Messenger).balance, 0);\n        assertEq(address(target).balance, value);\n        assertEq(L1Messenger.successfulMessages(hash), true);\n        assertEq(L1Messenger.receivedMessages(hash), true);\n    }\n\n    // relayMessage: should revert if recipient is trying to reenter\n    function test_L1MessengerRelayMessageRevertsOnReentrancy() external {\n        address target = address(0xabcd);\n        address sender = Predeploys.L2_CROSS_DOMAIN_MESSENGER;\n        bytes memory message = abi.encodeWithSelector(\n            L1Messenger.relayMessage.selector,\n            0,\n            sender,\n            target,\n            0,\n            0,\n            hex\"1111\"\n        );\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(0, sender, target, 0, 0, message);\n\n        uint256 senderSlotIndex = 51;\n        vm.store(address(op), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.etch(target, address(new CallerCaller()).code);\n\n        vm.expectEmit(true, true, true, true, target);\n\n        emit WhatHappened(false, abi.encodeWithSignature(\"Error(string)\", \"ReentrancyGuard: reentrant call\"));\n\n        vm.prank(address(op));\n        vm.expectCall(target, message);\n        L1Messenger.relayMessage(\n            0, // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            message\n        );\n\n        assertEq(L1Messenger.successfulMessages(hash), false);\n        assertEq(L1Messenger.receivedMessages(hash), true);\n    }\n}\n"
    },
    "contracts/test/L1StandardBridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { stdStorage, StdStorage } from \"forge-std/Test.sol\";\n\ncontract L1StandardBridge_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_initialize() external {\n        assertEq(\n            address(L1Bridge.messenger()),\n            address(L1Messenger)\n        );\n\n        assertEq(\n            address(L1Bridge.otherBridge()),\n            Predeploys.L2_STANDARD_BRIDGE\n        );\n\n        assertEq(\n            address(L2Bridge),\n            Predeploys.L2_STANDARD_BRIDGE\n        );\n    }\n\n    // receive\n    // - can accept ETH\n    function test_receive() external {\n        assertEq(address(op).balance, 0);\n\n        vm.expectEmit(true, true, true, true);\n        emit ETHBridgeInitiated(alice, alice, 100, hex\"\");\n\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                abi.encodeWithSelector(\n                    StandardBridge.finalizeBridgeETH.selector,\n                    alice,\n                    alice,\n                    100,\n                    hex\"\"\n                ),\n                200_000\n            )\n        );\n\n        vm.prank(alice, alice);\n        (bool success,) = address(L1Bridge).call{ value: 100 }(hex\"\");\n        assertEq(success, true);\n        assertEq(address(op).balance, 100);\n    }\n\n    // depositETH\n    // - emits ETHDepositInitiated\n    // - calls optimismPortal.depositTransaction\n    // - only EOA\n    // - ETH ends up in the optimismPortal\n    function test_depositETH() external {\n        assertEq(address(op).balance, 0);\n\n        vm.expectEmit(true, true, true, true);\n        emit ETHBridgeInitiated(alice, alice, 500, hex\"ff\");\n\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                abi.encodeWithSelector(\n                    StandardBridge.finalizeBridgeETH.selector,\n                    alice,\n                    alice,\n                    500,\n                    hex\"ff\"\n                ),\n                50000\n            )\n        );\n\n        vm.prank(alice, alice);\n        L1Bridge.depositETH{ value: 500 }(50000, hex\"ff\");\n        assertEq(address(op).balance, 500);\n    }\n\n    function test_onlyEOADepositETH() external {\n        // turn alice into a contract\n        vm.etch(alice, address(L1Token).code);\n\n        vm.expectRevert(\"StandardBridge: function can only be called from an EOA\");\n        vm.prank(alice);\n        L1Bridge.depositETH{ value: 1 }(300, hex\"\");\n    }\n\n    // depositETHTo\n    // - emits ETHDepositInitiated\n    // - calls optimismPortal.depositTransaction\n    // - EOA or contract can call\n    // - ETH ends up in the optimismPortal\n    function test_depositETHTo() external {\n        assertEq(address(op).balance, 0);\n\n        vm.expectEmit(true, true, true, true);\n        emit ETHDepositInitiated(alice, bob, 600, hex\"dead\");\n\n        vm.expectEmit(true, true, true, true);\n        emit ETHBridgeInitiated(alice, bob, 600, hex\"dead\");\n\n        // depositETHTo on the L1 bridge should be called\n        vm.expectCall(\n            address(L1Bridge),\n            abi.encodeWithSelector(\n                L1Bridge.depositETHTo.selector,\n                bob,\n                1000,\n                hex\"dead\"\n            )\n        );\n\n        // the L1 bridge should call\n        // L1CrossDomainMessenger.sendMessage\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                abi.encodeWithSelector(\n                    StandardBridge.finalizeBridgeETH.selector,\n                    alice,\n                    bob,\n                    600,\n                    hex\"dead\"\n                ),\n                1000\n            )\n        );\n\n        // TODO: assert on OptimismPortal being called\n        // and the event being emitted correctly\n\n        // deposit eth to bob\n        vm.prank(alice, alice);\n        L1Bridge.depositETHTo{ value: 600 }(bob, 1000, hex\"dead\");\n    }\n\n    // depositERC20\n    // - updates bridge.deposits\n    // - emits ERC20DepositInitiated\n    // - calls optimismPortal.depositTransaction\n    // - only callable by EOA\n    function test_depositERC20() external {\n        vm.expectEmit(true, true, true, true);\n        emit ERC20DepositInitiated(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n\n        deal(address(L1Token), alice, 100000, true);\n\n        vm.prank(alice);\n        L1Token.approve(address(L1Bridge), type(uint256).max);\n\n        // The L1Bridge should transfer alice's tokens\n        // to itself\n        vm.expectCall(\n            address(L1Token),\n            abi.encodeWithSelector(\n                ERC20.transferFrom.selector,\n                alice,\n                address(L1Bridge),\n                100\n            )\n        );\n\n        // TODO: optimismPortal.depositTransaction call + event\n\n        vm.prank(alice);\n        L1Bridge.depositERC20(\n            address(L1Token),\n            address(L2Token),\n            100,\n            10000,\n            hex\"\"\n        );\n\n        assertEq(L1Bridge.deposits(address(L1Token), address(L2Token)), 100);\n    }\n\n    function test_onlyEOADepositERC20() external {\n        // turn alice into a contract\n        vm.etch(alice, hex\"ffff\");\n\n        vm.expectRevert(\"StandardBridge: function can only be called from an EOA\");\n        vm.prank(alice, alice);\n        L1Bridge.depositERC20(\n            address(0),\n            address(0),\n            100,\n            100,\n            hex\"\"\n        );\n    }\n\n    // depositERC20To\n    // - updates bridge.deposits\n    // - emits ERC20DepositInitiated\n    // - calls optimismPortal.depositTransaction\n    // - callable by a contract\n    function test_depositERC20To() external {\n        vm.expectEmit(true, true, true, true);\n        emit ERC20DepositInitiated(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            bob,\n            1000,\n            hex\"\"\n        );\n\n        deal(address(L1Token), alice, 100000, true);\n\n        vm.prank(alice);\n        L1Token.approve(address(L1Bridge), type(uint256).max);\n\n        vm.expectCall(\n            address(L1Token),\n            abi.encodeWithSelector(\n                ERC20.transferFrom.selector,\n                alice,\n                address(L1Bridge),\n                1000\n            )\n        );\n\n        vm.prank(alice);\n        L1Bridge.depositERC20To(\n            address(L1Token),\n            address(L2Token),\n            bob,\n            1000,\n            10000,\n            hex\"\"\n        );\n\n        assertEq(L1Bridge.deposits(address(L1Token), address(L2Token)), 1000);\n    }\n\n    // finalizeETHWithdrawal\n    // - emits ETHWithdrawalFinalized\n    // - only callable by L2 bridge\n    function test_finalizeETHWithdrawal() external {\n        uint256 aliceBalance = alice.balance;\n\n        vm.expectEmit(true, true, true, true);\n        emit ETHWithdrawalFinalized(\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n\n        vm.expectCall(\n            alice,\n            hex\"\"\n        );\n\n        vm.mockCall(\n            address(L1Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.otherBridge()))\n        );\n        // ensure that the messenger has ETH to call with\n        vm.deal(address(L1Bridge.messenger()), 100);\n        vm.prank(address(L1Bridge.messenger()));\n        L1Bridge.finalizeETHWithdrawal{ value: 100 }(\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n\n        assertEq(address(L1Bridge.messenger()).balance, 0);\n        assertEq(aliceBalance + 100, alice.balance);\n    }\n\n    // finalizeERC20Withdrawal\n    // - updates bridge.deposits\n    // - emits ERC20WithdrawalFinalized\n    // - only callable by L2 bridge\n    function test_finalizeERC20Withdrawal() external {\n        deal(address(L1Token), address(L1Bridge), 100, true);\n\n        uint256 slot = stdstore\n            .target(address(L1Bridge))\n            .sig(\"deposits(address,address)\")\n            .with_key(address(L1Token))\n            .with_key(address(L2Token))\n            .find();\n\n        // Give the L1 bridge some ERC20 tokens\n        vm.store(address(L1Bridge), bytes32(slot), bytes32(uint256(100)));\n        assertEq(L1Bridge.deposits(address(L1Token), address(L2Token)), 100);\n\n        vm.expectEmit(true, true, true, true);\n        emit ERC20WithdrawalFinalized(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n\n        vm.expectCall(\n            address(L1Token),\n            abi.encodeWithSelector(\n                ERC20.transfer.selector,\n                alice,\n                100\n            )\n        );\n\n        vm.mockCall(\n            address(L1Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.otherBridge()))\n        );\n        vm.prank(address(L1Bridge.messenger()));\n        L1Bridge.finalizeERC20Withdrawal(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n\n        assertEq(L1Token.balanceOf(address(L1Bridge)), 0);\n        assertEq(L1Token.balanceOf(address(alice)), 100);\n    }\n\n    function test_onlyPortalFinalizeERC20Withdrawal() external {\n        vm.mockCall(\n            address(L1Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.otherBridge()))\n        );\n        vm.prank(address(28));\n        vm.expectRevert(\"StandardBridge: function can only be called from the other bridge\");\n        L1Bridge.finalizeERC20Withdrawal(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n    }\n\n    function test_onlyL2BridgeFinalizeERC20Withdrawal() external {\n        vm.mockCall(\n            address(L1Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(address(0)))\n        );\n        vm.prank(address(L1Bridge.messenger()));\n        vm.expectRevert(\"StandardBridge: function can only be called from the other bridge\");\n        L1Bridge.finalizeERC20Withdrawal(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n    }\n\n    function test_finalizeBridgeERC20FailSendBack() external {\n        deal(address(BadL1Token), address(L1Bridge), 100, true);\n\n        uint256 slot = stdstore\n            .target(address(L1Bridge))\n            .sig(\"deposits(address,address)\")\n            .with_key(address(BadL1Token))\n            .with_key(address(L2Token))\n            .find();\n\n        // Give the L1 bridge some ERC20 tokens\n        vm.store(address(L1Bridge), bytes32(slot), bytes32(uint256(100)));\n        assertEq(L1Bridge.deposits(address(BadL1Token), address(L2Token)), 100);\n\n        vm.expectEmit(true, true, true, true);\n\n        emit ERC20BridgeInitiated(\n            address(BadL1Token),\n            address(L2Token),\n            bob,\n            alice,\n            100,\n            hex\"\"\n        );\n\n        vm.mockCall(\n            address(L1Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.otherBridge()))\n        );\n        vm.prank(address(L1Bridge.messenger()));\n        L1Bridge.finalizeBridgeERC20(\n            address(BadL1Token),\n            address(L2Token),\n            alice,\n            bob,\n            100,\n            hex\"\"\n        );\n\n        assertEq(BadL1Token.balanceOf(address(L1Bridge)), 100);\n        assertEq(BadL1Token.balanceOf(address(alice)), 0);\n    }\n}\n"
    },
    "contracts/test/L2CrossDomainMessenger.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Messenger_Initializer, Reverter, CallerCaller } from \"./CommonTest.t.sol\";\n\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { L2CrossDomainMessenger } from \"../L2/L2CrossDomainMessenger.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\n\ncontract L2CrossDomainMessenger_Test is Messenger_Initializer {\n    // Receiver address for testing\n    address recipient = address(0xabbaacdc);\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_L2MessengerPause() external {\n        L2Messenger.pause();\n        assert(L2Messenger.paused());\n    }\n\n    function testCannot_L2MessengerPause() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(0xABBA));\n        L2Messenger.pause();\n    }\n\n    function test_L2MessengerMessageVersion() external {\n        (, uint16 version) = Encoding.decodeVersionedNonce(L2Messenger.messageNonce());\n        assertEq(\n            version,\n            L2Messenger.MESSAGE_VERSION()\n        );\n    }\n\n    function test_L2MessengerSendMessage() external {\n        vm.expectCall(\n            address(messagePasser),\n            abi.encodeWithSelector(\n                L2ToL1MessagePasser.initiateWithdrawal.selector,\n                address(L1Messenger),\n                L2Messenger.baseGas(hex\"ff\", 100),\n                Encoding.encodeCrossDomainMessage(\n                    L2Messenger.messageNonce(),\n                    alice,\n                    recipient,\n                    0,\n                    100,\n                    hex\"ff\"\n                )\n            )\n        );\n\n        // WithdrawalInitiated event\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalInitiated(\n            messagePasser.nonce(),\n            address(L2Messenger),\n            address(L1Messenger),\n            0,\n            L2Messenger.baseGas(hex\"ff\", 100),\n            Encoding.encodeCrossDomainMessage(\n                L2Messenger.messageNonce(),\n                alice,\n                recipient,\n                0,\n                100,\n                hex\"ff\"\n            )\n        );\n\n        vm.prank(alice);\n        L2Messenger.sendMessage(recipient, hex\"ff\", uint32(100));\n    }\n\n    function test_L2MessengerTwiceSendMessage() external {\n        uint256 nonce = L2Messenger.messageNonce();\n        L2Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        L2Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        // the nonce increments for each message sent\n        assertEq(\n            nonce + 2,\n            L2Messenger.messageNonce()\n        );\n    }\n\n    function test_L2MessengerXDomainSenderReverts() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L2Messenger.xDomainMessageSender();\n    }\n\n    function test_L2MessengerRelayMessageSucceeds() external {\n        address target = address(0xabcd);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        vm.expectCall(target, hex\"1111\");\n\n        vm.prank(caller);\n\n        vm.expectEmit(true, true, true, true);\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(\n            0,\n            sender,\n            target,\n            0,\n            0,\n            hex\"1111\"\n        );\n\n        emit RelayedMessage(hash);\n\n        L2Messenger.relayMessage(\n            0, // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n\n        // the message hash is in the successfulMessages mapping\n        assert(L2Messenger.successfulMessages(hash));\n        // it is not in the received messages mapping\n        assertEq(L2Messenger.receivedMessages(hash), false);\n    }\n\n    // relayMessage: should revert if attempting to relay a message sent to an L1 system contract\n    function test_L2MessengerRelayMessageToSystemContract() external {\n        address target = address(messagePasser);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n        bytes memory message = hex\"1111\";\n\n        vm.prank(caller);\n        vm.expectRevert(\"CrossDomainMessenger: message cannot be replayed\");\n        L1Messenger.relayMessage(0, sender, target, 0, 0, message);\n    }\n\n    // relayMessage: the xDomainMessageSender is reset to the original value\n    function test_L2MessengerxDomainMessageSenderResets() external {\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L2Messenger.xDomainMessageSender();\n\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n        vm.prank(caller);\n        L2Messenger.relayMessage(0, address(0), address(0), 0, 0, hex\"\");\n\n        vm.expectRevert(\"CrossDomainMessenger: xDomainMessageSender is not set\");\n        L2Messenger.xDomainMessageSender();\n    }\n\n    // relayMessage: should revert if paused\n    function test_L2MessengerRelayShouldRevertIfPaused() external {\n        vm.prank(L2Messenger.owner());\n        L2Messenger.pause();\n\n        vm.expectRevert(\"Pausable: paused\");\n        L2Messenger.relayMessage(0, address(0), address(0), 0, 0, hex\"\");\n    }\n\n    // relayMessage: should send a successful call to the target contract after the first message\n    // fails and ETH gets stuck, but the second message succeeds\n    function test_L2MessengerRelayMessageFirstStuckSecondSucceeds() external {\n        address target = address(0xabcd);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n        uint256 value = 100;\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(0, sender, target, value, 0, hex\"1111\");\n\n        vm.etch(target, address(new Reverter()).code);\n        vm.deal(address(caller), value);\n        vm.prank(caller);\n        L2Messenger.relayMessage{value: value}(\n            0, // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L2Messenger).balance, value);\n        assertEq(address(target).balance, 0);\n        assertEq(L2Messenger.successfulMessages(hash), false);\n        assertEq(L2Messenger.receivedMessages(hash), true);\n\n        vm.expectEmit(true, true, true, true);\n\n        emit RelayedMessage(hash);\n\n        vm.etch(target, address(0).code);\n        vm.prank(address(sender));\n        L2Messenger.relayMessage(\n            0, // nonce\n            sender,\n            target,\n            value,\n            0,\n            hex\"1111\"\n        );\n\n        assertEq(address(L2Messenger).balance, 0);\n        assertEq(address(target).balance, value);\n        assertEq(L2Messenger.successfulMessages(hash), true);\n        assertEq(L2Messenger.receivedMessages(hash), true);\n    }\n\n    // relayMessage: should revert if recipient is trying to reenter\n    function test_L1MessengerRelayMessageRevertsOnReentrancy() external {\n        address target = address(0xabcd);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n        bytes memory message = abi.encodeWithSelector(\n            L2Messenger.relayMessage.selector,\n            0,\n            sender,\n            target,\n            0,\n            0,\n            hex\"1111\"\n        );\n\n        bytes32 hash = Hashing.hashCrossDomainMessage(0, sender, target, 0, 0, message);\n\n        vm.etch(target, address(new CallerCaller()).code);\n\n        vm.expectEmit(true, true, true, true, target);\n\n        emit WhatHappened(false, abi.encodeWithSignature(\"Error(string)\", \"ReentrancyGuard: reentrant call\"));\n\n        vm.prank(caller);\n        vm.expectCall(target, message);\n        L2Messenger.relayMessage(\n            0, // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            message\n        );\n\n        assertEq(L2Messenger.successfulMessages(hash), false);\n        assertEq(L2Messenger.receivedMessages(hash), true);\n    }\n}\n"
    },
    "contracts/test/L2OutputOracle.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { L2OutputOracle_Initializer, NextImpl } from \"./CommonTest.t.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { Types } from \"../libraries/Types.sol\";\n\ncontract L2OutputOracleTest is L2OutputOracle_Initializer {\n    bytes32 proposedOutput1 = keccak256(abi.encode(1));\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_constructor() external {\n        assertEq(oracle.owner(), owner);\n        assertEq(oracle.SUBMISSION_INTERVAL(), submissionInterval);\n        assertEq(oracle.HISTORICAL_TOTAL_BLOCKS(), historicalTotalBlocks);\n        assertEq(oracle.latestBlockNumber(), startingBlockNumber);\n        assertEq(oracle.STARTING_BLOCK_NUMBER(), startingBlockNumber);\n        assertEq(oracle.STARTING_TIMESTAMP(), startingTimestamp);\n        assertEq(oracle.proposer(), proposer);\n        assertEq(oracle.owner(), owner);\n\n        Types.OutputProposal memory proposal = oracle.getL2Output(startingBlockNumber);\n        assertEq(proposal.outputRoot, genesisL2Output);\n        assertEq(proposal.timestamp, initL1Time);\n    }\n\n    /****************\n     * Getter Tests *\n     ****************/\n\n    // Test: latestBlockNumber() should return the correct value\n    function test_latestBlockNumber() external {\n        uint256 proposedNumber = oracle.nextBlockNumber();\n\n        // Roll to after the block number we'll propose\n        warpToProposeTime(proposedNumber);\n        vm.prank(proposer);\n        oracle.proposeL2Output(proposedOutput1, proposedNumber, 0, 0);\n        assertEq(oracle.latestBlockNumber(), proposedNumber);\n    }\n\n    // Test: getL2Output() should return the correct value\n    function test_getL2Output() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber);\n        vm.prank(proposer);\n        oracle.proposeL2Output(proposedOutput1, nextBlockNumber, 0, 0);\n\n        Types.OutputProposal memory proposal = oracle.getL2Output(nextBlockNumber);\n        assertEq(proposal.outputRoot, proposedOutput1);\n        assertEq(proposal.timestamp, block.timestamp);\n\n        // Handles a block number that is between checkpoints:\n        proposal = oracle.getL2Output(nextBlockNumber - 1);\n        assertEq(proposal.outputRoot, proposedOutput1);\n        assertEq(proposal.timestamp, block.timestamp);\n\n        // The block number is too low:\n        vm.expectRevert(\"L2OutputOracle: block number cannot be less than the starting block number.\");\n        oracle.getL2Output(0);\n\n        // The block number is larger than the latest proposed output:\n        vm.expectRevert(\"L2OutputOracle: No output found for that block number.\");\n        oracle.getL2Output(nextBlockNumber + 1);\n    }\n\n    // Test: nextBlockNumber() should return the correct value\n    function test_nextBlockNumber() external {\n        assertEq(\n            oracle.nextBlockNumber(),\n            // The return value should match this arithmetic\n            oracle.latestBlockNumber() + oracle.SUBMISSION_INTERVAL()\n        );\n    }\n\n    function test_computeL2Timestamp() external {\n        // reverts if timestamp is too low\n        vm.expectRevert(\n            \"L2OutputOracle: block number must be greater than or equal to starting block number\"\n        );\n        oracle.computeL2Timestamp(startingBlockNumber - 1);\n\n        // returns the correct value...\n        // ... for the very first block\n        assertEq(oracle.computeL2Timestamp(startingBlockNumber), startingTimestamp);\n\n        // ... for the first block after the starting block\n        assertEq(\n            oracle.computeL2Timestamp(startingBlockNumber + 1),\n            startingTimestamp + l2BlockTime\n        );\n\n        // ... for some other block number\n        assertEq(\n            oracle.computeL2Timestamp(startingBlockNumber + 96024),\n            startingTimestamp + l2BlockTime * 96024\n        );\n    }\n\n    /*******************\n     * Ownership tests *\n     *******************/\n\n    event ProposerChanged(address indexed previousProposer, address indexed newProposer);\n\n    function test_changeProposer() public {\n        address newProposer = address(20);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        oracle.changeProposer(newProposer);\n\n        vm.startPrank(owner);\n        vm.expectRevert(\"L2OutputOracle: new proposer cannot be the zero address\");\n        oracle.changeProposer(address(0));\n\n        vm.expectRevert(\"L2OutputOracle: proposer cannot be the same as the owner\");\n        oracle.changeProposer(owner);\n\n        // Double check proposer has not changed.\n        assertEq(proposer, oracle.proposer());\n\n        vm.expectEmit(true, true, true, true);\n        emit ProposerChanged(proposer, newProposer);\n        oracle.changeProposer(newProposer);\n        vm.stopPrank();\n    }\n\n    event OwnershipTransferred(address indexed, address indexed);\n\n    function test_updateOwner() public {\n        address newOwner = address(21);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        oracle.transferOwnership(newOwner);\n        // Double check owner has not changed.\n        assertEq(owner, oracle.owner());\n\n        vm.startPrank(owner);\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipTransferred(owner, newOwner);\n        oracle.transferOwnership(newOwner);\n        vm.stopPrank();\n    }\n\n    /*****************************\n     * Propose Tests - Happy Path *\n     *****************************/\n\n    // Test: proposeL2Output succeeds when given valid input, and no block hash and number are\n    // specified.\n    function test_proposingAnotherOutput() public {\n        bytes32 proposedOutput2 = keccak256(abi.encode(2));\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber);\n        uint256 proposedNumber = oracle.latestBlockNumber();\n\n        // Ensure the submissionInterval is enforced\n        assertEq(nextBlockNumber, proposedNumber + submissionInterval);\n\n        vm.roll(nextBlockNumber + 1);\n        vm.prank(proposer);\n        oracle.proposeL2Output(proposedOutput2, nextBlockNumber, 0, 0);\n    }\n\n    // Test: proposeL2Output succeeds when given valid input, and when a block hash and number are\n    // specified for reorg protection.\n    function test_proposeWithBlockhashAndHeight() external {\n        // Get the number and hash of a previous block in the chain\n        uint256 prevL1BlockNumber = block.number - 1;\n        bytes32 prevL1BlockHash = blockhash(prevL1BlockNumber);\n\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber);\n        vm.prank(proposer);\n        oracle.proposeL2Output(nonZeroHash, nextBlockNumber, prevL1BlockHash, prevL1BlockNumber);\n    }\n\n    /***************************\n     * Propose Tests - Sad Path *\n     ***************************/\n\n    // Test: proposeL2Output fails if called by a party that is not the proposer.\n    function testCannot_proposeL2OutputIfNotProposer() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber);\n\n        vm.prank(address(128));\n        vm.expectRevert(\"L2OutputOracle: function can only be called by proposer\");\n        oracle.proposeL2Output(nonZeroHash, nextBlockNumber, 0, 0);\n    }\n\n    // Test: proposeL2Output fails given a zero blockhash.\n    function testCannot_proposeEmptyOutput() external {\n        bytes32 outputToPropose = bytes32(0);\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber);\n        vm.prank(proposer);\n        vm.expectRevert(\"L2OutputOracle: L2 output proposal cannot be the zero hash\");\n        oracle.proposeL2Output(outputToPropose, nextBlockNumber, 0, 0);\n    }\n\n    // Test: proposeL2Output fails if the block number doesn't match the next expected number.\n    function testCannot_proposeUnexpectedBlockNumber() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber);\n        vm.prank(proposer);\n        vm.expectRevert(\"L2OutputOracle: block number must be equal to next expected block number\");\n        oracle.proposeL2Output(nonZeroHash, nextBlockNumber - 1, 0, 0);\n    }\n\n    // Test: proposeL2Output fails if it would have a timestamp in the future.\n    function testCannot_proposeFutureTimetamp() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        uint256 nextTimestamp = oracle.computeL2Timestamp(nextBlockNumber);\n        vm.warp(nextTimestamp);\n        vm.prank(proposer);\n        vm.expectRevert(\"L2OutputOracle: cannot propose L2 output in the future\");\n        oracle.proposeL2Output(nonZeroHash, nextBlockNumber, 0, 0);\n    }\n\n    // Test: proposeL2Output fails if a non-existent L1 block hash and number are provided for reorg\n    // protection.\n    function testCannot_proposeOnWrongFork() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber);\n        vm.prank(proposer);\n        vm.expectRevert(\"L2OutputOracle: blockhash does not match the hash at the expected height\");\n        oracle.proposeL2Output(\n            nonZeroHash,\n            nextBlockNumber,\n            bytes32(uint256(0x01)),\n            block.number - 1\n        );\n    }\n\n    // Test: proposeL2Output fails when given valid input, but the block hash and number do not\n    // match.\n    function testCannot_ProposeWithUnmatchedBlockhash() external {\n        // Move ahead to block 100 so that we can reference historical blocks\n        vm.roll(100);\n\n        // Get the number and hash of a previous block in the chain\n        uint256 l1BlockNumber = block.number - 1;\n        bytes32 l1BlockHash = blockhash(l1BlockNumber);\n\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToProposeTime(nextBlockNumber);\n        vm.prank(proposer);\n\n        // This will fail when foundry no longer returns zerod block hashes\n        vm.expectRevert(\"L2OutputOracle: blockhash does not match the hash at the expected height\");\n        oracle.proposeL2Output(nonZeroHash, nextBlockNumber, l1BlockHash, l1BlockNumber - 1);\n    }\n\n    /*****************************\n     * Delete Tests - Happy Path *\n     *****************************/\n\n    event OutputDeleted(\n        bytes32 indexed l2Output,\n        uint256 indexed l1Timestamp,\n        uint256 indexed l2BlockNumber\n    );\n\n    function test_deleteOutput() external {\n        test_proposingAnotherOutput();\n\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n        Types.OutputProposal memory proposalToDelete = oracle.getL2Output(\n            latestBlockNumber\n        );\n        Types.OutputProposal memory newLatestOutput = oracle.getL2Output(\n            latestBlockNumber - submissionInterval\n        );\n\n        vm.prank(owner);\n        vm.expectEmit(true, true, false, false);\n        emit OutputDeleted(\n            proposalToDelete.outputRoot,\n            proposalToDelete.timestamp,\n            latestBlockNumber\n        );\n        oracle.deleteL2Output(proposalToDelete);\n\n        // validate latestBlockNumber has been reduced\n        uint256 latestBlockNumberAfter = oracle.latestBlockNumber();\n        assertEq(latestBlockNumber - submissionInterval, latestBlockNumberAfter);\n\n        Types.OutputProposal memory proposal = oracle.getL2Output(latestBlockNumberAfter);\n        // validate that the new latest output is as expected.\n        assertEq(newLatestOutput.outputRoot, proposal.outputRoot);\n        assertEq(newLatestOutput.timestamp, proposal.timestamp);\n    }\n\n    /***************************\n     * Delete Tests - Sad Path *\n     ***************************/\n\n    function testCannot_deleteL2Output_ifNotOwner() external {\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n        Types.OutputProposal memory proposal = oracle.getL2Output(latestBlockNumber);\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        oracle.deleteL2Output(proposal);\n    }\n\n    function testCannot_deleteL2Output_withWrongRoot() external {\n        test_proposingAnotherOutput();\n\n        uint256 previousBlockNumber = oracle.latestBlockNumber() - submissionInterval;\n        Types.OutputProposal memory proposalToDelete = oracle.getL2Output(\n            previousBlockNumber\n        );\n\n        vm.prank(owner);\n        vm.expectRevert(\n            \"L2OutputOracle: output root to delete does not match the latest output proposal\"\n        );\n        oracle.deleteL2Output(proposalToDelete);\n    }\n\n    function testCannot_deleteL2Output_withWrongTime() external {\n        test_proposingAnotherOutput();\n\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n        Types.OutputProposal memory proposalToDelete = oracle.getL2Output(\n            latestBlockNumber\n        );\n\n        // Modify the timestamp so that it does not match.\n        proposalToDelete.timestamp -= 1;\n        vm.prank(owner);\n        vm.expectRevert(\n            \"L2OutputOracle: timestamp to delete does not match the latest output proposal\"\n        );\n        oracle.deleteL2Output(proposalToDelete);\n    }\n}\n\ncontract L2OutputOracleUpgradeable_Test is L2OutputOracle_Initializer {\n    Proxy internal proxy;\n\n    function setUp() public override {\n        super.setUp();\n        proxy = Proxy(payable(address(oracle)));\n    }\n\n    function test_initValuesOnProxy() external {\n        assertEq(submissionInterval, oracleImpl.SUBMISSION_INTERVAL());\n        assertEq(historicalTotalBlocks, oracleImpl.HISTORICAL_TOTAL_BLOCKS());\n        assertEq(startingBlockNumber, oracleImpl.STARTING_BLOCK_NUMBER());\n        assertEq(startingTimestamp, oracleImpl.STARTING_TIMESTAMP());\n        assertEq(l2BlockTime, oracleImpl.L2_BLOCK_TIME());\n\n        Types.OutputProposal memory initOutput = oracleImpl.getL2Output(\n            startingBlockNumber\n        );\n        assertEq(genesisL2Output, initOutput.outputRoot);\n        assertEq(initL1Time, initOutput.timestamp);\n\n        assertEq(proposer, oracleImpl.proposer());\n        assertEq(owner, oracleImpl.owner());\n    }\n\n    function test_cannotInitProxy() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        L2OutputOracle(payable(proxy)).initialize(\n            genesisL2Output,\n            startingBlockNumber,\n            proposer,\n            owner\n        );\n    }\n\n    function test_cannotInitImpl() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        L2OutputOracle(oracleImpl).initialize(\n            genesisL2Output,\n            startingBlockNumber,\n            proposer,\n            owner\n        );\n    }\n\n    function test_upgrading() external {\n        // Check an unused slot before upgrading.\n        bytes32 slot21Before = vm.load(address(oracle), bytes32(uint256(21)));\n        assertEq(bytes32(0), slot21Before);\n\n        NextImpl nextImpl = new NextImpl();\n        vm.startPrank(multisig);\n        proxy.upgradeToAndCall(\n            address(nextImpl),\n            abi.encodeWithSelector(NextImpl.initialize.selector)\n        );\n        assertEq(proxy.implementation(), address(nextImpl));\n\n        // Verify that the NextImpl contract initialized its values according as expected\n        bytes32 slot21After = vm.load(address(oracle), bytes32(uint256(21)));\n        bytes32 slot21Expected = NextImpl(address(oracle)).slot21Init();\n        assertEq(slot21Expected, slot21After);\n    }\n}\n"
    },
    "contracts/test/L2StandardBridge.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport { stdStorage, StdStorage } from \"forge-std/Test.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\nimport { console } from \"forge-std/console.sol\";\n\ncontract L2StandardBridge_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_initialize() external {\n        assertEq(\n            address(L2Bridge.messenger()),\n            address(L2Messenger)\n        );\n\n        assertEq(\n            address(L2Bridge.otherBridge()),\n            address(L1Bridge)\n        );\n    }\n\n    // receive\n    // - can accept ETH\n    function test_receive() external {\n        assertEq(address(messagePasser).balance, 0);\n\n        vm.expectEmit(true, true, true, true);\n        emit ETHBridgeInitiated(alice, alice, 100, hex\"\");\n\n        // TODO: L2Messenger should be called\n        // TODO: L2ToL1MessagePasser should be called\n        // TODO: withdrawal hash should be computed correctly\n        // TODO: events from each contract\n\n        vm.prank(alice, alice);\n        (bool success,) = address(L2Bridge).call{ value: 100 }(hex\"\");\n        assertEq(success, true);\n        assertEq(address(messagePasser).balance, 100);\n    }\n\n    // withrdraw\n    // - requires amount == msg.value\n    function test_cannotWithdrawEthWithoutSendingIt() external {\n        assertEq(address(messagePasser).balance, 0);\n\n        vm.expectRevert(\"L2StandardBridge: ETH withdrawals must include sufficient ETH value\");\n        vm.prank(alice, alice);\n        L2Bridge.withdraw(\n            address(Predeploys.LEGACY_ERC20_ETH),\n            100,\n            1000,\n            hex\"\"\n        );\n    }\n\n    // withdraw\n    // - token is burned\n    // - emits WithdrawalInitiated\n    // - calls Withdrawer.initiateWithdrawal\n    function test_withdraw() external {\n        // Alice has 100 L2Token\n        deal(address(L2Token), alice, 100, true);\n        assertEq(L2Token.balanceOf(alice), 100);\n\n        vm.prank(alice, alice);\n        L2Bridge.withdraw(\n            address(L2Token),\n            100,\n            1000,\n            hex\"\"\n        );\n\n        // TODO: events and calls\n\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n\n    function test_withdraw_onlyEOA() external {\n        // This contract has 100 L2Token\n        deal(address(L2Token), address(this), 100, true);\n\n        vm.expectRevert(\"StandardBridge: function can only be called from an EOA\");\n        L2Bridge.withdraw(\n            address(L2Token),\n            100,\n            1000,\n            hex\"\"\n        );\n    }\n\n    // withdrawTo\n    // - token is burned\n    // - emits WithdrawalInitiated w/ correct recipient\n    // - calls Withdrawer.initiateWithdrawal\n    function test_withdrawTo() external {\n        deal(address(L2Token), alice, 100, true);\n\n        vm.prank(alice, alice);\n        L2Bridge.withdrawTo(\n            address(L2Token),\n            bob,\n            100,\n            1000,\n            hex\"\"\n        );\n\n        // TODO: events and calls\n\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n\n    // finalizeDeposit\n    // - only callable by l1TokenBridge\n    // - supported token pair emits DepositFinalized\n    // - invalid deposit emits DepositFailed\n    // - invalid deposit calls Withdrawer.initiateWithdrawal\n    function test_finalizeDeposit() external {\n        // TODO: events and calls\n\n        vm.mockCall(\n            address(L2Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.otherBridge()))\n        );\n        vm.prank(address(L2Messenger));\n        L2Bridge.finalizeDeposit(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n    }\n\n    // finalizeDeposit\n    // - only callable by l1TokenBridge\n    // - supported token pair emits DepositFinalized\n    // - invalid deposit emits DepositFailed\n    // - invalid deposit calls Withdrawer.initiateWithdrawal\n    function test_finalizeDeposit_failsToCompleteOutboundTransfer() external {\n        // TODO: events and calls\n        vm.mockCall(\n            address(L2Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.otherBridge()))\n        );\n        address invalidL2Token = address(0x1234);\n        vm.prank(address(L2Messenger));\n        vm.expectEmit(true, true, true, true);\n        emit ERC20BridgeInitiated(\n            invalidL2Token,\n            address(L1Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n        vm.expectEmit(true, true, true, true);\n        emit ERC20BridgeFailed(\n            invalidL2Token,\n            address(L1Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n        L2Bridge.finalizeDeposit(\n            address(L1Token),\n            invalidL2Token,\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n    }\n\n    // finalizeBridgeERC20\n    // - fails when the local token's address equals bridge address\n    function test_ERC20BridgeFailed_whenLocalTokenIsBridge() external {\n        vm.mockCall(\n            address(L2Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.otherBridge()))\n        );\n        // fails when the local token's address equals bridge address\n        vm.expectEmit(true, true, true, true);\n        emit ERC20BridgeFailed(address(L2Bridge), address(L1Token), alice, bob, 100, hex\"\");\n\n        vm.prank(address(L2Messenger));\n        L2Bridge.finalizeDeposit(address(L1Token), address(L2Bridge), alice, bob, 100, hex\"\");\n    }\n\n    function test_finalizeBridgeERC20FailSendBack() external {\n        deal(address(BadL2Token), address(L2Bridge), 100, true);\n\n        uint256 slot = stdstore\n            .target(address(L2Bridge))\n            .sig(\"deposits(address,address)\")\n            .with_key(address(BadL2Token))\n            .with_key(address(L1Token))\n            .find();\n\n        // Give the L2 bridge some ERC20 tokens\n        vm.store(address(L2Bridge), bytes32(slot), bytes32(uint256(100)));\n        assertEq(L2Bridge.deposits(address(BadL2Token), address(L1Token)), 100);\n\n        vm.expectEmit(true, true, true, true);\n\n        emit ERC20BridgeInitiated(\n            address(BadL2Token),\n            address(L1Token),\n            bob,\n            alice,\n            100,\n            hex\"\"\n        );\n\n        vm.mockCall(\n            address(L2Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.otherBridge()))\n        );\n        vm.prank(address(L2Bridge.messenger()));\n        L2Bridge.finalizeBridgeERC20(\n            address(BadL2Token),\n            address(L1Token),\n            alice,\n            bob,\n            100,\n            hex\"\"\n        );\n\n        assertEq(BadL2Token.balanceOf(address(L2Bridge)), 100);\n        assertEq(BadL2Token.balanceOf(address(alice)), 0);\n    }\n}\n"
    },
    "contracts/test/L2ToL1MessagePasser.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\n\ncontract L2ToL1MessagePasserTest is CommonTest {\n    L2ToL1MessagePasser messagePasser;\n\n    event WithdrawalInitiated(\n        uint256 indexed nonce,\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    event WithdrawalInitiatedExtension1(bytes32 indexed hash);\n\n    event WithdrawerBalanceBurnt(uint256 indexed amount);\n\n    function setUp() virtual public {\n        messagePasser = new L2ToL1MessagePasser();\n    }\n\n    // Test: initiateWithdrawal should emit the correct log when called by a contract\n    function test_initiateWithdrawal_fromContract() external {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalInitiated(\n            messagePasser.nonce(),\n            address(this),\n            address(4),\n            100,\n            64000,\n            hex\"\"\n        );\n\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction(\n                messagePasser.nonce(),\n                address(this),\n                address(4),\n                100,\n                64000,\n                hex\"\"\n            )\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalInitiatedExtension1(withdrawalHash);\n\n        vm.deal(address(this), 2**64);\n        messagePasser.initiateWithdrawal{ value: 100 }(\n            address(4),\n            64000,\n            hex\"\"\n        );\n    }\n\n    // Test: initiateWithdrawal should emit the correct log when called by an EOA\n    function test_initiateWithdrawal_fromEOA() external {\n        uint256 gasLimit = 64000;\n        address target = address(4);\n        uint256 value = 100;\n        bytes memory data = hex\"ff\";\n        uint256 nonce = messagePasser.nonce();\n\n        // EOA emulation\n        vm.prank(alice, alice);\n        vm.deal(alice, 2**64);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalInitiated(\n            nonce,\n            alice,\n            target,\n            value,\n            gasLimit,\n            data\n        );\n\n        bytes32 withdrawalHash = Hashing.hashWithdrawal(\n            Types.WithdrawalTransaction(\n                nonce,\n                alice,\n                target,\n                value,\n                gasLimit,\n                data\n            )\n        );\n\n        messagePasser.initiateWithdrawal{ value: value }(\n            target,\n            gasLimit,\n            data\n        );\n\n        // the sent messages mapping is filled\n        assertEq(messagePasser.sentMessages(withdrawalHash), true);\n        // the nonce increments\n        assertEq(nonce + 1, messagePasser.nonce());\n    }\n\n    // Test: burn should destroy the ETH held in the contract\n    function test_burn() external {\n        messagePasser.initiateWithdrawal{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            NON_ZERO_GASLIMIT,\n            NON_ZERO_DATA\n        );\n\n        assertEq(address(messagePasser).balance, NON_ZERO_VALUE);\n        vm.expectEmit(true, false, false, false);\n        emit WithdrawerBalanceBurnt(NON_ZERO_VALUE);\n        messagePasser.burn();\n\n        // The Withdrawer should have no balance\n        assertEq(address(messagePasser).balance, 0);\n    }\n}\n"
    },
    "contracts/test/LegacyERC20ETH.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { LegacyERC20ETH } from \"../legacy/LegacyERC20ETH.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\n\ncontract LegacyERC20ETH_Test is CommonTest {\n    LegacyERC20ETH eth;\n\n    function setUp() external {\n        eth = new LegacyERC20ETH();\n    }\n\n    function test_metadata() external {\n        assertEq(eth.name(), \"Ether\");\n        assertEq(eth.symbol(), \"ETH\");\n        assertEq(eth.decimals(), 18);\n    }\n\n    function test_crossDomain() external {\n        assertEq(eth.l2Bridge(), Predeploys.L2_STANDARD_BRIDGE);\n        assertEq(eth.l1Token(), address(0));\n    }\n\n    function test_transfer() external {\n        vm.expectRevert(\"LegacyERC20ETH: transfer is disabled\");\n        eth.transfer(alice, 100);\n    }\n\n    function test_approve() external {\n        vm.expectRevert(\"LegacyERC20ETH: approve is disabled\");\n        eth.approve(alice, 100);\n    }\n\n    function test_transferFrom() external {\n        vm.expectRevert(\"LegacyERC20ETH: transferFrom is disabled\");\n        eth.transferFrom(bob, alice, 100);\n    }\n\n    function test_increaseAllowance() external {\n        vm.expectRevert(\"LegacyERC20ETH: increaseAllowance is disabled\");\n        eth.increaseAllowance(alice, 100);\n    }\n\n    function test_decreaseAllowance() external {\n        vm.expectRevert(\"LegacyERC20ETH: decreaseAllowance is disabled\");\n        eth.decreaseAllowance(alice, 100);\n    }\n\n    function test_mint() external {\n        vm.expectRevert(\"LegacyERC20ETH: mint is disabled\");\n        eth.mint(alice, 100);\n    }\n\n    function test_burn() external {\n        vm.expectRevert(\"LegacyERC20ETH: burn is disabled\");\n        eth.burn(alice, 100);\n    }\n}\n"
    },
    "contracts/test/OptimismMintableERC20.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport \"../universal/SupportedInterfaces.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ncontract OptimismMintableERC20_Test is Bridge_Initializer {\n    event Mint(address indexed account, uint256 amount);\n    event Burn(address indexed account, uint256 amount);\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_remoteToken() external {\n        assertEq(L2Token.remoteToken(), address(L1Token));\n    }\n\n    function test_bridge() external {\n        assertEq(L2Token.bridge(), address(L2Bridge));\n    }\n\n    function test_l1Token() external {\n        assertEq(L2Token.l1Token(), address(L1Token));\n    }\n\n    function test_l2Bridge() external {\n        assertEq(L2Token.l2Bridge(), address(L2Bridge));\n    }\n\n    function test_mint() external {\n        vm.expectEmit(true, true, true, true);\n        emit Mint(alice, 100);\n\n        vm.prank(address(L2Bridge));\n        L2Token.mint(alice, 100);\n\n        assertEq(L2Token.balanceOf(alice), 100);\n    }\n\n    function test_mintRevertsFromNotBridge() external {\n        // NOT the bridge\n        vm.expectRevert(\"OptimismMintableERC20: only bridge can mint and burn\");\n        vm.prank(address(alice));\n        L2Token.mint(alice, 100);\n    }\n\n    function test_burn() external {\n        vm.prank(address(L2Bridge));\n        L2Token.mint(alice, 100);\n\n        vm.expectEmit(true, true, true, true);\n        emit Burn(alice, 100);\n\n        vm.prank(address(L2Bridge));\n        L2Token.burn(alice, 100);\n\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n\n    function test_burnRevertsFromNotBridge() external {\n        // NOT the bridge\n        vm.expectRevert(\"OptimismMintableERC20: only bridge can mint and burn\");\n        vm.prank(address(alice));\n        L2Token.burn(alice, 100);\n    }\n\n    function test_erc165_supportsInterface() external {\n        // The assertEq calls in this test are comparing the manual calculation of the iface,\n        // with what is returned by the solidity's type().interfaceId, just to be safe.\n        bytes4 iface1 = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n        assertEq(iface1, type(IERC165).interfaceId);\n        assert(L2Token.supportsInterface(iface1));\n\n        bytes4 iface2 = L2Token.l1Token.selector ^ L2Token.mint.selector ^ L2Token.burn.selector;\n        assertEq(iface2, type(IL1Token).interfaceId);\n        assert(L2Token.supportsInterface(iface2));\n\n        bytes4 iface3 = L2Token.remoteToken.selector ^ L2Token.mint.selector ^ L2Token.burn.selector;\n        assertEq(iface3, type(IRemoteToken).interfaceId);\n        assert(L2Token.supportsInterface(iface3));\n    }\n}\n"
    },
    "contracts/test/OptimismMintableERC20Factory.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport { LibRLP } from \"./RLP.t.sol\";\n\ncontract OptimismMintableTokenFactory_Test is Bridge_Initializer {\n    event StandardL2TokenCreated(address indexed remoteToken, address indexed localToken);\n    event OptimismMintableERC20Created(\n        address indexed localToken,\n        address indexed remoteToken,\n        address deployer\n    );\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_bridge() external {\n        assertEq(address(L2TokenFactory.bridge()), address(L2Bridge));\n    }\n\n    function test_createStandardL2Token() external {\n        address remote = address(4);\n        address local = LibRLP.computeAddress(address(L2TokenFactory), 2);\n\n        vm.expectEmit(true, true, true, true);\n        emit StandardL2TokenCreated(\n            remote,\n            local\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit OptimismMintableERC20Created(\n            remote,\n            local,\n            alice\n        );\n\n        vm.prank(alice);\n        L2TokenFactory.createStandardL2Token(remote, \"Beep\", \"BOOP\");\n    }\n\n    function test_createStandardL2TokenSameTwice() external {\n        address remote = address(4);\n\n        vm.prank(alice);\n        L2TokenFactory.createStandardL2Token(remote, \"Beep\", \"BOOP\");\n\n        address local = LibRLP.computeAddress(address(L2TokenFactory), 3);\n\n        vm.expectEmit(true, true, true, true);\n        emit StandardL2TokenCreated(\n            remote,\n            local\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit OptimismMintableERC20Created(\n            remote,\n            local,\n            alice\n        );\n\n        vm.prank(alice);\n        L2TokenFactory.createStandardL2Token(remote, \"Beep\", \"BOOP\");\n    }\n\n    function test_createStandardL2TokenShouldRevertIfRemoteIsZero() external {\n        address remote = address(0);\n        vm.expectRevert(\"OptimismMintableERC20Factory: must provide remote token address\");\n        L2TokenFactory.createStandardL2Token(remote, \"Beep\", \"BOOP\");\n    }\n}\n"
    },
    "contracts/test/OptimismPortal.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Portal_Initializer, CommonTest, NextImpl } from \"./CommonTest.t.sol\";\nimport { AddressAliasHelper } from \"../vendor/AddressAliasHelper.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { OptimismPortal } from \"../L1/OptimismPortal.sol\";\nimport { Types } from \"../libraries/Types.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\n\ncontract OptimismPortal_Test is Portal_Initializer {\n    function test_OptimismPortalConstructor() external {\n        assertEq(op.FINALIZATION_PERIOD_SECONDS(), 7 days);\n        assertEq(address(op.L2_ORACLE()), address(oracle));\n        assertEq(op.l2Sender(), 0x000000000000000000000000000000000000dEaD);\n    }\n\n    function test_OptimismPortalReceiveEth() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(alice, alice, 100, 100, 100_000, false, hex\"\");\n\n        // give alice money and send as an eoa\n        vm.deal(alice, 2**64);\n        vm.prank(alice, alice);\n        (bool s, ) = address(op).call{ value: 100 }(hex\"\");\n\n        assert(s);\n        assertEq(address(op).balance, 100);\n    }\n\n    // Test: depositTransaction fails when contract creation has a non-zero destination address\n    function test_OptimismPortalContractCreationReverts() external {\n        // contract creation must have a target of address(0)\n        vm.expectRevert(\"OptimismPortal: must send to address(0) when creating a contract\");\n        op.depositTransaction(address(1), 1, 0, true, hex\"\");\n    }\n\n    // Test: depositTransaction should emit the correct log when an EOA deposits a tx with 0 value\n    function test_depositTransaction_NoValueEOA() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    // Test: depositTransaction should emit the correct log when a contract deposits a tx with 0 value\n    function test_depositTransaction_NoValueContract() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    // Test: depositTransaction should emit the correct log when an EOA deposits a contract creation with 0 value\n    function test_depositTransaction_createWithZeroValueForEOA() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction(ZERO_ADDRESS, ZERO_VALUE, NON_ZERO_GASLIMIT, true, NON_ZERO_DATA);\n    }\n\n    // Test: depositTransaction should emit the correct log when a contract deposits a contract creation with 0 value\n    function test_depositTransaction_createWithZeroValueForContract() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction(ZERO_ADDRESS, ZERO_VALUE, NON_ZERO_GASLIMIT, true, NON_ZERO_DATA);\n    }\n\n    // Test: depositTransaction should increase its eth balance when an EOA deposits a transaction with ETH\n    function test_depositTransaction_withEthValueFromEOA() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            NON_ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n        assertEq(address(op).balance, NON_ZERO_VALUE);\n    }\n\n    // Test: depositTransaction should increase its eth balance when a contract deposits a transaction with ETH\n    function test_depositTransaction_withEthValueFromContract() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            NON_ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    // Test: depositTransaction should increase its eth balance when an EOA deposits a contract creation with ETH\n    function test_depositTransaction_withEthValueAndEOAContractCreation() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            address(this),\n            ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            hex\"\"\n        );\n\n        op.depositTransaction{ value: NON_ZERO_VALUE }(\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            hex\"\"\n        );\n        assertEq(address(op).balance, NON_ZERO_VALUE);\n    }\n\n    // Test: depositTransaction should increase its eth balance when a contract deposits a contract creation with ETH\n    function test_depositTransaction_withEthValueAndContractContractCreation() external {\n        vm.expectEmit(true, true, false, true);\n        emitTransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction{ value: NON_ZERO_VALUE }(\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n        assertEq(address(op).balance, NON_ZERO_VALUE);\n    }\n\n    function test_simple_isBlockFinalized() external {\n        vm.mockCall(\n            address(op.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(Types.OutputProposal(bytes32(uint256(1)), startingBlockNumber))\n        );\n\n        // warp to the finalization period\n        vm.warp(startingBlockNumber + op.FINALIZATION_PERIOD_SECONDS());\n        assertEq(op.isBlockFinalized(startingBlockNumber), false);\n        // warp past the finalization period\n        vm.warp(startingBlockNumber + op.FINALIZATION_PERIOD_SECONDS() + 1);\n        assertEq(op.isBlockFinalized(startingBlockNumber), true);\n    }\n\n    function test_isBlockFinalized() external {\n        uint256 checkpoint = oracle.nextBlockNumber();\n        vm.roll(checkpoint);\n        vm.warp(oracle.computeL2Timestamp(checkpoint) + 1);\n        vm.prank(oracle.proposer());\n        oracle.proposeL2Output(keccak256(abi.encode(2)), checkpoint, 0, 0);\n\n        // warp to the final second of the finalization period\n        uint256 finalizationHorizon = block.timestamp + op.FINALIZATION_PERIOD_SECONDS();\n        vm.warp(finalizationHorizon);\n        // The checkpointed block should not be finalized until 1 second from now.\n        assertEq(op.isBlockFinalized(checkpoint), false);\n        // Nor should a block after it\n        vm.expectRevert(\"L2OutputOracle: No output found for that block number.\");\n        assertEq(op.isBlockFinalized(checkpoint + 1), false);\n        // Nor a block before it, even though the finalization period has passed, there is\n        // not yet a checkpoint block on top of it for which that is true.\n        assertEq(op.isBlockFinalized(checkpoint - 1), false);\n\n        // warp past the finalization period\n        vm.warp(finalizationHorizon + 1);\n        // It should now be finalized.\n        assertEq(op.isBlockFinalized(checkpoint), true);\n        // So should the block before it.\n        assertEq(op.isBlockFinalized(checkpoint - 1), true);\n        // But not the block after it.\n        vm.expectRevert(\"L2OutputOracle: No output found for that block number.\");\n        assertEq(op.isBlockFinalized(checkpoint + 1), false);\n    }\n}\n\ncontract OptimismPortal_FinalizeWithdrawal_Test is Portal_Initializer {\n    // Reusable default values for a test withdrawal\n    Types.WithdrawalTransaction _defaultTx;\n\n    uint256 _proposedBlockNumber;\n    bytes32 _stateRoot;\n    bytes32 _storageRoot;\n    bytes32 _outputRoot;\n    bytes32 _withdrawalHash;\n    bytes _withdrawalProof;\n    Types.OutputRootProof internal _outputRootProof;\n\n    event WithdrawalFinalized(bytes32 indexed, bool success);\n\n    // Use a constructor to set the storage vars above, so as to minimize the number of ffi calls.\n    constructor() {\n        super.setUp();\n        _defaultTx = Types.WithdrawalTransaction({\n            nonce: 0,\n            sender: alice,\n            target: bob,\n            value: 100,\n            gasLimit: 100_000,\n            data: hex\"\"\n        });\n        // Get withdrawal proof data we can use for testing.\n        (_stateRoot, _storageRoot, _outputRoot, _withdrawalHash, _withdrawalProof) = ffi\n            .getFinalizeWithdrawalTransactionInputs(_defaultTx);\n\n        // Setup a dummy output root proof for reuse.\n        _outputRootProof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: _stateRoot,\n            withdrawerStorageRoot: _storageRoot,\n            latestBlockhash: bytes32(uint256(0))\n        });\n        _proposedBlockNumber = oracle.nextBlockNumber();\n    }\n\n    // Get the system into a nice ready-to-use state.\n    function setUp() public override {\n        // Configure the oracle to return the output root we've prepared.\n        vm.warp(oracle.computeL2Timestamp(_proposedBlockNumber) + 1);\n        vm.prank(oracle.proposer());\n        oracle.proposeL2Output(_outputRoot, _proposedBlockNumber, 0, 0);\n\n        // Warp beyond the finalization period for the block we've proposed.\n        vm.warp(\n            oracle.getL2Output(_proposedBlockNumber).timestamp +\n                op.FINALIZATION_PERIOD_SECONDS() +\n                1\n        );\n        // Fund the portal so that we can withdraw ETH.\n        vm.deal(address(op), 0xFFFFFFFF);\n    }\n\n    // Test: finalizeWithdrawalTransaction succeeds and emits the WithdrawalFinalized event.\n    function test_finalizeWithdrawalTransaction_succeeds() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalFinalized(_withdrawalHash, true);\n        op.finalizeWithdrawalTransaction(\n            _defaultTx,\n            _proposedBlockNumber,\n            _outputRootProof,\n            _withdrawalProof\n        );\n        assert(address(bob).balance == bobBalanceBefore + 100);\n    }\n\n    // Test: finalizeWithdrawalTransaction fails because the target reverts,\n    // and emits the WithdrawalFinalized event with success=false.\n    function test_finalizeWithdrawalTransaction_targetFails() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n        vm.etch(bob, hex\"fe\"); // Contract with just the invalid opcode.\n\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalFinalized(_withdrawalHash, false);\n        op.finalizeWithdrawalTransaction(\n            _defaultTx,\n            _proposedBlockNumber,\n            _outputRootProof,\n            _withdrawalProof\n        );\n        assert(address(bob).balance == bobBalanceBefore);\n    }\n\n    // Test: finalizeWithdrawalTransaction cannot finalize a withdrawal with itself (the OptimismPortal) as the target.\n    function test_finalizeWithdrawalTransaction_revertsOnSelfCall() external {\n        _defaultTx.target = address(op);\n        vm.expectRevert(\"OptimismPortal: you cannot send messages to the portal contract\");\n        op.finalizeWithdrawalTransaction(\n            _defaultTx,\n            _proposedBlockNumber,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the outputRootProof does not match the output root\n    function test_finalizeWithdrawalTransaction_revertsOnInvalidOutputRootProof() external {\n        // Modify the version to invalidate the withdrawal proof.\n        _outputRootProof.version = bytes32(uint256(1));\n        vm.expectRevert(\"OptimismPortal: invalid output root proof\");\n        op.finalizeWithdrawalTransaction(\n            _defaultTx,\n            _proposedBlockNumber,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the finalization period has not yet passed.\n    function test_finalizeWithdrawalTransaction_revertsOnRecentWithdrawal() external {\n        // Setup the Oracle to return an output with a recent timestamp\n        uint256 recentTimestamp = block.timestamp - 1000;\n        vm.mockCall(\n            address(op.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(bytes32(uint256(1)), recentTimestamp)\n        );\n\n        vm.expectRevert(\"OptimismPortal: proposal is not yet finalized\");\n        op.finalizeWithdrawalTransaction(\n            _defaultTx,\n            _proposedBlockNumber,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the withdrawal has already been finalized.\n    function test_finalizeWithdrawalTransaction_revertsOnReplay() external {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalFinalized(_withdrawalHash, true);\n        op.finalizeWithdrawalTransaction(\n            _defaultTx,\n            _proposedBlockNumber,\n            _outputRootProof,\n            _withdrawalProof\n        );\n        vm.expectRevert(\"OptimismPortal: withdrawal has already been finalized\");\n        op.finalizeWithdrawalTransaction(\n            _defaultTx,\n            _proposedBlockNumber,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if insufficient gas is supplied.\n    function test_finalizeWithdrawalTransaction_revertsOnInsufficientGas() external {\n        // This number was identified through trial and error.\n        uint256 gasLimit = 150_000;\n        Types.WithdrawalTransaction memory insufficientGasTx = Types.WithdrawalTransaction({\n            nonce: 0,\n            sender: alice,\n            target: bob,\n            value: 100,\n            gasLimit: gasLimit,\n            data: hex\"\"\n        });\n        (\n            bytes32 stateRoot,\n            bytes32 storageRoot,\n            ,\n            ,\n            bytes memory withdrawalProof\n        ) = ffi.getFinalizeWithdrawalTransactionInputs(insufficientGasTx);\n        Types.OutputRootProof memory outputRootProof = Types.OutputRootProof({\n            version: bytes32(0),\n            stateRoot: stateRoot,\n            withdrawerStorageRoot: storageRoot,\n            latestBlockhash: bytes32(0)\n        });\n        vm.mockCall(\n            address(op.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(Hashing.hashOutputRootProof(outputRootProof), _proposedBlockNumber)\n        );\n        vm.expectRevert(\"OptimismPortal: insufficient gas to finalize withdrawal\");\n        op.finalizeWithdrawalTransaction{ gas: gasLimit }(\n            insufficientGasTx,\n            _proposedBlockNumber,\n            outputRootProof,\n            withdrawalProof\n        );\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if the proof is invalid due to non-existence of\n    // the withdrawal.\n    function test_finalizeWithdrawalTransaction_revertsOninvalidWithdrawalProof() external {\n        // modify the default test values to invalidate the proof.\n        _defaultTx.data = hex\"abcd\";\n        vm.expectRevert(\"OptimismPortal: invalid withdrawal inclusion proof\");\n        op.finalizeWithdrawalTransaction(\n            _defaultTx,\n            _proposedBlockNumber,\n            _outputRootProof,\n            _withdrawalProof\n        );\n    }\n\n    // Utility function used in the subsequent test. This is necessary to assert that the\n    // reentrant call will revert.\n    function callPortalAndExpectRevert() external payable {\n        vm.expectRevert(\"OptimismPortal: can only trigger one withdrawal per transaction\");\n        // Arguments here don't matter, as the require check is the first thing that happens.\n        op.finalizeWithdrawalTransaction(_defaultTx, 0, _outputRootProof, hex\"\");\n        // Assert that the withdrawal was not finalized.\n        assertFalse(op.finalizedWithdrawals(Hashing.hashWithdrawal(_defaultTx)));\n    }\n\n    // Test: finalizeWithdrawalTransaction reverts if a sub-call attempts to finalize another\n    // withdrawal.\n    function test_finalizeWithdrawalTransaction_revertsOnReentrancy() external {\n        uint256 bobBalanceBefore = address(bob).balance;\n        // Copy and modify the default test values to attempt a reentrant call by first calling to\n        // this contract's callPortalAndExpectRevert() function above.\n        Types.WithdrawalTransaction memory _testTx = _defaultTx;\n        _testTx.target = address(this);\n        _testTx.data = abi.encodeWithSelector(this.callPortalAndExpectRevert.selector);\n\n        // Get modified proof inputs.\n        (\n            bytes32 stateRoot,\n            bytes32 storageRoot,\n            bytes32 outputRoot,\n            bytes32 withdrawalHash,\n            bytes memory withdrawalProof\n        ) = ffi.getFinalizeWithdrawalTransactionInputs(_testTx);\n        Types.OutputRootProof memory outputRootProof = Types.OutputRootProof({\n            version: bytes32(0),\n            stateRoot: stateRoot,\n            withdrawerStorageRoot: storageRoot,\n            latestBlockhash: bytes32(0)\n        });\n\n        // Setup the Oracle to return the outputRoot we want as well as a finalized timestamp.\n        uint256 finalizedTimestamp = block.timestamp - op.FINALIZATION_PERIOD_SECONDS() - 1;\n        vm.mockCall(\n            address(op.L2_ORACLE()),\n            abi.encodeWithSelector(L2OutputOracle.getL2Output.selector),\n            abi.encode(Types.OutputProposal(outputRoot, finalizedTimestamp))\n        );\n\n        // Assert that this contract is called with the expected data (i.e. the function signature of\n        // callPortalAndExpectRevert).\n        vm.expectCall(address(this), _testTx.data);\n        vm.expectEmit(true, true, true, true);\n        // Assert that the withdrawal should be finalized, and that the sub-call passes (because the\n        // assertions in callPortalAndExpectRevert pass).\n        emit WithdrawalFinalized(withdrawalHash, true);\n        op.finalizeWithdrawalTransaction(\n            _testTx,\n            _proposedBlockNumber,\n            outputRootProof,\n            withdrawalProof\n        );\n        // Ensure that bob's balance was not changed by the reentrant call.\n        assert(address(bob).balance == bobBalanceBefore);\n    }\n\n    function test_finalizeWithdrawalTransaction_differential(\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        // Cannot call the optimism portal\n        vm.assume(_target != address(op));\n        // Total ETH supply is currently about 120M ETH.\n        vm.assume(_value < 200_000_000 ether);\n        vm.assume(_gasLimit < 50_000_000);\n        uint256 _nonce = messagePasser.nonce();\n        Types.WithdrawalTransaction memory _tx = Types.WithdrawalTransaction({\n            nonce: _nonce,\n            sender: _sender,\n            target: _target,\n            value: _value,\n            gasLimit: _gasLimit,\n            data: _data\n        });\n        (\n            bytes32 stateRoot,\n            bytes32 storageRoot,\n            bytes32 outputRoot,\n            bytes32 withdrawalHash,\n            bytes memory withdrawalProof\n        ) = ffi.getFinalizeWithdrawalTransactionInputs(_tx);\n\n        Types.OutputRootProof memory proof = Types.OutputRootProof({\n            version: bytes32(uint256(0)),\n            stateRoot: stateRoot,\n            withdrawerStorageRoot: storageRoot,\n            latestBlockhash: bytes32(uint256(0))\n        });\n\n        // Ensure the values returned from ffi are correct\n        assertEq(outputRoot, Hashing.hashOutputRootProof(proof));\n        assertEq(withdrawalHash, Hashing.hashWithdrawal(_tx));\n\n        // Mock the call to the oracle\n        vm.mockCall(\n            address(oracle),\n            abi.encodeWithSelector(oracle.getL2Output.selector),\n            abi.encode(outputRoot, 0)\n        );\n\n        // Start the withdrawal, it must be initiated by the _sender and the\n        // correct value must be passed along\n        vm.deal(_tx.sender, _tx.value);\n        vm.prank(_tx.sender);\n        messagePasser.initiateWithdrawal{ value: _tx.value }(_tx.target, _tx.gasLimit, _tx.data);\n        // Ensure that the sentMessages is correct\n        assertEq(messagePasser.sentMessages(withdrawalHash), true);\n\n        vm.warp(op.FINALIZATION_PERIOD_SECONDS() + 1);\n        op.finalizeWithdrawalTransaction{ value: _tx.value }(\n            _tx,\n            100, // l2BlockNumber\n            proof,\n            withdrawalProof\n        );\n    }\n}\n\ncontract OptimismPortalUpgradeable_Test is Portal_Initializer {\n    Proxy internal proxy;\n    uint64 initialBlockNum;\n\n    function setUp() public override {\n        super.setUp();\n        initialBlockNum = uint64(block.number);\n        proxy = Proxy(payable(address(op)));\n    }\n\n    function test_initValuesOnProxy() external {\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = OptimismPortal(\n            payable(address(proxy))\n        ).params();\n        assertEq(prevBaseFee, opImpl.INITIAL_BASE_FEE());\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum);\n    }\n\n    function test_cannotInitProxy() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        OptimismPortal(payable(proxy)).initialize();\n    }\n\n    function test_cannotInitImpl() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        OptimismPortal(opImpl).initialize();\n    }\n\n    function test_upgrading() external {\n        // Check an unused slot before upgrading.\n        bytes32 slot21Before = vm.load(address(op), bytes32(uint256(21)));\n        assertEq(bytes32(0), slot21Before);\n\n        NextImpl nextImpl = new NextImpl();\n        vm.startPrank(multisig);\n        proxy.upgradeToAndCall(\n            address(nextImpl),\n            abi.encodeWithSelector(NextImpl.initialize.selector)\n        );\n        assertEq(proxy.implementation(), address(nextImpl));\n\n        // Verify that the NextImpl contract initialized its values according as expected\n        bytes32 slot21After = vm.load(address(op), bytes32(uint256(21)));\n        bytes32 slot21Expected = NextImpl(address(op)).slot21Init();\n        assertEq(slot21Expected, slot21After);\n    }\n}\n"
    },
    "contracts/test/Proxy.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\ncontract SimpleStorage {\n    mapping(uint256 => uint256) internal store;\n\n    function get(uint256 key) external payable returns (uint256) {\n        return store[key];\n    }\n\n    function set(uint256 key, uint256 value) external payable {\n        store[key] = value;\n    }\n}\n\ncontract Clasher {\n    function upgradeTo(address) external pure {\n        revert(\"upgradeTo\");\n    }\n}\n\ncontract Proxy_Test is Test {\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    address alice = address(64);\n\n    bytes32 internal constant IMPLEMENTATION_KEY =\n        bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1);\n\n    bytes32 internal constant OWNER_KEY =\n        bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1);\n\n    Proxy proxy;\n    SimpleStorage simpleStorage;\n\n    function setUp() external {\n        // Deploy a proxy and simple storage contract as\n        // the implementation\n        proxy = new Proxy(alice);\n        simpleStorage = new SimpleStorage();\n\n        vm.prank(alice);\n        proxy.upgradeTo(address(simpleStorage));\n    }\n\n    function test_implementationKey() external {\n        // The hardcoded implementation key should be correct\n        vm.prank(alice);\n        proxy.upgradeTo(address(6));\n\n        bytes32 key = vm.load(address(proxy), IMPLEMENTATION_KEY);\n        assertEq(\n            address(6),\n            Bytes32AddressLib.fromLast20Bytes(key)\n        );\n\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(6));\n    }\n\n    function test_ownerKey() external {\n        // The hardcoded owner key should be correct\n        vm.prank(alice);\n        proxy.changeAdmin(address(6));\n\n        bytes32 key = vm.load(address(proxy), OWNER_KEY);\n        assertEq(\n            address(6),\n            Bytes32AddressLib.fromLast20Bytes(key)\n        );\n\n        vm.prank(address(6));\n        address owner = proxy.admin();\n        assertEq(owner, address(6));\n    }\n\n    function test_implementationProxyCallIfNotAdmin() external {\n        // The implementation does not have a `upgradeTo`\n        // method, calling `upgradeTo` not as the owner\n        // should revert.\n        vm.expectRevert();\n        proxy.upgradeTo(address(64));\n\n        // Call `upgradeTo` as the owner, it should succeed\n        // and emit the `Upgraded` event.\n        vm.expectEmit(true, true, true, true);\n        emit Upgraded(address(64));\n        vm.prank(alice);\n        proxy.upgradeTo(address(64));\n\n        // Get the implementation as the owner\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(64));\n    }\n\n    function test_ownerProxyCallIfNotAdmin() external {\n        // Calling `changeAdmin` not as the owner should revert\n        // as the implementation does not have a `changeAdmin` method.\n        vm.expectRevert();\n        proxy.changeAdmin(address(1));\n\n        // Call `changeAdmin` as the owner, it should succeed\n        // and emit the `AdminChanged` event.\n        vm.expectEmit(true, true, true, true);\n        emit AdminChanged(alice, address(1));\n        vm.prank(alice);\n        proxy.changeAdmin(address(1));\n\n        // Calling `admin` not as the owner should\n        // revert as the implementation does not have\n        // a `admin` method.\n        vm.expectRevert();\n        proxy.admin();\n\n        // Calling `admin` as the owner should work.\n        vm.prank(address(1));\n        address owner = proxy.admin();\n        assertEq(owner, address(1));\n    }\n\n    function test_itDelegatesToTheImplementation() external {\n        // Call the storage setter on the proxy\n        SimpleStorage(address(proxy)).set(1, 1);\n\n        // The key should not be set in the implementation\n        uint256 result = simpleStorage.get(1);\n        assertEq(result, 0);\n        {\n            // The key should be set in the proxy\n            uint256 expect = SimpleStorage(address(proxy)).get(1);\n            assertEq(expect, 1);\n        }\n\n        {\n            // The owner should be able to call through the proxy\n            // when there is not a function selector crash\n            vm.prank(alice);\n            uint256 expect = SimpleStorage(address(proxy)).get(1);\n            assertEq(expect, 1);\n        }\n    }\n\n    function test_upgradeToAndCall() external {\n        {\n            // There should be nothing in the current proxy storage\n            uint256 expect = SimpleStorage(address(proxy)).get(1);\n            assertEq(expect, 0);\n        }\n\n        // Deploy a new SimpleStorage\n        simpleStorage = new SimpleStorage();\n\n        // Set the new SimpleStorage as the implementation\n        // and call.\n        vm.expectEmit(true, true, true, true);\n        emit Upgraded(address(simpleStorage));\n        vm.prank(alice);\n        proxy.upgradeToAndCall(\n            address(simpleStorage),\n            abi.encodeWithSelector(simpleStorage.set.selector, 1, 1)\n        );\n\n        // The call should have impacted the state\n        uint256 result = SimpleStorage(address(proxy)).get(1);\n        assertEq(result, 1);\n    }\n\n    function test_revertUpgradeToAndCall() external {\n        // Get the current implementation address\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(simpleStorage));\n\n        // Deploy a new SimpleStorage\n        simpleStorage = new SimpleStorage();\n\n        // Set the new SimpleStorage as the implementation\n        // and call. This reverts because the calldata doesn't\n        // match a function on the implementation.\n        vm.expectRevert(\"Proxy: delegatecall to new implementation contract failed\");\n        vm.prank(alice);\n        proxy.upgradeToAndCall(\n            address(simpleStorage),\n            hex\"\"\n        );\n\n        // The implementation address should have not\n        // updated because the call to `upgradeToAndCall`\n        // reverted.\n        vm.prank(alice);\n        address postImpl = proxy.implementation();\n        assertEq(impl, postImpl);\n\n        // The attempt to `upgradeToAndCall`\n        // should revert when it is not called by the owner.\n        vm.expectRevert();\n        proxy.upgradeToAndCall(\n            address(simpleStorage),\n            abi.encodeWithSelector(simpleStorage.set.selector, 1, 1)\n        );\n    }\n\n    function test_payableUpgradeToAndCall() external {\n        // Give alice some funds\n        vm.deal(alice, 1 ether);\n        // Set the implementation and call and send\n        // value.\n        vm.prank(alice);\n        proxy.upgradeToAndCall{ value: 1 ether }(\n            address(simpleStorage),\n            abi.encodeWithSelector(simpleStorage.set.selector, 1, 1)\n        );\n\n        // The implementation address should be correct\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(simpleStorage));\n\n        // The proxy should have a balance\n        assertEq(address(proxy).balance, 1 ether);\n    }\n\n    function test_clashingFunctionSignatures() external {\n        // Clasher has a clashing function with the proxy.\n        Clasher clasher = new Clasher();\n\n        // Set the clasher as the implementation.\n        vm.prank(alice);\n        proxy.upgradeTo(address(clasher));\n\n        {\n            // Assert that the implementation was set properly.\n            vm.prank(alice);\n            address impl = proxy.implementation();\n            assertEq(impl, address(clasher));\n        }\n\n        // Call the clashing function on the proxy\n        // not as the owner so that the call passes through.\n        // The implementation will revert so we can be\n        // sure that the call passed through.\n        vm.expectRevert(bytes(\"upgradeTo\"));\n        proxy.upgradeTo(address(0));\n\n        {\n            // Now call the clashing function as the owner\n            // and be sure that it doesn't pass through to\n            // the implementation.\n            vm.prank(alice);\n            proxy.upgradeTo(address(0));\n            vm.prank(alice);\n            address impl = proxy.implementation();\n            assertEq(impl, address(0));\n        }\n    }\n\n    // Allow for `eth_call` to call proxy methods\n    // by setting \"from\" to `address(0)`.\n    function test_zeroAddressCaller() external {\n        vm.prank(address(0));\n        address impl = proxy.implementation();\n        assertEq(impl, address(simpleStorage));\n    }\n\n    function test_implementationZeroAddress() external {\n        // Set `address(0)` as the implementation.\n        vm.prank(alice);\n        proxy.upgradeTo(address(0));\n\n        (bool success, bytes memory returndata) = address(proxy).call(hex\"\");\n        assertEq(success, false);\n\n        bytes memory err = abi.encodeWithSignature(\n            \"Error(string)\",\n            \"Proxy: implementation not initialized\"\n        );\n\n        assertEq(returndata, err);\n    }\n}\n"
    },
    "contracts/test/ProxyAdmin.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { ProxyAdmin } from \"../universal/ProxyAdmin.sol\";\nimport { SimpleStorage } from \"./Proxy.t.sol\";\nimport { L1ChugSplashProxy } from \"../legacy/L1ChugSplashProxy.sol\";\nimport { ResolvedDelegateProxy } from \"../legacy/ResolvedDelegateProxy.sol\";\nimport { AddressManager } from \"../legacy/AddressManager.sol\";\n\ncontract ProxyAdmin_Test is Test {\n    address alice = address(64);\n\n    Proxy proxy;\n    L1ChugSplashProxy chugsplash;\n    ResolvedDelegateProxy resolved;\n\n    AddressManager addressManager;\n\n    ProxyAdmin admin;\n\n    SimpleStorage implementation;\n\n    function setUp() external {\n        // Deploy the proxy admin\n        admin = new ProxyAdmin(alice);\n        // Deploy the standard proxy\n        proxy = new Proxy(address(admin));\n\n        // Deploy the legacy L1ChugSplashProxy with the admin as the owner\n        chugsplash = new L1ChugSplashProxy(address(admin));\n\n        // Deploy the legacy AddressManager\n        addressManager = new AddressManager();\n        // The proxy admin must be the new owner of the address manager\n        addressManager.transferOwnership(address(admin));\n        // Deploy a legacy ResolvedDelegateProxy with the name `a`.\n        // Whatever `a` is set to in AddressManager will be the address\n        // that is used for the implementation.\n        resolved = new ResolvedDelegateProxy(addressManager, \"a\");\n\n        // Impersonate alice for setting up the admin.\n        vm.startPrank(alice);\n        // Set the address of the address manager in the admin so that it\n        // can resolve the implementation address of legacy\n        // ResolvedDelegateProxy based proxies.\n        admin.setAddressManager(addressManager);\n        // Set the reverse lookup of the ResolvedDelegateProxy\n        // proxy\n        admin.setImplementationName(address(resolved), \"a\");\n\n        // Set the proxy types\n        admin.setProxyType(address(proxy), ProxyAdmin.ProxyType.ERC1967);\n        admin.setProxyType(address(chugsplash), ProxyAdmin.ProxyType.CHUGSPLASH);\n        admin.setProxyType(address(resolved), ProxyAdmin.ProxyType.RESOLVED);\n        vm.stopPrank();\n\n        implementation = new SimpleStorage();\n    }\n\n    function test_setImplementationName() external {\n        vm.prank(alice);\n        admin.setImplementationName(address(1), \"foo\");\n        assertEq(\n            admin.implementationName(address(1)),\n            \"foo\"\n        );\n    }\n\n    function test_onlyOwnerSetAddressManager() external {\n        vm.expectRevert(\"UNAUTHORIZED\");\n        admin.setAddressManager(AddressManager((address(0))));\n    }\n\n    function test_onlyOwnerSetImplementationName() external {\n        vm.expectRevert(\"UNAUTHORIZED\");\n        admin.setImplementationName(address(0), \"foo\");\n    }\n\n    function test_onlyOwnerSetProxyType() external {\n        vm.expectRevert(\"UNAUTHORIZED\");\n        admin.setProxyType(address(0), ProxyAdmin.ProxyType.CHUGSPLASH);\n    }\n\n    function test_owner() external {\n        assertEq(admin.owner(), alice);\n    }\n\n    function test_proxyType() external {\n        assertEq(\n            uint256(admin.proxyType(address(proxy))),\n            uint256(ProxyAdmin.ProxyType.ERC1967)\n        );\n        assertEq(\n            uint256(admin.proxyType(address(chugsplash))),\n            uint256(ProxyAdmin.ProxyType.CHUGSPLASH)\n        );\n        assertEq(\n            uint256(admin.proxyType(address(resolved))),\n            uint256(ProxyAdmin.ProxyType.RESOLVED)\n        );\n    }\n\n    function test_erc1967GetProxyImplementation() external {\n        getProxyImplementation(payable(proxy));\n    }\n\n    function test_chugsplashGetProxyImplementation() external {\n        getProxyImplementation(payable(chugsplash));\n    }\n\n    function test_delegateResolvedGetProxyImplementation() external {\n        getProxyImplementation(payable(resolved));\n    }\n\n    function getProxyImplementation(address payable _proxy) internal {\n        {\n            address impl = admin.getProxyImplementation(_proxy);\n            assertEq(impl, address(0));\n        }\n\n        vm.prank(alice);\n        admin.upgrade(_proxy, address(implementation));\n\n        {\n            address impl = admin.getProxyImplementation(_proxy);\n            assertEq(impl, address(implementation));\n        }\n    }\n\n    function test_erc1967GetProxyAdmin() external {\n        getProxyAdmin(payable(proxy));\n    }\n\n    function test_chugsplashGetProxyAdmin() external {\n        getProxyAdmin(payable(chugsplash));\n    }\n\n    function test_delegateResolvedGetProxyAdmin() external {\n        getProxyAdmin(payable(resolved));\n    }\n\n    function getProxyAdmin(address payable _proxy) internal {\n        address owner = admin.getProxyAdmin(_proxy);\n        assertEq(owner, address(admin));\n    }\n\n    function test_erc1967ChangeProxyAdmin() external {\n        changeProxyAdmin(payable(proxy));\n    }\n\n    function test_chugsplashChangeProxyAdmin() external {\n        changeProxyAdmin(payable(chugsplash));\n    }\n\n    function test_delegateResolvedChangeProxyAdmin() external {\n        changeProxyAdmin(payable(resolved));\n    }\n\n    function changeProxyAdmin(address payable _proxy) internal {\n        ProxyAdmin.ProxyType proxyType = admin.proxyType(address(_proxy));\n\n        vm.prank(alice);\n        admin.changeProxyAdmin(_proxy, address(128));\n\n        // The proxy is no longer the admin and can\n        // no longer call the proxy interface except for\n        // the ResolvedDelegate type on which anybody can\n        // call the admin interface.\n        if (proxyType == ProxyAdmin.ProxyType.ERC1967) {\n            vm.expectRevert(\"Proxy: implementation not initialized\");\n            admin.getProxyAdmin(_proxy);\n        } else if (proxyType == ProxyAdmin.ProxyType.CHUGSPLASH) {\n            vm.expectRevert(\"L1ChugSplashProxy: implementation is not set yet\");\n            admin.getProxyAdmin(_proxy);\n        } else if (proxyType == ProxyAdmin.ProxyType.RESOLVED) {\n            // Just an empty block to show that all cases are covered\n        } else {\n            vm.expectRevert(\"ProxyAdmin: unknown proxy type\");\n        }\n\n        // Call the proxy contract directly to get the admin.\n        // Different proxy types have different interfaces.\n        vm.prank(address(128));\n        if (proxyType == ProxyAdmin.ProxyType.ERC1967) {\n            assertEq(Proxy(payable(_proxy)).admin(), address(128));\n        } else if (proxyType == ProxyAdmin.ProxyType.CHUGSPLASH) {\n            assertEq(\n                L1ChugSplashProxy(payable(_proxy)).getOwner(),\n                address(128)\n            );\n        } else if (proxyType == ProxyAdmin.ProxyType.RESOLVED) {\n            assertEq(\n                addressManager.owner(),\n                address(128)\n            );\n        } else {\n            assert(false);\n        }\n    }\n\n    function test_erc1967Upgrade() external {\n        upgrade(payable(proxy));\n    }\n\n    function test_chugsplashUpgrade() external {\n        upgrade(payable(chugsplash));\n    }\n\n    function test_delegateResolvedUpgrade() external {\n        upgrade(payable(resolved));\n    }\n\n    function upgrade(address payable _proxy) internal {\n        vm.prank(alice);\n        admin.upgrade(_proxy, address(implementation));\n\n        address impl = admin.getProxyImplementation(_proxy);\n        assertEq(impl, address(implementation));\n    }\n\n    function test_erc1967UpgradeAndCall() external {\n        upgradeAndCall(payable(proxy));\n    }\n\n    function test_chugsplashUpgradeAndCall() external {\n        upgradeAndCall(payable(chugsplash));\n    }\n\n    function test_delegateResolvedUpgradeAndCall() external {\n        upgradeAndCall(payable(resolved));\n    }\n\n    function upgradeAndCall(address payable _proxy) internal {\n        vm.prank(alice);\n        admin.upgradeAndCall(\n            _proxy,\n            address(implementation),\n            abi.encodeWithSelector(SimpleStorage.set.selector, 1, 1)\n        );\n\n        address impl = admin.getProxyImplementation(_proxy);\n        assertEq(impl, address(implementation));\n\n        uint256 got = SimpleStorage(address(_proxy)).get(1);\n        assertEq(got, 1);\n    }\n\n    function test_onlyOwner() external {\n        vm.expectRevert(\"UNAUTHORIZED\");\n        admin.changeProxyAdmin(payable(proxy), address(0));\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n        admin.upgrade(payable(proxy), address(implementation));\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n        admin.upgradeAndCall(payable(proxy), address(implementation), hex\"\");\n    }\n\n    function test_isUpgrading() external {\n        assertEq(false, admin.isUpgrading());\n\n        vm.prank(alice);\n        admin.setUpgrading(true);\n        assertEq(true, admin.isUpgrading());\n    }\n}\n"
    },
    "contracts/test/RLP.t.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\n/**\n * @title LibRLP\n * @notice Via https://github.com/Rari-Capital/solmate/issues/207.\n */\nlibrary LibRLP {\n    using Bytes32AddressLib for bytes32;\n\n    function computeAddress(address deployer, uint256 nonce) internal pure returns (address) {\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)             return keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))).fromLast20Bytes();\n        if (nonce <= 0x7f)             return keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))).fromLast20Bytes();\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= type(uint8).max)  return keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))).fromLast20Bytes();\n        if (nonce <= type(uint16).max) return keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))).fromLast20Bytes();\n        if (nonce <= type(uint24).max) return keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))).fromLast20Bytes();\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce))).fromLast20Bytes();\n    }\n}\n"
    },
    "contracts/test/RLPReader.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { RLPReader } from \"../libraries/rlp/RLPReader.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract RLPReader_Test is CommonTest {\n    function testReadBool() external {\n        assertEq(\n            RLPReader.readBool(hex\"01\"),\n            true\n        );\n\n        assertEq(\n            RLPReader.readBool(hex\"00\"),\n            false\n        );\n    }\n\n    function test_readBoolInvalidValue() external {\n        vm.expectRevert(\"RLPReader: invalid RLP boolean value, must be 0 or 1\");\n        RLPReader.readBool(hex\"02\");\n    }\n\n    function test_readBoolLargeInput() external {\n        vm.expectRevert(\"RLPReader: invalid RLP boolean value\");\n        RLPReader.readBool(hex\"0101\");\n    }\n\n    function test_readAddress() external {\n        assertEq(\n            RLPReader.readAddress(hex\"941212121212121212121212121212121212121212\"),\n            address(0x1212121212121212121212121212121212121212)\n        );\n    }\n\n    function test_readAddressSmall() external {\n        assertEq(\n            RLPReader.readAddress(hex\"12\"),\n            address(0)\n        );\n    }\n\n    function test_readAddressTooLarge() external {\n        vm.expectRevert(\"RLPReader: invalid RLP address value\");\n        RLPReader.readAddress(hex\"94121212121212121212121212121212121212121212121212\");\n    }\n\n    function test_readAddressTooShort() external {\n        vm.expectRevert(\"RLPReader: invalid RLP address value\");\n        RLPReader.readAddress(hex\"94121212121212121212121212\");\n    }\n\n    function test_readBytes_bytestring00() external {\n        assertEq(\n            RLPReader.readBytes(hex\"00\"),\n            hex\"00\"\n        );\n    }\n\n    function test_readBytes_bytestring01() external {\n        assertEq(\n            RLPReader.readBytes(hex\"01\"),\n            hex\"01\"\n        );\n    }\n\n    function test_readBytes_bytestring7f() external {\n        assertEq(\n            RLPReader.readBytes(hex\"7f\"),\n            hex\"7f\"\n        );\n    }\n\n    function test_readBytes_revertListItem() external {\n        vm.expectRevert(\"RLPReader: invalid RLP bytes value\");\n        RLPReader.readBytes(hex\"c7c0c1c0c3c0c1c0\");\n    }\n\n    function test_readBytes_invalidStringLength() external {\n        vm.expectRevert(\"RLPReader: invalid RLP long string length\");\n        RLPReader.readBytes(hex\"b9\");\n    }\n\n    function test_readBytes_invalidListLength() external {\n        vm.expectRevert(\"RLPReader: invalid RLP long list length\");\n        RLPReader.readBytes(hex\"ff\");\n    }\n\n    function test_readBytes32_revertOnList() external {\n        vm.expectRevert(\"RLPReader: invalid RLP bytes32 value\");\n        RLPReader.readBytes32(hex\"c7c0c1c0c3c0c1c0\");\n    }\n\n    function test_readBytes32_revertOnTooLong() external {\n        vm.expectRevert(\"RLPReader: invalid RLP bytes32 value\");\n        RLPReader.readBytes32(hex\"11110000000000000000000000000000000000000000000000000000000000000000\");\n    }\n\n    function test_readString_emptyString() external {\n        assertEq(\n            RLPReader.readString(hex\"80\"),\n            hex\"\"\n        );\n    }\n\n    function test_readString_shortString() external {\n        assertEq(\n            RLPReader.readString(hex\"83646f67\"),\n            \"dog\"\n        );\n    }\n\n    function test_readString_shortString2() external {\n        assertEq(\n            RLPReader.readString(hex\"b74c6f72656d20697073756d20646f6c6f722073697420616d65742c20636f6e7365637465747572206164697069736963696e6720656c69\"),\n            \"Lorem ipsum dolor sit amet, consectetur adipisicing eli\"\n        );\n    }\n\n    function test_readString_longString() external {\n        assertEq(\n            RLPReader.readString(hex\"b8384c6f72656d20697073756d20646f6c6f722073697420616d65742c20636f6e7365637465747572206164697069736963696e6720656c6974\"),\n            \"Lorem ipsum dolor sit amet, consectetur adipisicing elit\"\n        );\n    }\n\n    function test_readString_longString2() external {\n        assertEq(\n            RLPReader.readString(hex\"b904004c6f72656d20697073756d20646f6c6f722073697420616d65742c20636f6e73656374657475722061646970697363696e6720656c69742e20437572616269747572206d6175726973206d61676e612c20737573636970697420736564207665686963756c61206e6f6e2c20696163756c697320666175636962757320746f72746f722e2050726f696e20737573636970697420756c74726963696573206d616c6573756164612e204475697320746f72746f7220656c69742c2064696374756d2071756973207472697374697175652065752c20756c7472696365732061742072697375732e204d6f72626920612065737420696d70657264696574206d6920756c6c616d636f7270657220616c6971756574207375736369706974206e6563206c6f72656d2e2041656e65616e2071756973206c656f206d6f6c6c69732c2076756c70757461746520656c6974207661726975732c20636f6e73657175617420656e696d2e204e756c6c6120756c74726963657320747572706973206a7573746f2c20657420706f73756572652075726e6120636f6e7365637465747572206e65632e2050726f696e206e6f6e20636f6e76616c6c6973206d657475732e20446f6e65632074656d706f7220697073756d20696e206d617572697320636f6e67756520736f6c6c696369747564696e2e20566573746962756c756d20616e746520697073756d207072696d697320696e206661756369627573206f726369206c756374757320657420756c74726963657320706f737565726520637562696c69612043757261653b2053757370656e646973736520636f6e76616c6c69732073656d2076656c206d617373612066617563696275732c2065676574206c6163696e6961206c616375732074656d706f722e204e756c6c61207175697320756c747269636965732070757275732e2050726f696e20617563746f722072686f6e637573206e69626820636f6e64696d656e74756d206d6f6c6c69732e20416c697175616d20636f6e73657175617420656e696d206174206d65747573206c75637475732c206120656c656966656e6420707572757320656765737461732e20437572616269747572206174206e696268206d657475732e204e616d20626962656e64756d2c206e6571756520617420617563746f72207472697374697175652c206c6f72656d206c696265726f20616c697175657420617263752c206e6f6e20696e74657264756d2074656c6c7573206c65637475732073697420616d65742065726f732e20437261732072686f6e6375732c206d65747573206163206f726e617265206375727375732c20646f6c6f72206a7573746f20756c747269636573206d657475732c20617420756c6c616d636f7270657220766f6c7574706174\"),\n            \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur mauris magna, suscipit sed vehicula non, iaculis faucibus tortor. Proin suscipit ultricies malesuada. Duis tortor elit, dictum quis tristique eu, ultrices at risus. Morbi a est imperdiet mi ullamcorper aliquet suscipit nec lorem. Aenean quis leo mollis, vulputate elit varius, consequat enim. Nulla ultrices turpis justo, et posuere urna consectetur nec. Proin non convallis metus. Donec tempor ipsum in mauris congue sollicitudin. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Suspendisse convallis sem vel massa faucibus, eget lacinia lacus tempor. Nulla quis ultricies purus. Proin auctor rhoncus nibh condimentum mollis. Aliquam consequat enim at metus luctus, a eleifend purus egestas. Curabitur at nibh metus. Nam bibendum, neque at auctor tristique, lorem libero aliquet arcu, non interdum tellus lectus sit amet eros. Cras rhoncus, metus ac ornare cursus, dolor justo ultrices metus, at ullamcorper volutpat\"\n        );\n    }\n\n    function test_readUint256_zero() external {\n        assertEq(\n            RLPReader.readUint256(hex\"80\"),\n            0\n        );\n    }\n\n    function test_readUint256_smallInt() external {\n        assertEq(\n            RLPReader.readUint256(hex\"01\"),\n            1\n        );\n    }\n\n    function test_readUint256_smallInt2() external {\n        assertEq(\n            RLPReader.readUint256(hex\"10\"),\n            16\n        );\n    }\n\n    function test_readUint256_smallInt3() external {\n        assertEq(\n            RLPReader.readUint256(hex\"4f\"),\n            79\n        );\n    }\n\n    function test_readUint256_smallInt4() external {\n        assertEq(\n            RLPReader.readUint256(hex\"7f\"),\n            127\n        );\n    }\n\n    function test_readUint256_mediumInt1() external {\n        assertEq(\n            RLPReader.readUint256(hex\"8180\"),\n            128\n        );\n    }\n\n    function test_readUint256_mediumInt2() external {\n        assertEq(\n            RLPReader.readUint256(hex\"8203e8\"),\n            1000\n        );\n    }\n\n    function test_readUint256_mediumInt3() external {\n        assertEq(\n            RLPReader.readUint256(hex\"830186a0\"),\n            100000\n        );\n    }\n\n    function test_readList_empty() external {\n        RLPReader.RLPItem[] memory list = RLPReader.readList(hex\"c0\");\n        assertEq(list.length, 0);\n    }\n\n    function test_readList_stringList() external {\n        RLPReader.RLPItem[] memory list = RLPReader.readList(hex\"cc83646f6783676f6483636174\");\n        assertEq(list.length, 3);\n        assertEq(RLPReader.readString(list[0]), RLPReader.readString(hex\"83646f67\"));\n        assertEq(RLPReader.readString(list[1]), RLPReader.readString(hex\"83676f64\"));\n        assertEq(RLPReader.readString(list[2]), RLPReader.readString(hex\"83636174\"));\n    }\n\n    function test_readList_multiList() external {\n        RLPReader.RLPItem[] memory list = RLPReader.readList(hex\"c6827a77c10401\");\n        assertEq(list.length, 3);\n\n        assertEq(RLPReader.readRawBytes(list[0]), hex\"827a77\");\n        assertEq(RLPReader.readRawBytes(list[1]), hex\"c104\");\n        assertEq(RLPReader.readRawBytes(list[2]), hex\"01\");\n    }\n\n    function test_readList_shortListMax1() external {\n        RLPReader.RLPItem[] memory list = RLPReader.readList(hex\"f784617364668471776572847a78637684617364668471776572847a78637684617364668471776572847a78637684617364668471776572\");\n\n        assertEq(list.length, 11);\n        assertEq(RLPReader.readRawBytes(list[0]), hex\"8461736466\");\n        assertEq(RLPReader.readRawBytes(list[1]), hex\"8471776572\");\n        assertEq(RLPReader.readRawBytes(list[2]), hex\"847a786376\");\n        assertEq(RLPReader.readRawBytes(list[3]), hex\"8461736466\");\n        assertEq(RLPReader.readRawBytes(list[4]), hex\"8471776572\");\n        assertEq(RLPReader.readRawBytes(list[5]), hex\"847a786376\");\n        assertEq(RLPReader.readRawBytes(list[6]), hex\"8461736466\");\n        assertEq(RLPReader.readRawBytes(list[7]), hex\"8471776572\");\n        assertEq(RLPReader.readRawBytes(list[8]), hex\"847a786376\");\n        assertEq(RLPReader.readRawBytes(list[9]), hex\"8461736466\");\n        assertEq(RLPReader.readRawBytes(list[10]), hex\"8471776572\");\n    }\n\n    function test_readList_longList1() external {\n        RLPReader.RLPItem[] memory list = RLPReader.readList(hex\"f840cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376\");\n\n        assertEq(list.length, 4);\n        assertEq(RLPReader.readRawBytes(list[0]), hex\"cf84617364668471776572847a786376\");\n        assertEq(RLPReader.readRawBytes(list[1]), hex\"cf84617364668471776572847a786376\");\n        assertEq(RLPReader.readRawBytes(list[2]), hex\"cf84617364668471776572847a786376\");\n        assertEq(RLPReader.readRawBytes(list[3]), hex\"cf84617364668471776572847a786376\");\n    }\n\n    function test_readList_longList2() external {\n        RLPReader.RLPItem[] memory list = RLPReader.readList(hex\"f90200cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376\");\n        assertEq(list.length, 32);\n\n        for (uint256 i = 0; i < 32; i++) {\n            assertEq(RLPReader.readRawBytes(list[i]), hex\"cf84617364668471776572847a786376\");\n        }\n    }\n\n    function test_readList_listOfLists() external {\n        RLPReader.RLPItem[] memory list = RLPReader.readList(hex\"c4c2c0c0c0\");\n        assertEq(list.length, 2);\n        assertEq(RLPReader.readRawBytes(list[0]), hex\"c2c0c0\");\n        assertEq(RLPReader.readRawBytes(list[1]), hex\"c0\");\n    }\n\n    function test_readList_listOfLists2() external {\n        RLPReader.RLPItem[] memory list = RLPReader.readList(hex\"c7c0c1c0c3c0c1c0\");\n        assertEq(list.length, 3);\n\n        assertEq(RLPReader.readRawBytes(list[0]), hex\"c0\");\n        assertEq(RLPReader.readRawBytes(list[1]), hex\"c1c0\");\n        assertEq(RLPReader.readRawBytes(list[2]), hex\"c3c0c1c0\");\n    }\n\n    function test_readList_dictTest1() external {\n        RLPReader.RLPItem[] memory list = RLPReader.readList(hex\"ecca846b6579318476616c31ca846b6579328476616c32ca846b6579338476616c33ca846b6579348476616c34\");\n        assertEq(list.length, 4);\n\n        assertEq(RLPReader.readRawBytes(list[0]), hex\"ca846b6579318476616c31\");\n        assertEq(RLPReader.readRawBytes(list[1]), hex\"ca846b6579328476616c32\");\n        assertEq(RLPReader.readRawBytes(list[2]), hex\"ca846b6579338476616c33\");\n        assertEq(RLPReader.readRawBytes(list[3]), hex\"ca846b6579348476616c34\");\n    }\n\n    function test_readList_invalidShortList() external {\n        vm.expectRevert(\"RLPReader: invalid RLP short list\");\n        RLPReader.readList(hex\"efdebd\");\n    }\n\n    function test_readList_longStringLength() external {\n        vm.expectRevert(\"RLPReader: invalid RLP short list\");\n        RLPReader.readList(hex\"efb83600\");\n    }\n\n    function test_readList_notLongEnough() external {\n        vm.expectRevert(\"RLPReader: invalid RLP short list\");\n        RLPReader.readList(hex\"efdebdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\");\n    }\n\n    function test_readList_int32Overflow() external {\n        vm.expectRevert(\"RLPReader: invalid RLP long string\");\n        RLPReader.readList(hex\"bf0f000000000000021111\");\n    }\n\n    function test_readList_int32Overflow2() external {\n        vm.expectRevert(\"RLPReader: invalid RLP long list\");\n        RLPReader.readList(hex\"ff0f000000000000021111\");\n    }\n\n    function test_readList_incorrectLengthInArray() external {\n        vm.expectRevert(\"RLPReader: invalid RLP list value\");\n        RLPReader.readList(hex\"b9002100dc2b275d0f74e8a53e6f4ec61b27f24278820be3f82ea2110e582081b0565df0\");\n    }\n\n    function test_readList_leadingZerosInLongLengthArray1() external {\n        vm.expectRevert(\"RLPReader: invalid RLP list value\");\n        RLPReader.readList(hex\"b90040000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\");\n    }\n\n    function test_readList_leadingZerosInLongLengthArray2() external {\n        vm.expectRevert(\"RLPReader: invalid RLP list value\");\n        RLPReader.readList(hex\"b800\");\n    }\n\n    function test_readList_leadingZerosInLongLengthList1() external {\n        vm.expectRevert(\"RLPReader: provided RLP list exceeds max list length\");\n        RLPReader.readList(hex\"fb00000040000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\");\n    }\n\n    function test_readList_nonOptimalLongLengthArray1() external {\n        vm.expectRevert(\"RLPReader: invalid RLP list value\");\n        RLPReader.readList(hex\"b81000112233445566778899aabbccddeeff\");\n    }\n\n    function test_readList_nonOptimalLongLengthArray2() external {\n        vm.expectRevert(\"RLPReader: invalid RLP list value\");\n        RLPReader.readList(hex\"b801ff\");\n    }\n\n    function test_readList_invalidValue() external {\n        vm.expectRevert(\"RLPReader: invalid RLP short string\");\n        RLPReader.readList(hex\"91\");\n    }\n}\n"
    },
    "contracts/test/RLPWriter.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { RLPWriter } from \"../libraries/rlp/RLPWriter.sol\";\nimport { CommonTest } from \"./CommonTest.t.sol\";\n\ncontract RLPWriter_Test is CommonTest {\n    function test_writeString_empty() external {\n        assertEq(\n            RLPWriter.writeString(\"\"),\n            hex\"80\"\n        );\n    }\n\n    function test_writeString_bytestring00() external {\n        assertEq(\n            RLPWriter.writeString(\"\\u0000\"),\n            hex\"00\"\n        );\n    }\n\n    function test_writeString_bytestring01() external {\n        assertEq(\n            RLPWriter.writeString(\"\\u0001\"),\n            hex\"01\"\n        );\n    }\n\n    function test_writeString_bytestring7f() external {\n        assertEq(\n            RLPWriter.writeString(\"\\u007F\"),\n            hex\"7f\"\n        );\n    }\n\n    function test_writeString_shortstring() external {\n        assertEq(\n            RLPWriter.writeString(\"dog\"),\n            hex\"83646f67\"\n        );\n    }\n\n    function test_writeString_shortstring2() external {\n        assertEq(\n            RLPWriter.writeString(\"Lorem ipsum dolor sit amet, consectetur adipisicing eli\"),\n            hex\"b74c6f72656d20697073756d20646f6c6f722073697420616d65742c20636f6e7365637465747572206164697069736963696e6720656c69\"\n        );\n    }\n\n    function test_writeString_longstring() external {\n        assertEq(\n            RLPWriter.writeString(\"Lorem ipsum dolor sit amet, consectetur adipisicing elit\"),\n            hex\"b8384c6f72656d20697073756d20646f6c6f722073697420616d65742c20636f6e7365637465747572206164697069736963696e6720656c6974\"\n        );\n    }\n\n    function test_writeString_longstring2() external {\n        assertEq(\n            RLPWriter.writeString(\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur mauris magna, suscipit sed vehicula non, iaculis faucibus tortor. Proin suscipit ultricies malesuada. Duis tortor elit, dictum quis tristique eu, ultrices at risus. Morbi a est imperdiet mi ullamcorper aliquet suscipit nec lorem. Aenean quis leo mollis, vulputate elit varius, consequat enim. Nulla ultrices turpis justo, et posuere urna consectetur nec. Proin non convallis metus. Donec tempor ipsum in mauris congue sollicitudin. Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia Curae; Suspendisse convallis sem vel massa faucibus, eget lacinia lacus tempor. Nulla quis ultricies purus. Proin auctor rhoncus nibh condimentum mollis. Aliquam consequat enim at metus luctus, a eleifend purus egestas. Curabitur at nibh metus. Nam bibendum, neque at auctor tristique, lorem libero aliquet arcu, non interdum tellus lectus sit amet eros. Cras rhoncus, metus ac ornare cursus, dolor justo ultrices metus, at ullamcorper volutpat\"),\n            hex\"b904004c6f72656d20697073756d20646f6c6f722073697420616d65742c20636f6e73656374657475722061646970697363696e6720656c69742e20437572616269747572206d6175726973206d61676e612c20737573636970697420736564207665686963756c61206e6f6e2c20696163756c697320666175636962757320746f72746f722e2050726f696e20737573636970697420756c74726963696573206d616c6573756164612e204475697320746f72746f7220656c69742c2064696374756d2071756973207472697374697175652065752c20756c7472696365732061742072697375732e204d6f72626920612065737420696d70657264696574206d6920756c6c616d636f7270657220616c6971756574207375736369706974206e6563206c6f72656d2e2041656e65616e2071756973206c656f206d6f6c6c69732c2076756c70757461746520656c6974207661726975732c20636f6e73657175617420656e696d2e204e756c6c6120756c74726963657320747572706973206a7573746f2c20657420706f73756572652075726e6120636f6e7365637465747572206e65632e2050726f696e206e6f6e20636f6e76616c6c6973206d657475732e20446f6e65632074656d706f7220697073756d20696e206d617572697320636f6e67756520736f6c6c696369747564696e2e20566573746962756c756d20616e746520697073756d207072696d697320696e206661756369627573206f726369206c756374757320657420756c74726963657320706f737565726520637562696c69612043757261653b2053757370656e646973736520636f6e76616c6c69732073656d2076656c206d617373612066617563696275732c2065676574206c6163696e6961206c616375732074656d706f722e204e756c6c61207175697320756c747269636965732070757275732e2050726f696e20617563746f722072686f6e637573206e69626820636f6e64696d656e74756d206d6f6c6c69732e20416c697175616d20636f6e73657175617420656e696d206174206d65747573206c75637475732c206120656c656966656e6420707572757320656765737461732e20437572616269747572206174206e696268206d657475732e204e616d20626962656e64756d2c206e6571756520617420617563746f72207472697374697175652c206c6f72656d206c696265726f20616c697175657420617263752c206e6f6e20696e74657264756d2074656c6c7573206c65637475732073697420616d65742065726f732e20437261732072686f6e6375732c206d65747573206163206f726e617265206375727375732c20646f6c6f72206a7573746f20756c747269636573206d657475732c20617420756c6c616d636f7270657220766f6c7574706174\"\n        );\n    }\n\n    function test_writeUint_zero() external {\n        assertEq(\n            RLPWriter.writeUint(0x0),\n            hex\"80\"\n        );\n    }\n\n    function test_writeUint_smallint() external {\n        assertEq(\n            RLPWriter.writeUint(1),\n            hex\"01\"\n        );\n    }\n\n    function test_writeUint_smallint2() external {\n        assertEq(\n            RLPWriter.writeUint(16),\n            hex\"10\"\n        );\n    }\n\n    function test_writeUint_smallint3() external {\n        assertEq(\n            RLPWriter.writeUint(79),\n            hex\"4f\"\n        );\n    }\n\n    function test_writeUint_smallint4() external {\n        assertEq(\n            RLPWriter.writeUint(127),\n            hex\"7f\"\n        );\n    }\n\n    function test_writeUint_mediumint() external {\n        assertEq(\n            RLPWriter.writeUint(128),\n            hex\"8180\"\n        );\n    }\n\n    function test_writeUint_mediumint2() external {\n        assertEq(\n            RLPWriter.writeUint(1000),\n            hex\"8203e8\"\n        );\n    }\n\n    function test_writeUint_mediumint3() external {\n        assertEq(\n            RLPWriter.writeUint(100000),\n            hex\"830186a0\"\n        );\n    }\n\n    function test_writeList_empty() external {\n        assertEq(\n            RLPWriter.writeList(new bytes[](0)),\n            hex\"c0\"\n        );\n    }\n\n    function test_writeList_stringList() external {\n        bytes[] memory list = new bytes[](3);\n        list[0] = RLPWriter.writeString(\"dog\");\n        list[1] = RLPWriter.writeString(\"god\");\n        list[2] = RLPWriter.writeString(\"cat\");\n\n        assertEq(\n            RLPWriter.writeList(list),\n            hex\"cc83646f6783676f6483636174\"\n        );\n    }\n\n    function test_writeList_multiList() external {\n        bytes[] memory list = new bytes[](3);\n        bytes[] memory list2 = new bytes[](1);\n        list2[0] = RLPWriter.writeUint(4);\n\n        list[0] = RLPWriter.writeString(\"zw\");\n        list[1] = RLPWriter.writeList(list2);\n        list[2] = RLPWriter.writeUint(1);\n\n        assertEq(\n            RLPWriter.writeList(list),\n            hex\"c6827a77c10401\"\n        );\n    }\n\n    function test_writeList_shortListMax1() external {\n        bytes[] memory list = new bytes[](11);\n        list[0] = RLPWriter.writeString(\"asdf\");\n        list[1] = RLPWriter.writeString(\"qwer\");\n        list[2] = RLPWriter.writeString(\"zxcv\");\n        list[3] = RLPWriter.writeString(\"asdf\");\n        list[4] = RLPWriter.writeString(\"qwer\");\n        list[5] = RLPWriter.writeString(\"zxcv\");\n        list[6] = RLPWriter.writeString(\"asdf\");\n        list[7] = RLPWriter.writeString(\"qwer\");\n        list[8] = RLPWriter.writeString(\"zxcv\");\n        list[9] = RLPWriter.writeString(\"asdf\");\n        list[10] = RLPWriter.writeString(\"qwer\");\n\n        assertEq(\n            RLPWriter.writeList(list),\n            hex\"f784617364668471776572847a78637684617364668471776572847a78637684617364668471776572847a78637684617364668471776572\"\n        );\n    }\n\n    function test_writeList_longlist1() external {\n        bytes[] memory list = new bytes[](4);\n        bytes[] memory list2 = new bytes[](3);\n\n        list2[0] = RLPWriter.writeString(\"asdf\");\n        list2[1] = RLPWriter.writeString(\"qwer\");\n        list2[2] = RLPWriter.writeString(\"zxcv\");\n\n        list[0] = RLPWriter.writeList(list2);\n        list[1] = RLPWriter.writeList(list2);\n        list[2] = RLPWriter.writeList(list2);\n        list[3] = RLPWriter.writeList(list2);\n\n        assertEq(\n            RLPWriter.writeList(list),\n            hex\"f840cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376\"\n        );\n    }\n\n    function test_writeList_longlist2() external {\n        bytes[] memory list = new bytes[](32);\n        bytes[] memory list2 = new bytes[](3);\n\n        list2[0] = RLPWriter.writeString(\"asdf\");\n        list2[1] = RLPWriter.writeString(\"qwer\");\n        list2[2] = RLPWriter.writeString(\"zxcv\");\n\n        for (uint256 i = 0; i < 32; i++) {\n            list[i] = RLPWriter.writeList(list2);\n        }\n\n        assertEq(\n            RLPWriter.writeList(list),\n            hex\"f90200cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376cf84617364668471776572847a786376\"\n        );\n    }\n\n\n    function test_writeList_listoflists() external {\n        // [ [ [], [] ], [] ]\n        bytes[] memory list = new bytes[](2);\n        bytes[] memory list2 = new bytes[](2);\n\n        list2[0] = RLPWriter.writeList(new bytes[](0));\n        list2[1] = RLPWriter.writeList(new bytes[](0));\n\n        list[0] = RLPWriter.writeList(list2);\n        list[1] = RLPWriter.writeList(new bytes[](0));\n\n        assertEq(\n            RLPWriter.writeList(list),\n            hex\"c4c2c0c0c0\"\n        );\n    }\n\n    function test_writeList_listoflists2() external {\n        // [ [], [[]], [ [], [[]] ] ]\n        bytes[] memory list = new bytes[](3);\n        list[0] = RLPWriter.writeList(new bytes[](0));\n\n        bytes[] memory list2 = new bytes[](1);\n        list2[0] = RLPWriter.writeList(new bytes[](0));\n\n        list[1] = RLPWriter.writeList(list2);\n\n        bytes[] memory list3 = new bytes[](2);\n        list3[0] = RLPWriter.writeList(new bytes[](0));\n        list3[1] = RLPWriter.writeList(list2);\n\n        list[2] = RLPWriter.writeList(list3);\n\n        assertEq(\n            RLPWriter.writeList(list),\n            hex\"c7c0c1c0c3c0c1c0\"\n        );\n    }\n\n    function test_writeList_dictTest1() external {\n        bytes[] memory list = new bytes[](4);\n\n        bytes[] memory list1 = new bytes[](2);\n        list1[0] = RLPWriter.writeString(\"key1\");\n        list1[1] = RLPWriter.writeString(\"val1\");\n\n        bytes[] memory list2 = new bytes[](2);\n        list2[0] = RLPWriter.writeString(\"key2\");\n        list2[1] = RLPWriter.writeString(\"val2\");\n\n        bytes[] memory list3 = new bytes[](2);\n        list3[0] = RLPWriter.writeString(\"key3\");\n        list3[1] = RLPWriter.writeString(\"val3\");\n\n        bytes[] memory list4 = new bytes[](2);\n        list4[0] = RLPWriter.writeString(\"key4\");\n        list4[1] = RLPWriter.writeString(\"val4\");\n\n        list[0] = RLPWriter.writeList(list1);\n        list[1] = RLPWriter.writeList(list2);\n        list[2] = RLPWriter.writeList(list3);\n        list[3] = RLPWriter.writeList(list4);\n\n        assertEq(\n            RLPWriter.writeList(list),\n            hex\"ecca846b6579318476616c31ca846b6579328476616c32ca846b6579338476616c33ca846b6579348476616c34\"\n        );\n    }\n}\n"
    },
    "contracts/test/ResourceMetering.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\n\ncontract MeterUser is ResourceMetering {\n    constructor() {\n        initialize();\n    }\n\n    function initialize() public initializer {\n        __ResourceMetering_init();\n    }\n\n    function use(uint64 _amount) public metered(_amount) {}\n}\n\ncontract ResourceMetering_Test is CommonTest {\n    MeterUser internal meter;\n    uint64 initialBlockNum;\n\n    function setUp() external {\n        _setUp();\n        meter = new MeterUser();\n        initialBlockNum = uint64(block.number);\n    }\n\n    function test_initialResourceParams() external {\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, meter.INITIAL_BASE_FEE());\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum);\n    }\n\n    function test_updateParamsNoChange() external {\n        meter.use(0); // equivalent to just updating the base fee and block number\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n        meter.use(0);\n        (uint128 postBaseFee, uint64 postBoughtGas, uint64 postBlockNum) = meter.params();\n\n        assertEq(postBaseFee, prevBaseFee);\n        assertEq(postBoughtGas, prevBoughtGas);\n        assertEq(postBlockNum, prevBlockNum);\n    }\n\n    function test_updateOneEmptyBlock() external {\n        vm.roll(initialBlockNum + 1);\n        meter.use(0);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        // Base fee decreases by 12.5%\n        assertEq(prevBaseFee, 875000000);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum + 1);\n    }\n\n    function test_updateTwoEmptyBlocks() external {\n        vm.roll(initialBlockNum + 2);\n        meter.use(0);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 765624999);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum + 2);\n    }\n\n    function test_updateTenEmptyBlocks() external {\n        vm.roll(initialBlockNum + 10);\n        meter.use(0);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 263075576);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum + 10);\n    }\n\n    function test_updateNoGasDelta() external {\n        uint64 target = uint64(uint256(meter.TARGET_RESOURCE_LIMIT()));\n        meter.use(target);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 1000000000);\n        assertEq(prevBoughtGas, target);\n        assertEq(prevBlockNum, initialBlockNum);\n    }\n\n    function test_useMaxSucceeds() external {\n        uint64 target = uint64(uint256(meter.TARGET_RESOURCE_LIMIT()));\n        uint64 elasticity = uint64(uint256(meter.ELASTICITY_MULTIPLIER()));\n        meter.use(target * elasticity);\n\n        (, uint64 prevBoughtGas, ) = meter.params();\n        assertEq(prevBoughtGas, target * elasticity);\n\n        vm.roll(initialBlockNum + 1);\n        meter.use(0);\n        (uint128 postBaseFee,,) = meter.params();\n        // Base fee increases by 1/8 the difference\n        assertEq(postBaseFee, 1375000000);\n    }\n\n    function test_useMoreThanMaxReverts() external {\n        uint64 target = uint64(uint256(meter.TARGET_RESOURCE_LIMIT()));\n        uint64 elasticity = uint64(uint256(meter.ELASTICITY_MULTIPLIER()));\n        vm.expectRevert(\"ResourceMetering: cannot buy more gas than available gas limit\");\n        meter.use(target * elasticity + 1);\n    }\n}\n"
    },
    "contracts/test/SafeCall.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\n\ncontract SafeCall_Test is CommonTest {\n    function test_safeCall(\n        address from,\n        address to,\n        uint256 gas,\n        uint64 value,\n        bytes memory data\n    ) external {\n        vm.assume(from.balance == 0);\n        vm.assume(to.balance == 0);\n        // no precompiles\n        vm.assume(uint160(to) > 10);\n        // don't call the vm\n        vm.assume(to != address(vm));\n        vm.assume(from != address(vm));\n        // don't call the console\n        vm.assume(\n            to != address(0x000000000000000000636F6e736F6c652e6c6f67)\n        );\n        // don't call the create2 deployer\n        vm.assume(\n            to != address(0x4e59b44847b379578588920cA78FbF26c0B4956C)\n        );\n        // don't send funds to self\n        vm.assume(from != to);\n\n        assertEq(from.balance, 0, \"from balance is 0\");\n        vm.deal(from, value);\n        assertEq(from.balance, value, \"from balance not dealt\");\n\n        vm.expectCall(\n            to,\n            value,\n            data\n        );\n\n        vm.prank(from);\n        bool success = SafeCall.call(\n            to,\n            gas,\n            value,\n            data\n        );\n\n        assertEq(success, true, \"call not successful\");\n        assertEq(to.balance, value, \"to balance received\");\n        assertEq(from.balance, 0, \"from balance not drained\");\n    }\n}\n"
    },
    "contracts/test/Semver.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { Semver } from \"../universal/Semver.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\n\n/**\n * @notice Test the Semver contract that is used for semantic versioning\n *         of various contracts.\n */\ncontract Semver_Test is CommonTest {\n    /**\n     * @notice Global semver contract deployed in setUp. This is used in\n     *         the test cases.\n     */\n    Semver semver;\n\n    /**\n     * @notice Deploy a Semver contract\n     */\n    function setUp() external {\n        semver = new Semver(7, 8, 0);\n    }\n\n    /**\n     * @notice Test the version getter\n     */\n    function test_version() external {\n        assertEq(\n            semver.version(),\n            \"7.8.0\"\n        );\n    }\n\n    /**\n     * @notice Since the versions are all immutable, they should\n     *         be able to be accessed from behind a proxy without needing\n     *         to initialize the contract.\n     */\n    function test_behindProxy() external {\n        Proxy proxy = new Proxy(alice);\n        vm.prank(alice);\n        proxy.upgradeTo(address(semver));\n\n        assertEq(\n            Semver(address(proxy)).version(),\n            \"7.8.0\"\n        );\n    }\n}\n"
    },
    "contracts/test/SequencerFeeVault.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\n\nimport { SequencerFeeVault } from \"../L2/SequencerFeeVault.sol\";\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\nimport { Predeploys } from \"../libraries/Predeploys.sol\";\n\ncontract SequencerFeeVault_Test is Bridge_Initializer {\n    SequencerFeeVault vault =\n        SequencerFeeVault(payable(Predeploys.SEQUENCER_FEE_WALLET));\n    address constant recipient = address(256);\n\n    function setUp() public override {\n        super.setUp();\n\n        vm.etch(\n            Predeploys.SEQUENCER_FEE_WALLET,\n            address(new SequencerFeeVault()).code\n        );\n\n        vm.store(\n            Predeploys.SEQUENCER_FEE_WALLET,\n            bytes32(uint256(0)),\n            bytes32(uint256(uint160(recipient)))\n        );\n    }\n\n    function test_minWithdrawalAmount() external {\n        assertEq(\n            vault.MIN_WITHDRAWAL_AMOUNT(),\n            15 ether\n        );\n    }\n\n    function test_constructor() external {\n        assertEq(\n            vault.l1FeeWallet(),\n            recipient\n        );\n    }\n\n    function test_receive() external {\n        assertEq(\n            address(vault).balance,\n            0\n        );\n\n        vm.prank(alice);\n        (bool success,) = address(vault).call{ value: 100 }(hex\"\");\n\n        assertEq(success, true);\n        assertEq(\n            address(vault).balance,\n            100\n        );\n    }\n\n    function test_revertWithdraw() external {\n        assert(address(vault).balance < vault.MIN_WITHDRAWAL_AMOUNT());\n\n        vm.expectRevert(\n            \"SequencerFeeVault: withdrawal amount must be greater than minimum withdrawal amount\"\n        );\n        vault.withdraw();\n    }\n\n    function test_withdraw() external {\n        vm.deal(address(vault), vault.MIN_WITHDRAWAL_AMOUNT() + 1);\n\n        vm.expectCall(\n            Predeploys.L2_STANDARD_BRIDGE,\n            abi.encodeWithSelector(\n                L2StandardBridge.withdrawTo.selector,\n                Predeploys.LEGACY_ERC20_ETH,\n                vault.l1FeeWallet(),\n                address(vault).balance,\n                0,\n                bytes(\"\")\n            )\n        );\n\n        vault.withdraw();\n    }\n}\n"
    },
    "contracts/universal/CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    PausableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { Hashing } from \"../libraries/Hashing.sol\";\nimport { Encoding } from \"../libraries/Encoding.sol\";\n\n/**\n * @custom:legacy\n * @title CrossDomainMessengerLegacySpacer\n * @notice Contract only exists to add a spacer to the CrossDomainMessenger where the\n *         libAddressManager variable used to exist. Must be the first contract in the inheritance\n *         tree of the CrossDomainMessenger\n */\ncontract CrossDomainMessengerLegacySpacer {\n    /**\n     * @custom:legacy\n     * @custom:spacer libAddressManager\n     * @notice Spacer for backwards compatibility.\n     */\n    address internal spacer0;\n}\n\n/**\n * @title CrossDomainMessenger\n * @notice CrossDomainMessenger is a base contract that provides the core logic for the L1 and L2\n *         cross-chain messenger contracts. It's designed to be a universal interface that only\n *         needs to be extended slightly to provide low-level message passing functionality on each\n *         chain it's deployed on. Currently only designed for message passing between two paired\n *         chains and does not support one-to-many interactions.\n */\nabstract contract CrossDomainMessenger is\n    CrossDomainMessengerLegacySpacer,\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    /**\n     * @notice Current message version identifier.\n     */\n    uint16 public constant MESSAGE_VERSION = 1;\n\n    /**\n     * @notice Constant overhead added to the base gas for a message.\n     */\n    uint32 public constant MIN_GAS_CONSTANT_OVERHEAD = 200_000;\n\n    /**\n     * @notice Numerator for dynamic overhead added to the base gas for a message.\n     */\n    uint32 public constant MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR = 1016;\n\n    /**\n     * @notice Denominator for dynamic overhead added to the base gas for a message.\n     */\n    uint32 public constant MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR = 1000;\n\n    /**\n     * @notice Extra gas added to base gas for each byte of calldata in a message.\n     */\n    uint32 public constant MIN_GAS_CALLDATA_OVERHEAD = 16;\n\n    /**\n     * @notice Minimum amount of gas required to relay a message.\n     */\n    uint256 internal constant RELAY_GAS_REQUIRED = 45_000;\n\n    /**\n     * @notice Amount of gas held in reserve to guarantee that relay execution completes.\n     */\n    uint256 internal constant RELAY_GAS_BUFFER = RELAY_GAS_REQUIRED - 5000;\n\n    /**\n     * @notice Initial value for the xDomainMsgSender variable. We set this to a non-zero value\n     *         because performing an SSTORE on a non-zero value is significantly cheaper than on a\n     *         zero value.\n     */\n    address internal constant DEFAULT_XDOMAIN_SENDER = 0x000000000000000000000000000000000000dEaD;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer blockedMessages\n     * @notice Spacer for backwards compatibility.\n     */\n    uint256 internal spacer1;\n\n    /**\n     * @custom:legacy\n     * @custom:spacer relayedMessages\n     * @notice Spacer for backwards compatibility.\n     */\n    uint256 internal spacer2;\n\n    /**\n     * @notice Mapping of message hashes to boolean receipt values. Note that a message will only\n     *         be present in this mapping if it failed to be relayed on this chain at least once.\n     *         If a message is successfully relayed on the first attempt, then it will only be\n     *         present within the successfulMessages mapping.\n     */\n    mapping(bytes32 => bool) public successfulMessages;\n\n    /**\n     * @notice Address of the sender of the currently executing message on the other chain. If the\n     *         value of this variable is the default value (0x00000000...dead) then no message is\n     *         currently being executed. Use the xDomainMessageSender getter which will throw an\n     *         error if this is the case.\n     */\n    address internal xDomainMsgSender;\n\n    /**\n     * @notice Nonce for the next message to be sent, without the message version applied. Use the\n     *         messageNonce getter which will insert the message version into the nonce to give you\n     *         the actual nonce to be used for the message.\n     */\n    uint240 internal msgNonce;\n\n    /**\n     * @notice Address of the paired CrossDomainMessenger contract on the other chain.\n     */\n    address public otherMessenger;\n\n    /**\n     * @notice Mapping of message hashes to boolean receipt values. Note that a message will only\n     *         be present in this mapping if it failed to be relayed on this chain at least once.\n     *         If a message is successfully relayed on the first attempt, then it will only be\n     *         present within the successfulMessages mapping.\n     */\n    mapping(bytes32 => bool) public receivedMessages;\n\n    /**\n     * @notice Mapping of blocked system addresses. Note that this is NOT a mapping of blocked user\n     *         addresses and cannot be used to prevent users from sending or receiving messages.\n     *         This is ONLY used to prevent the execution of messages to specific system addresses\n     *         that could cause security issues, e.g., having the CrossDomainMessenger send\n     *         messages to itself.\n     */\n    mapping(address => bool) public blockedSystemAddresses;\n\n    /**\n     * @notice Emitted whenever a message is sent to the other chain.\n     *\n     * @param target       Address of the recipient of the message.\n     * @param sender       Address of the sender of the message.\n     * @param message      Message to trigger the recipient address with.\n     * @param messageNonce Unique nonce attached to the message.\n     * @param gasLimit     Minimum gas limit that the message can be executed with.\n     */\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n\n    /**\n     * @notice Additional event data to emit, required as of Bedrock. Cannot be merged with the\n     *         SentMessage event without breaking the ABI of this contract, this is good enough.\n     *\n     * @param sender Address of the sender of the message.\n     * @param value  ETH value sent along with the message to the recipient.\n     */\n    event SentMessageExtension1(address indexed sender, uint256 value);\n\n    /**\n     * @notice Emitted whenever a message is successfully relayed on this chain.\n     *\n     * @param msgHash Hash of the message that was relayed.\n     */\n    event RelayedMessage(bytes32 indexed msgHash);\n\n    /**\n     * @notice Emitted whenever a message fails to be relayed on this chain.\n     *\n     * @param msgHash Hash of the message that failed to be relayed.\n     */\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /**\n     * @notice Allows the owner of this contract to temporarily pause message relaying. Backup\n     *         security mechanism just in case. Owner should be the same as the upgrade wallet to\n     *         maintain the security model of the system as a whole.\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Allows the owner of this contract to resume message relaying once paused.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice Sends a message to some target address on the other chain.\n     *\n     * @param _target      Target contract or wallet address.\n     * @param _message     Message to trigger the target address with.\n     * @param _minGasLimit Minimum gas limit that the message can be executed with.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _minGasLimit\n    ) external payable {\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\n        // guarantee the property that the call to the target contract will always have at least\n        // the minimum gas limit specified by the user.\n        _sendMessage(\n            otherMessenger,\n            baseGas(_message, _minGasLimit),\n            msg.value,\n            abi.encodeWithSelector(\n                this.relayMessage.selector,\n                messageNonce(),\n                msg.sender,\n                _target,\n                msg.value,\n                _minGasLimit,\n                _message\n            )\n        );\n\n        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);\n        emit SentMessageExtension1(msg.sender, msg.value);\n\n        unchecked {\n            ++msgNonce;\n        }\n    }\n\n    /**\n     * @notice Relays a message that was sent by the other CrossDomainMessenger contract. Can only\n     *         be executed via cross-chain call from the other messenger OR if the message was\n     *         already received once and is currently being replayed.\n     *\n     * @param _nonce       Nonce of the message being relayed.\n     * @param _sender      Address of the user who sent the message.\n     * @param _target      Address that the message is targeted at.\n     * @param _value       ETH value to send with the message.\n     * @param _minGasLimit Minimum amount of gas that the message can be executed with.\n     * @param _message     Message to send to the target.\n     */\n    function relayMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _minGasLimit,\n        bytes calldata _message\n    ) external payable nonReentrant whenNotPaused {\n        bytes32 versionedHash = Hashing.hashCrossDomainMessage(\n            _nonce,\n            _sender,\n            _target,\n            _value,\n            _minGasLimit,\n            _message\n        );\n\n        if (_isOtherMessenger()) {\n            // Should never happen.\n            require(msg.value == _value, \"CrossDomainMessenger: mismatched message value\");\n        } else {\n            require(\n                msg.value == 0,\n                \"CrossDomainMessenger: value must be zero unless message is from a system address\"\n            );\n\n            require(\n                receivedMessages[versionedHash],\n                \"CrossDomainMessenger: message cannot be replayed\"\n            );\n        }\n\n        require(\n            blockedSystemAddresses[_target] == false,\n            \"CrossDomainMessenger: cannot send message to blocked system address\"\n        );\n\n        require(\n            successfulMessages[versionedHash] == false,\n            \"CrossDomainMessenger: message has already been relayed\"\n        );\n\n        require(\n            gasleft() >= _minGasLimit + RELAY_GAS_REQUIRED,\n            \"CrossDomainMessenger: insufficient gas to relay message\"\n        );\n\n        xDomainMsgSender = _sender;\n        bool success = SafeCall.call(_target, gasleft() - RELAY_GAS_BUFFER, _value, _message);\n        xDomainMsgSender = DEFAULT_XDOMAIN_SENDER;\n\n        if (success == true) {\n            successfulMessages[versionedHash] = true;\n            emit RelayedMessage(versionedHash);\n        } else {\n            receivedMessages[versionedHash] = true;\n            emit FailedRelayedMessage(versionedHash);\n        }\n    }\n\n    /**\n     * @notice Retrieves the address of the contract or wallet that initiated the currently\n     *         executing message on the other chain. Will throw an error if there is no message\n     *         currently being executed. Allows the recipient of a call to see who triggered it.\n     *\n     * @return Address of the sender of the currently executing message on the other chain.\n     */\n    function xDomainMessageSender() external view returns (address) {\n        require(\n            xDomainMsgSender != DEFAULT_XDOMAIN_SENDER,\n            \"CrossDomainMessenger: xDomainMessageSender is not set\"\n        );\n\n        return xDomainMsgSender;\n    }\n\n    /**\n     * @notice Retrieves the next message nonce. Message version will be added to the upper two\n     *         bytes of the message nonce. Message version allows us to treat messages as having\n     *         different structures.\n     *\n     * @return Nonce of the next message to be sent, with added message version.\n     */\n    function messageNonce() public view returns (uint256) {\n        return Encoding.encodeVersionedNonce(msgNonce, MESSAGE_VERSION);\n    }\n\n    /**\n     * @notice Computes the amount of gas required to guarantee that a given message will be\n     *         received on the other chain without running out of gas. Guaranteeing that a message\n     *         will not run out of gas is important because this ensures that a message can always\n     *         be replayed on the other chain if it fails to execute completely.\n     *\n     * @param _message     Message to compute the amount of required gas for.\n     * @param _minGasLimit Minimum desired gas limit when message goes to target.\n     *\n     * @return Amount of gas required to guarantee message receipt.\n     */\n    function baseGas(bytes calldata _message, uint32 _minGasLimit) public pure returns (uint32) {\n        return\n            // Dynamic overhead\n            ((_minGasLimit * MIN_GAS_DYNAMIC_OVERHEAD_NUMERATOR) /\n                MIN_GAS_DYNAMIC_OVERHEAD_DENOMINATOR) +\n            // Calldata overhead\n            (uint32(_message.length) * MIN_GAS_CALLDATA_OVERHEAD) +\n            // Constant overhead\n            MIN_GAS_CONSTANT_OVERHEAD;\n    }\n\n    /**\n     * @notice Intializer.\n     *\n     * @param _otherMessenger         Address of the CrossDomainMessenger on the paired chain.\n     * @param _blockedSystemAddresses List of system addresses that need to be blocked to prevent\n     *                                certain security issues. Exact list depends on the network\n     *                                where this contract is deployed. See note attached to the\n     *                                blockedSystemAddresses variable in this contract for more\n     *                                detailed information about what this block list can and\n     *                                cannot be used for.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __CrossDomainMessenger_init(\n        address _otherMessenger,\n        address[] memory _blockedSystemAddresses\n    ) internal onlyInitializing {\n        xDomainMsgSender = DEFAULT_XDOMAIN_SENDER;\n        otherMessenger = _otherMessenger;\n        for (uint256 i = 0; i < _blockedSystemAddresses.length; i++) {\n            blockedSystemAddresses[_blockedSystemAddresses[i]] = true;\n        }\n\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __Pausable_init_unchained();\n        __ReentrancyGuard_init_unchained();\n    }\n\n    /**\n     * @notice Sends a low-level message to the other messenger. Needs to be implemented by child\n     *         contracts because the logic for this depends on the network where the messenger is\n     *         being deployed.\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal virtual;\n\n    /**\n     * @notice Checks whether the message is coming from the other messenger. Implemented by child\n     *         contracts because the logic for this depends on the network where the messenger is\n     *         being deployed.\n     */\n    function _isOtherMessenger() internal view virtual returns (bool);\n}\n"
    },
    "contracts/universal/OptimismMintableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./SupportedInterfaces.sol\";\n\n/**\n * @title OptimismMintableERC20\n * @notice OptimismMintableERC20 is a standard extension of the base ERC20 token contract designed\n *         to allow the StandardBridge contracts to mint and burn tokens. This makes it possible to\n *         use an OptimismMintablERC20 as the L2 representation of an L1 token, or vice-versa.\n *         Designed to be backwards compatible with the older StandardL2ERC20 token which was only\n *         meant for use on L2.\n */\ncontract OptimismMintableERC20 is ERC20 {\n    /**\n     * @notice Address of the corresponding version of this token on the remote chain.\n     */\n    address public remoteToken;\n\n    /**\n     * @notice Address of the StandardBridge on this network.\n     */\n    address public bridge;\n\n    /**\n     * @notice Emitted whenever tokens are minted for an account.\n     *\n     * @param account Address of the account tokens are being minted for.\n     * @param amount  Amount of tokens minted.\n     */\n    event Mint(address indexed account, uint256 amount);\n\n    /**\n     * @notice Emitted whenever tokens are burned from an account.\n     *\n     * @param account Address of the account tokens are being burned from.\n     * @param amount  Amount of tokens burned.\n     */\n    event Burn(address indexed account, uint256 amount);\n\n    /**\n     * @notice A modifier that only allows the bridge to call\n     */\n    modifier onlyBridge() {\n        require(msg.sender == bridge, \"OptimismMintableERC20: only bridge can mint and burn\");\n        _;\n    }\n\n    /**\n     * @param _bridge      Address of the L2 standard bridge.\n     * @param _remoteToken Address of the corresponding L1 token.\n     * @param _name        ERC20 name.\n     * @param _symbol      ERC20 symbol.\n     */\n    constructor(\n        address _bridge,\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) {\n        remoteToken = _remoteToken;\n        bridge = _bridge;\n    }\n\n    /**\n     * @notice Allows the StandardBridge on this network to mint tokens.\n     *\n     * @param _to     Address to mint tokens to.\n     * @param _amount Amount of tokens to mint.\n     */\n    function mint(address _to, uint256 _amount) external virtual onlyBridge {\n        _mint(_to, _amount);\n        emit Mint(_to, _amount);\n    }\n\n    /**\n     * @notice Allows the StandardBridge on this network to burn tokens.\n     *\n     * @param _from   Address to burn tokens from.\n     * @param _amount Amount of tokens to burn.\n     */\n    function burn(address _from, uint256 _amount) external virtual onlyBridge {\n        _burn(_from, _amount);\n        emit Burn(_from, _amount);\n    }\n\n    /**\n     * @notice ERC165 interface check function.\n     *\n     * @param _interfaceId Interface ID to check.\n     *\n     * @return Whether or not the interface is supported by this contract.\n     */\n    function supportsInterface(bytes4 _interfaceId) external pure returns (bool) {\n        bytes4 iface1 = type(IERC165).interfaceId;\n        bytes4 iface2 = type(IL1Token).interfaceId;\n        bytes4 iface3 = type(IRemoteToken).interfaceId;\n        return _interfaceId == iface1 || _interfaceId == iface2 || _interfaceId == iface3;\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Legacy getter for the remote token. Use remoteToken going forward.\n     */\n    function l1Token() public view returns (address) {\n        return remoteToken;\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Legacy getter for the bridge. Use bridge going forward.\n     */\n    function l2Bridge() public view returns (address) {\n        return bridge;\n    }\n}\n"
    },
    "contracts/universal/OptimismMintableERC20Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/* Contract Imports */\nimport { OptimismMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeployed 0x4200000000000000000000000000000000000012\n * @title OptimismMintableERC20Factory\n * @notice OptimismMintableERC20Factory is a factory contract that generates OptimismMintableERC20\n *         contracts on the network it's deployed to. Simplifies the deployment process for users\n *         who may be less familiar with deploying smart contracts. Designed to be backwards\n *         compatible with the older StandardL2ERC20Factory contract.\n */\ncontract OptimismMintableERC20Factory {\n    /**\n     * @notice Address of the StandardBridge on this chain.\n     */\n    address public immutable bridge;\n\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever a new OptimismMintableERC20 is created. Legacy version of the newer\n     *         OptimismMintableERC20Created event. We recommend relying on that event instead.\n     *\n     * @param remoteToken Address of the token on the remote chain.\n     * @param localToken  Address of the created token on the local chain.\n     */\n    event StandardL2TokenCreated(address indexed remoteToken, address indexed localToken);\n\n    /**\n     * @notice Emitted whenever a new OptimismMintableERC20 is created.\n     *\n     * @param localToken  Address of the created token on the local chain.\n     * @param remoteToken Address of the corresponding token on the remote chain.\n     * @param deployer    Address of the account that deployed the token.\n     */\n    event OptimismMintableERC20Created(\n        address indexed localToken,\n        address indexed remoteToken,\n        address deployer\n    );\n\n    /**\n     * @param _bridge Address of the StandardBridge on this chain.\n     */\n    constructor(address _bridge) {\n        bridge = _bridge;\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Creates an instance of the OptimismMintableERC20 contract. Legacy version of the\n     *         newer createOptimismMintableERC20 function, which has a more intuitive name.\n     *\n     * @param _remoteToken Address of the token on the remote chain.\n     * @param _name        ERC20 name.\n     * @param _symbol      ERC20 symbol.\n     *\n     * @return Address of the newly created token.\n     */\n    function createStandardL2Token(\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) external returns (address) {\n        return createOptimismMintableERC20(_remoteToken, _name, _symbol);\n    }\n\n    /**\n     * @notice Creates an instance of the OptimismMintableERC20 contract.\n     *\n     * @param _remoteToken Address of the token on the remote chain.\n     * @param _name        ERC20 name.\n     * @param _symbol      ERC20 symbol.\n     *\n     * @return Address of the newly created token.\n     */\n    function createOptimismMintableERC20(\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) public returns (address) {\n        require(\n            _remoteToken != address(0),\n            \"OptimismMintableERC20Factory: must provide remote token address\"\n        );\n\n        OptimismMintableERC20 localToken = new OptimismMintableERC20(\n            bridge,\n            _remoteToken,\n            _name,\n            _symbol\n        );\n\n        // Emit the old event too for legacy support.\n        emit StandardL2TokenCreated(_remoteToken, address(localToken));\n        emit OptimismMintableERC20Created(_remoteToken, address(localToken), msg.sender);\n\n        return address(localToken);\n    }\n}\n"
    },
    "contracts/universal/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\n/**\n * @title Proxy\n * @notice Proxy is a transparent proxy that passes through the call if the caller is the owner or\n *         if the caller is address(0), meaning that the call originated from an off-chain\n *         simulation.\n */\ncontract Proxy {\n    /**\n     * @notice The storage slot that holds the address of the implementation.\n     *         bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n     */\n    bytes32 internal constant IMPLEMENTATION_KEY =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @notice The storage slot that holds the address of the owner.\n     *         bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\n     */\n    bytes32 internal constant OWNER_KEY =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @notice An event that is emitted each time the implementation is changed. This event is part\n     *         of the EIP-1967 specification.\n     *\n     * @param implementation The address of the implementation contract\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @notice An event that is emitted each time the owner is upgraded. This event is part of the\n     *         EIP-1967 specification.\n     *\n     * @param previousAdmin The previous owner of the contract\n     * @param newAdmin      The new owner of the contract\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @notice A modifier that reverts if not called by the owner or by address(0) to allow\n     *         eth_call to interact with this proxy without needing to use low-level storage\n     *         inspection. We assume that nobody is able to trigger calls from address(0) during\n     *         normal EVM execution.\n     */\n    modifier proxyCallIfNotAdmin() {\n        if (msg.sender == _getAdmin() || msg.sender == address(0)) {\n            _;\n        } else {\n            // This WILL halt the call frame on completion.\n            _doProxyCall();\n        }\n    }\n\n    /**\n     * @notice Sets the initial admin during contract deployment. Admin address is stored at the\n     *         EIP-1967 admin storage slot so that accidental storage collision with the\n     *         implementation is not possible.\n     *\n     * @param _admin Address of the initial contract admin. Admin as the ability to access the\n     *               transparent proxy interface.\n     */\n    constructor(address _admin) {\n        _changeAdmin(_admin);\n    }\n\n    // slither-disable-next-line locked-ether\n    receive() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    // slither-disable-next-line locked-ether\n    fallback() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    /**\n     * @notice Set the implementation contract address. The code at the given address will execute\n     *         when this contract is called.\n     *\n     * @param _implementation Address of the implementation contract.\n     */\n    function upgradeTo(address _implementation) external proxyCallIfNotAdmin {\n        _setImplementation(_implementation);\n    }\n\n    /**\n     * @notice Set the implementation and call a function in a single transaction. Useful to ensure\n     *         atomic execution of initialization-based upgrades.\n     *\n     * @param _implementation Address of the implementation contract.\n     * @param _data           Calldata to delegatecall the new implementation with.\n     */\n    function upgradeToAndCall(address _implementation, bytes calldata _data)\n        external\n        payable\n        proxyCallIfNotAdmin\n        returns (bytes memory)\n    {\n        _setImplementation(_implementation);\n        (bool success, bytes memory returndata) = _implementation.delegatecall(_data);\n        require(success, \"Proxy: delegatecall to new implementation contract failed\");\n        return returndata;\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract. Only callable by the owner.\n     *\n     * @param _admin New owner of the proxy contract.\n     */\n    function changeAdmin(address _admin) external proxyCallIfNotAdmin {\n        _changeAdmin(_admin);\n    }\n\n    /**\n     * @notice Gets the owner of the proxy contract.\n     *\n     * @return Owner address.\n     */\n    function admin() external proxyCallIfNotAdmin returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @notice Queries the implementation address.\n     *\n     * @return Implementation address.\n     */\n    function implementation() external proxyCallIfNotAdmin returns (address) {\n        return _getImplementation();\n    }\n\n    /**\n     * @notice Sets the implementation address.\n     *\n     * @param _implementation New implementation address.\n     */\n    function _setImplementation(address _implementation) internal {\n        assembly {\n            sstore(IMPLEMENTATION_KEY, _implementation)\n        }\n        emit Upgraded(_implementation);\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract.\n     *\n     * @param _admin New owner of the proxy contract.\n     */\n    function _changeAdmin(address _admin) internal {\n        address previous = _getAdmin();\n        assembly {\n            sstore(OWNER_KEY, _admin)\n        }\n        emit AdminChanged(previous, _admin);\n    }\n\n    /**\n     * @notice Performs the proxy call via a delegatecall.\n     */\n    function _doProxyCall() internal {\n        address impl = _getImplementation();\n        require(impl != address(0), \"Proxy: implementation not initialized\");\n\n        assembly {\n            // Copy calldata into memory at 0x0....calldatasize.\n            calldatacopy(0x0, 0x0, calldatasize())\n\n            // Perform the delegatecall, make sure to pass all available gas.\n            let success := delegatecall(gas(), impl, 0x0, calldatasize(), 0x0, 0x0)\n\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\n            // overwrite the calldata that we just copied into memory but that doesn't really\n            // matter because we'll be returning in a second anyway.\n            returndatacopy(0x0, 0x0, returndatasize())\n\n            // Success == 0 means a revert. We'll revert too and pass the data up.\n            if iszero(success) {\n                revert(0x0, returndatasize())\n            }\n\n            // Otherwise we'll just return and pass the data up.\n            return(0x0, returndatasize())\n        }\n    }\n\n    /**\n     * @notice Queries the implementation address.\n     *\n     * @return Implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        address impl;\n        assembly {\n            impl := sload(IMPLEMENTATION_KEY)\n        }\n        return impl;\n    }\n\n    /**\n     * @notice Queries the owner of the proxy contract.\n     *\n     * @return Owner address.\n     */\n    function _getAdmin() internal view returns (address) {\n        address owner;\n        assembly {\n            owner := sload(OWNER_KEY)\n        }\n        return owner;\n    }\n}\n"
    },
    "contracts/universal/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { Owned } from \"@rari-capital/solmate/src/auth/Owned.sol\";\nimport { Proxy } from \"./Proxy.sol\";\nimport { AddressManager } from \"../legacy/AddressManager.sol\";\nimport { L1ChugSplashProxy } from \"../legacy/L1ChugSplashProxy.sol\";\n\n/**\n * @title IStaticERC1967Proxy\n * @notice IStaticERC1967Proxy is a static version of the ERC1967 proxy interface.\n */\ninterface IStaticERC1967Proxy {\n    function implementation() external view returns (address);\n\n    function admin() external view returns (address);\n}\n\n/**\n * @title IStaticL1ChugSplashProxy\n * @notice IStaticL1ChugSplashProxy is a static version of the ChugSplash proxy interface.\n */\ninterface IStaticL1ChugSplashProxy {\n    function getImplementation() external view returns (address);\n\n    function getOwner() external view returns (address);\n}\n\n/**\n * @title ProxyAdmin\n * @notice This is an auxiliary contract meant to be assigned as the admin of an ERC1967 Proxy,\n *         based on the OpenZeppelin implementation. It has backwards compatibility logic to work\n *         with the various types of proxies that have been deployed by Optimism in the past.\n */\ncontract ProxyAdmin is Owned {\n    /**\n     * @notice The proxy types that the ProxyAdmin can manage.\n     *\n     * @custom:value ERC1967    Represents an ERC1967 compliant transparent proxy interface.\n     * @custom:value CHUGSPLASH Represents the Chugsplash proxy interface (legacy).\n     * @custom:value RESOLVED   Represents the ResolvedDelegate proxy (legacy).\n     */\n    enum ProxyType {\n        ERC1967,\n        CHUGSPLASH,\n        RESOLVED\n    }\n\n    /**\n     * @custom:legacy\n     * @notice A mapping of proxy types, used for backwards compatibility.\n     */\n    mapping(address => ProxyType) public proxyType;\n\n    /**\n     * @custom:legacy\n     * @notice A reverse mapping of addresses to names held in the AddressManager. This must be\n     *         manually kept up to date with changes in the AddressManager for this contract\n     *         to be able to work as an admin for the ResolvedDelegateProxy type.\n     */\n    mapping(address => string) public implementationName;\n\n    /**\n     * @custom:legacy\n     * @notice The address of the address manager, this is required to manage the\n     *         ResolvedDelegateProxy type.\n     */\n    AddressManager public addressManager;\n\n    /**\n     * @custom:legacy\n     * @notice A legacy upgrading indicator used by the old Chugsplash Proxy.\n     */\n    bool internal upgrading = false;\n\n    /**\n     * @param _owner Address of the initial owner of this contract.\n     */\n    constructor(address _owner) Owned(_owner) {}\n\n    /**\n     * @notice Sets the proxy type for a given address. Only required for non-standard (legacy)\n     *         proxy types.\n     *\n     * @param _address Address of the proxy.\n     * @param _type    Type of the proxy.\n     */\n    function setProxyType(address _address, ProxyType _type) external onlyOwner {\n        proxyType[_address] = _type;\n    }\n\n    /**\n     * @notice Sets the implementation name for a given address. Only required for\n     *         ResolvedDelegateProxy type proxies that have an implementation name.\n     *\n     * @param _address Address of the ResolvedDelegateProxy.\n     * @param _name    Name of the implementation for the proxy.\n     */\n    function setImplementationName(address _address, string memory _name) external onlyOwner {\n        implementationName[_address] = _name;\n    }\n\n    /**\n     * @notice Set the address of the AddressManager. This is required to manage legacy\n     *         ResolvedDelegateProxy type proxy contracts.\n     *\n     * @param _address Address of the AddressManager.\n     */\n    function setAddressManager(AddressManager _address) external onlyOwner {\n        addressManager = _address;\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Set an address in the address manager. Since only the owner of the AddressManager\n     *         can directly modify addresses and the ProxyAdmin will own the AddressManager, this\n     *         gives the owner of the ProxyAdmin the ability to modify addresses directly.\n     *\n     * @param _name    Name to set within the AddressManager.\n     * @param _address Address to attach to the given name.\n     */\n    function setAddress(string memory _name, address _address) external onlyOwner {\n        addressManager.setAddress(_name, _address);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Set the upgrading status for the Chugsplash proxy type.\n     *\n     * @param _upgrading Whether or not the system is upgrading.\n     */\n    function setUpgrading(bool _upgrading) external onlyOwner {\n        upgrading = _upgrading;\n    }\n\n    /**\n     * @notice Updates the admin of the given proxy address.\n     *\n     * @param _proxy    Address of the proxy to update.\n     * @param _newAdmin Address of the new proxy admin.\n     */\n    function changeProxyAdmin(address payable _proxy, address _newAdmin) external onlyOwner {\n        ProxyType ptype = proxyType[_proxy];\n        if (ptype == ProxyType.ERC1967) {\n            Proxy(_proxy).changeAdmin(_newAdmin);\n        } else if (ptype == ProxyType.CHUGSPLASH) {\n            L1ChugSplashProxy(_proxy).setOwner(_newAdmin);\n        } else if (ptype == ProxyType.RESOLVED) {\n            addressManager.transferOwnership(_newAdmin);\n        } else {\n            revert(\"ProxyAdmin: unknown proxy type\");\n        }\n    }\n\n    /**\n     * @notice Changes a proxy's implementation contract and delegatecalls the new implementation\n     *         with some given data. Useful for atomic upgrade-and-initialize calls.\n     *\n     * @param _proxy          Address of the proxy to upgrade.\n     * @param _implementation Address of the new implementation address.\n     * @param _data           Data to trigger the new implementation with.\n     */\n    function upgradeAndCall(\n        address payable _proxy,\n        address _implementation,\n        bytes memory _data\n    ) external payable onlyOwner {\n        ProxyType ptype = proxyType[_proxy];\n        if (ptype == ProxyType.ERC1967) {\n            Proxy(_proxy).upgradeToAndCall{ value: msg.value }(_implementation, _data);\n        } else {\n            // reverts if proxy type is unknown\n            upgrade(_proxy, _implementation);\n            (bool success, ) = _proxy.call{ value: msg.value }(_data);\n            require(success, \"ProxyAdmin: call to proxy after upgrade failed\");\n        }\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Legacy function used to tell ChugSplashProxy contracts if an upgrade is happening.\n     *\n     * @return Whether or not there is an upgrade going on. May not actually tell you whether an\n     *         upgrade is going on, since we don't currently plan to use this variable for anything\n     *         other than a legacy indicator to fix a UX bug in the ChugSplash proxy.\n     */\n    function isUpgrading() external view returns (bool) {\n        return upgrading;\n    }\n\n    /**\n     * @notice Returns the implementation of the given proxy address.\n     *\n     * @param _proxy Address of the proxy to get the implementation of.\n     *\n     * @return Address of the implementation of the proxy.\n     */\n    function getProxyImplementation(address _proxy) external view returns (address) {\n        ProxyType ptype = proxyType[_proxy];\n        if (ptype == ProxyType.ERC1967) {\n            return IStaticERC1967Proxy(_proxy).implementation();\n        } else if (ptype == ProxyType.CHUGSPLASH) {\n            return IStaticL1ChugSplashProxy(_proxy).getImplementation();\n        } else if (ptype == ProxyType.RESOLVED) {\n            return addressManager.getAddress(implementationName[_proxy]);\n        } else {\n            revert(\"ProxyAdmin: unknown proxy type\");\n        }\n    }\n\n    /**\n     * @notice Returns the admin of the given proxy address.\n     *\n     * @param _proxy Address of the proxy to get the admin of.\n     *\n     * @return Address of the admin of the proxy.\n     */\n    function getProxyAdmin(address payable _proxy) external view returns (address) {\n        ProxyType ptype = proxyType[_proxy];\n        if (ptype == ProxyType.ERC1967) {\n            return IStaticERC1967Proxy(_proxy).admin();\n        } else if (ptype == ProxyType.CHUGSPLASH) {\n            return IStaticL1ChugSplashProxy(_proxy).getOwner();\n        } else if (ptype == ProxyType.RESOLVED) {\n            return addressManager.owner();\n        } else {\n            revert(\"ProxyAdmin: unknown proxy type\");\n        }\n    }\n\n    /**\n     * @notice Changes a proxy's implementation contract.\n     *\n     * @param _proxy          Address of the proxy to upgrade.\n     * @param _implementation Address of the new implementation address.\n     */\n    function upgrade(address payable _proxy, address _implementation) public onlyOwner {\n        ProxyType ptype = proxyType[_proxy];\n        if (ptype == ProxyType.ERC1967) {\n            Proxy(_proxy).upgradeTo(_implementation);\n        } else if (ptype == ProxyType.CHUGSPLASH) {\n            L1ChugSplashProxy(_proxy).setStorage(\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc,\n                bytes32(uint256(uint160(_implementation)))\n            );\n        } else if (ptype == ProxyType.RESOLVED) {\n            string memory name = implementationName[_proxy];\n            addressManager.setAddress(name, _implementation);\n        } else {\n            revert(\"ProxyAdmin: unknown proxy type\");\n        }\n    }\n}\n"
    },
    "contracts/universal/Semver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/**\n * @title Semver\n * @notice Semver is a simple contract for managing contract versions.\n */\ncontract Semver {\n    /**\n     * @notice Contract version number (major).\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    uint256 private immutable MAJOR_VERSION;\n\n    /**\n     * @notice Contract version number (minor).\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    uint256 private immutable MINOR_VERSION;\n\n    /**\n     * @notice Contract version number (patch).\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    uint256 private immutable PATCH_VERSION;\n\n    /**\n     * @param _major Version number (major).\n     * @param _minor Version number (minor).\n     * @param _patch Version number (patch).\n     */\n    constructor(\n        uint256 _major,\n        uint256 _minor,\n        uint256 _patch\n    ) {\n        MAJOR_VERSION = _major;\n        MINOR_VERSION = _minor;\n        PATCH_VERSION = _patch;\n    }\n\n    /**\n     * @notice Returns the full semver contract version.\n     *\n     * @return Semver contract version as a string.\n     */\n    function version() public view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    Strings.toString(MAJOR_VERSION),\n                    \".\",\n                    Strings.toString(MINOR_VERSION),\n                    \".\",\n                    Strings.toString(PATCH_VERSION)\n                )\n            );\n    }\n}\n"
    },
    "contracts/universal/StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.15;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { SafeCall } from \"../libraries/SafeCall.sol\";\nimport { IRemoteToken, IL1Token } from \"./SupportedInterfaces.sol\";\nimport { CrossDomainMessenger } from \"./CrossDomainMessenger.sol\";\nimport { OptimismMintableERC20 } from \"./OptimismMintableERC20.sol\";\n\n/**\n * @title StandardBridge\n * @notice StandardBridge is a base contract for the L1 and L2 standard ERC20 bridges.\n */\nabstract contract StandardBridge {\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice The L2 gas limit set when eth is depoisited using the receive() function.\n     */\n    uint32 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 200_000;\n\n    /**\n     * @notice Messenger contract on this domain.\n     */\n    CrossDomainMessenger public immutable messenger;\n\n    /**\n     * @notice Corresponding bridge on the other domain.\n     */\n    StandardBridge public immutable otherBridge;\n\n    /**\n     * @custom:legacy\n     * @notice Spacer for backwards compatibility.\n     */\n    uint256 internal spacer0;\n\n    /**\n     * @custom:legacy\n     * @notice Spacer for backwards compatibility.\n     */\n    uint256 internal spacer1;\n\n    /**\n     * @notice Mapping that stores deposits for a given pair of local and remote tokens.\n     */\n    mapping(address => mapping(address => uint256)) public deposits;\n\n    /**\n     * @notice Emitted when an ETH bridge is initiated to the other chain.\n     *\n     * @param from      Address of the sender.\n     * @param to        Address of the receiver.\n     * @param amount    Amount of ETH sent.\n     * @param extraData Extra data sent with the transaction.\n     */\n    event ETHBridgeInitiated(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ETH bridge is finalized on this chain.\n     *\n     * @param from      Address of the sender.\n     * @param to        Address of the receiver.\n     * @param amount    Amount of ETH sent.\n     * @param extraData Extra data sent with the transaction.\n     */\n    event ETHBridgeFinalized(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ERC20 bridge is initiated to the other chain.\n     *\n     * @param localToken  Address of the ERC20 on this chain.\n     * @param remoteToken Address of the ERC20 on the remote chain.\n     * @param from        Address of the sender.\n     * @param to          Address of the receiver.\n     * @param amount      Amount of ETH sent.\n     * @param extraData   Extra data sent with the transaction.\n     */\n    event ERC20BridgeInitiated(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ERC20 bridge is finalized on this chain.\n     *\n     * @param localToken  Address of the ERC20 on this chain.\n     * @param remoteToken Address of the ERC20 on the remote chain.\n     * @param from        Address of the sender.\n     * @param to          Address of the receiver.\n     * @param amount      Amount of ETH sent.\n     * @param extraData   Extra data sent with the transaction.\n     */\n    event ERC20BridgeFinalized(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Emitted when an ERC20 bridge to this chain fails.\n     *\n     * @param localToken  Address of the ERC20 on this chain.\n     * @param remoteToken Address of the ERC20 on the remote chain.\n     * @param from        Address of the sender.\n     * @param to          Address of the receiver.\n     * @param amount      Amount of ETH sent.\n     * @param extraData   Extra data sent with the transaction.\n     */\n    event ERC20BridgeFailed(\n        address indexed localToken,\n        address indexed remoteToken,\n        address indexed from,\n        address to,\n        uint256 amount,\n        bytes extraData\n    );\n\n    /**\n     * @notice Only allow EOAs to call the functions. Note that this is not safe against contracts\n     *         calling code within their constructors, but also doesn't really matter since we're\n     *         just trying to prevent users accidentally depositing with smart contract wallets.\n     */\n    modifier onlyEOA() {\n        require(\n            !Address.isContract(msg.sender),\n            \"StandardBridge: function can only be called from an EOA\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Ensures that the caller is a cross-chain message from the other bridge.\n     */\n    modifier onlyOtherBridge() {\n        require(\n            msg.sender == address(messenger) &&\n                messenger.xDomainMessageSender() == address(otherBridge),\n            \"StandardBridge: function can only be called from the other bridge\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Ensures that the caller is this contract.\n     */\n    modifier onlySelf() {\n        require(msg.sender == address(this), \"StandardBridge: function can only be called by self\");\n        _;\n    }\n\n    /**\n     * @param _messenger   Address of CrossDomainMessenger on this network.\n     * @param _otherBridge Address of the other StandardBridge contract.\n     */\n    constructor(address payable _messenger, address payable _otherBridge) {\n        messenger = CrossDomainMessenger(_messenger);\n        otherBridge = StandardBridge(_otherBridge);\n    }\n\n    /**\n     * @notice Allows EOAs to deposit ETH by sending directly to the bridge.\n     */\n    receive() external payable onlyEOA {\n        _initiateBridgeETH(msg.sender, msg.sender, msg.value, RECEIVE_DEFAULT_GAS_LIMIT, bytes(\"\"));\n    }\n\n    /**\n     * @notice Sends ETH to the sender's address on the other chain.\n     *\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeETH(uint32 _minGasLimit, bytes calldata _extraData) public payable onlyEOA {\n        _initiateBridgeETH(msg.sender, msg.sender, msg.value, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @notice Sends ETH to a receiver's address on the other chain. Note that if ETH is sent to a\n     *         smart contract and the call fails, the ETH will be temporarily locked in the\n     *         StandardBridge on the other chain until the call is replayed. If the call cannot be\n     *         replayed with any amount of gas (call always reverts), then the ETH will be\n     *         permanently locked in the StandardBridge on the other chain.\n     *\n     * @param _to          Address of the receiver.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeETHTo(\n        address _to,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) public payable {\n        _initiateBridgeETH(msg.sender, _to, msg.value, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @notice Sends ERC20 tokens to the sender's address on the other chain. Note that if the\n     *         ERC20 token on the other chain does not recognize the local token as the correct\n     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n     *         this chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _amount      Amount of local tokens to deposit.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) public virtual onlyEOA {\n        _initiateBridgeERC20(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            msg.sender,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Sends ERC20 tokens to a receiver's address on the other chain. Note that if the\n     *         ERC20 token on the other chain does not recognize the local token as the correct\n     *         pair token, the ERC20 bridge will fail and the tokens will be returned to sender on\n     *         this chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of local tokens to deposit.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function bridgeERC20To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) public virtual {\n        _initiateBridgeERC20(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            _to,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Finalizes an ETH bridge on this chain. Can only be triggered by the other\n     *         StandardBridge contract on the remote chain.\n     *\n     * @param _from      Address of the sender.\n     * @param _to        Address of the receiver.\n     * @param _amount    Amount of ETH being bridged.\n     * @param _extraData Extra data to be sent with the transaction. Note that the recipient will\n     *                   not be triggered with this data, but it will be emitted and can be used\n     *                   to identify the transaction.\n     */\n    function finalizeBridgeETH(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) public payable onlyOtherBridge {\n        require(msg.value == _amount, \"StandardBridge: amount sent does not match amount required\");\n        require(_to != address(this), \"StandardBridge: cannot send to self\");\n\n        emit ETHBridgeFinalized(_from, _to, _amount, _extraData);\n        bool success = SafeCall.call(_to, gasleft(), _amount, hex\"\");\n        require(success, \"StandardBridge: ETH transfer failed\");\n    }\n\n    /**\n     * @notice Finalizes an ERC20 bridge on this chain. Can only be triggered by the other\n     *         StandardBridge contract on the remote chain.\n     *\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _from        Address of the sender.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of ETH being bridged.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function finalizeBridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) public onlyOtherBridge {\n        try this.completeOutboundTransfer(_localToken, _remoteToken, _to, _amount) {\n            emit ERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n        } catch {\n            // Something went wrong during the bridging process, return to sender.\n            // Can happen if a bridge UI specifies the wrong L2 token.\n            // We reverse the to and from addresses to make sure the tokens are returned to the\n            // sender on the other chain and preserve the accuracy of accounting based on emitted\n            // events.\n            _initiateBridgeERC20Unchecked(\n                _localToken,\n                _remoteToken,\n                _to,\n                _from,\n                _amount,\n                0, // _minGasLimit, 0 is fine here\n                _extraData\n            );\n            emit ERC20BridgeFailed(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n        }\n    }\n\n    /**\n     * @notice Completes an outbound token transfer. Public function, but can only be called by\n     *         this contract. It's security critical that there be absolutely no way for anyone to\n     *         trigger this function, except by explicit trigger within this contract. Used as a\n     *         simple way to be able to try/catch any type of revert that could occur during an\n     *         ERC20 mint/transfer.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of ETH being bridged.\n     */\n    function completeOutboundTransfer(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _amount\n    ) public onlySelf {\n        // Make sure external function calls can't be used to trigger calls to\n        // completeOutboundTransfer. We only make external (write) calls to _localToken.\n        require(_localToken != address(this), \"StandardBridge: local token cannot be self\");\n\n        if (_isOptimismMintableERC20(_localToken)) {\n            require(\n                _isCorrectTokenPair(_localToken, _remoteToken),\n                \"StandardBridge: wrong remote token for Optimism Mintable ERC20 local token\"\n            );\n\n            OptimismMintableERC20(_localToken).mint(_to, _amount);\n        } else {\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] - _amount;\n            IERC20(_localToken).safeTransfer(_to, _amount);\n        }\n    }\n\n    /**\n     * @notice Initiates a bridge of ETH through the CrossDomainMessenger.\n     *\n     * @param _from        Address of the sender.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of ETH being bridged.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function _initiateBridgeETH(\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes memory _extraData\n    ) internal {\n        emit ETHBridgeInitiated(_from, _to, _amount, _extraData);\n\n        messenger.sendMessage{ value: _amount }(\n            address(otherBridge),\n            abi.encodeWithSelector(\n                this.finalizeBridgeETH.selector,\n                _from,\n                _to,\n                _amount,\n                _extraData\n            ),\n            _minGasLimit\n        );\n    }\n\n    /**\n     * @notice Sends ERC20 tokens to a receiver's address on the other chain.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of local tokens to deposit.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function _initiateBridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal {\n        // Make sure external function calls can't be used to trigger calls to\n        // completeOutboundTransfer. We only make external (write) calls to _localToken.\n        require(_localToken != address(this), \"StandardBridge: local token cannot be self\");\n\n        if (_isOptimismMintableERC20(_localToken)) {\n            require(\n                _isCorrectTokenPair(_localToken, _remoteToken),\n                \"StandardBridge: wrong remote token for Optimism Mintable ERC20 local token\"\n            );\n\n            OptimismMintableERC20(_localToken).burn(_from, _amount);\n        } else {\n            IERC20(_localToken).safeTransferFrom(_from, address(this), _amount);\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] + _amount;\n        }\n\n        _initiateBridgeERC20Unchecked(\n            _localToken,\n            _remoteToken,\n            _from,\n            _to,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Sends ERC20 tokens to a receiver's address on the other chain WITHOUT doing any\n     *         validation. Be EXTREMELY careful when using this function.\n     *\n     * @param _localToken  Address of the ERC20 on this chain.\n     * @param _remoteToken Address of the corresponding token on the remote chain.\n     * @param _to          Address of the receiver.\n     * @param _amount      Amount of local tokens to deposit.\n     * @param _minGasLimit Minimum amount of gas that the bridge can be relayed with.\n     * @param _extraData   Extra data to be sent with the transaction. Note that the recipient will\n     *                     not be triggered with this data, but it will be emitted and can be used\n     *                     to identify the transaction.\n     */\n    function _initiateBridgeERC20Unchecked(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal {\n        messenger.sendMessage(\n            address(otherBridge),\n            abi.encodeWithSelector(\n                this.finalizeBridgeERC20.selector,\n                // Because this call will be executed on the remote chain, we reverse the order of\n                // the remote and local token addresses relative to their order in the\n                // finalizeBridgeERC20 function.\n                _remoteToken,\n                _localToken,\n                _from,\n                _to,\n                _amount,\n                _extraData\n            ),\n            _minGasLimit\n        );\n\n        emit ERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @notice Checks if a given address is an OptimismMintableERC20. Not perfect, but good enough.\n     *         Just the way we like it.\n     *\n     * @param _token Address of the token to check.\n     *\n     * @return True if the token is an OptimismMintableERC20.\n     */\n    function _isOptimismMintableERC20(address _token) internal view returns (bool) {\n        return ERC165Checker.supportsInterface(_token, type(IL1Token).interfaceId);\n    }\n\n    /**\n     * @notice Checks if the \"other token\" is the correct pair token for the OptimismMintableERC20.\n     *\n     * @param _mintableToken OptimismMintableERC20 to check against.\n     * @param _otherToken    Pair token to check.\n     *\n     * @return True if the other token is the correct pair token for the OptimismMintableERC20.\n     */\n    function _isCorrectTokenPair(address _mintableToken, address _otherToken)\n        internal\n        view\n        returns (bool)\n    {\n        return _otherToken == OptimismMintableERC20(_mintableToken).l1Token();\n    }\n}\n"
    },
    "contracts/universal/SupportedInterfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Import this here to make it available just by importing this file\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IRemoteToken {\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n\n    function remoteToken() external;\n}\n\ninterface IL1Token {\n    function mint(address _to, uint256 _amount) external;\n\n    function burn(address _from, uint256 _amount) external;\n\n    function l1Token() external;\n}\n"
    },
    "contracts/vendor/AddressAliasHelper.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.0;\n\nlibrary AddressAliasHelper {\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + offset);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - offset);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.2) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "node_modules/@rari-capital/solmate/src/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnerUpdated(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setOwner(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n"
    },
    "node_modules/@rari-capital/solmate/src/utils/Bytes32AddressLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"
    },
    "node_modules/@rari-capital/solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\n        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.\n    }\n\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is < 0.5 we return zero. This happens when\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n            if (x <= -42139678854452767551) return 0;\n\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n            if (x >= 135305999368893231589) revert(\"EXP_OVERFLOW\");\n\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5**18;\n\n            // Reduce range of x to (- ln 2,  ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // k is in the range [-61, 195].\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // p is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range (0.09, 0.25) * 2**96.\n\n            // We now need to multiply r by:\n            // * the scale factor s = ~6.031367120.\n            // * the 2**k factor from the range reduction.\n            // * the 1e18 / 2**96 factor for base conversion.\n            // We do this all at once, with an intermediate result in 2**213\n            // basis, so the final right shift is always by a positive amount.\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n        }\n    }\n\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            require(x > 0, \"UNDEFINED\");\n\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n            // We do this by multiplying by 2**96 / 10**18. But since\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n            // and add ln(2**96 / 10**18) at the end.\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            int256 k = int256(log2(uint256(x))) - 96;\n            x <<= uint256(159 - k);\n            x = int256(uint256(x) >> 159);\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // p is made monic, we will multiply by a scale factor later.\n            int256 p = x + 3273285459638523848632254066296;\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\n            p = p * x - (795164235651350426258249787498 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            // q is monic by convention.\n            int256 q = x + 5573035233440673466300451813936;\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial is known not to have zeros in the domain.\n                // No scaling required because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r is in the range (0, 0.125) * 2**96\n\n            // Finalization, we need to:\n            // * multiply by the scale factor s = 5.549\n            // * add ln(2**96 / 10**18)\n            // * add k * ln(2)\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n            r *= 1677202110996718588342820967067443963516166;\n            // add ln(2) * k * 5e18 * 2**192\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n            // base conversion: mul 2**18 / 2**192\n            r >>= 174;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        require(x > 0, \"UNDEFINED\");\n\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\n            r := or(r, lt(0x1, shr(r, x)))\n        }\n    }\n}\n"
    },
    "node_modules/ds-test/src/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    } \n\n    function fail() internal {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Expected\", b);\n            emit log_named_string(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "node_modules/forge-std/src/Script.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"./Vm.sol\";\nimport \"./console.sol\";\nimport \"./console2.sol\";\n\nabstract contract Script {\n    bool public IS_SCRIPT = true;\n    address constant private VM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    Vm public constant vm = Vm(VM_ADDRESS);\n\n    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce\n    /// @notice adapated from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)\n    function computeCreateAddress(address deployer, uint256 nonce) internal pure returns (address) {\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)             return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))));\n        if (nonce <= 0x7f)             return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))));\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= 2**8 - 1)  return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))));\n        if (nonce <= 2**16 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))));\n        if (nonce <= 2**24 - 1) return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))));\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return addressFromLast20Bytes(keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce))));\n    }\n\n    function addressFromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n}\n"
    },
    "node_modules/forge-std/src/Test.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"./Script.sol\";\nimport \"ds-test/test.sol\";\n\n// Wrappers around Cheatcodes to avoid footguns\nabstract contract Test is DSTest, Script {\n    using stdStorage for StdStorage;\n\n    uint256 internal constant UINT256_MAX =\n        115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    StdStorage internal stdstore;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-LOGS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    event log_array(uint256[] val);\n    event log_array(int256[] val);\n    event log_array(address[] val);\n    event log_named_array(string key, uint256[] val);\n    event log_named_array(string key, int256[] val);\n    event log_named_array(string key, address[] val);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-CHEATS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) public {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) public {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address who) public {\n        vm.deal(who, 1 << 128);\n        vm.prank(who);\n    }\n\n    function hoax(address who, uint256 give) public {\n        vm.deal(who, give);\n        vm.prank(who);\n    }\n\n    function hoax(address who, address origin) public {\n        vm.deal(who, 1 << 128);\n        vm.prank(who, origin);\n    }\n\n    function hoax(address who, address origin, uint256 give) public {\n        vm.deal(who, give);\n        vm.prank(who, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address who) public {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who);\n    }\n\n    function startHoax(address who, uint256 give) public {\n        vm.deal(who, give);\n        vm.startPrank(who);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address who, address origin) public {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who, origin);\n    }\n\n    function startHoax(address who, address origin, uint256 give) public {\n        vm.deal(who, give);\n        vm.startPrank(who, origin);\n    }\n\n    function changePrank(address who) internal {\n        vm.stopPrank();\n        vm.startPrank(who);\n    }\n\n    // DEPRECATED: Use `deal` instead\n    function tip(address token, address to, uint256 give) public {\n        emit log_named_string(\"WARNING\", \"Test tip(address,address,uint256): The `tip` stdcheat has been deprecated. Use `deal` instead.\");\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n    }\n\n    // The same as Vm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) public {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) public {\n        deal(token, to, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) public {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n\n        // update total supply\n        if(adjust){\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if(give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore\n                .target(token)\n                .sig(0x18160ddd)\n                .checked_write(totSup);\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) internal virtual returns (uint256 result) {\n        require(min <= max, \"Test bound(uint256,uint256,uint256): Max is less than min.\");\n\n        uint256 size = max - min;\n\n        if (size == 0)\n        {\n            result = min;\n        }\n        else if (size == UINT256_MAX)\n        {\n            result = x;\n        }\n        else\n        {\n            ++size; // make `max` inclusive\n            uint256 mod = x % size;\n            result = min + mod;\n        }\n\n        emit log_named_uint(\"Bound Result\", result);\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args)\n        public\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what)\n        public\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string): Deployment failed.\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-ASSERTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal {\n        if (a != b) {\n            emit log                (\"Error: a == b not satisfied [bool]\");\n            emit log_named_string   (\"  Expected\", b ? \"true\" : \"false\");\n            emit log_named_string   (\"    Actual\", a ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal {\n        assertEq0(a, b, err);\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [uint[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [int[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(address[] memory a, address[] memory b) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log(\"Error: a == b not satisfied [address[]]\");\n            emit log_named_array(\"  Expected\", b);\n            emit log_named_array(\"    Actual\", a);\n            fail();\n        }\n    }\n\n    function assertEq(uint256[] memory a, uint256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(int256[] memory a, int256[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n\n    function assertEq(address[] memory a, address[] memory b, string memory err) internal {\n        if (keccak256(abi.encode(a)) != keccak256(abi.encode(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint (\"  Expected\", b);\n            emit log_named_uint (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int  (\"  Expected\", b);\n            emit log_named_int  (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                    (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint         (\"    Expected\", b);\n            emit log_named_uint         (\"      Actual\", a);\n            emit log_named_decimal_uint (\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint (\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string       (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                   (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int         (\"    Expected\", b);\n            emit log_named_int         (\"      Actual\", a);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string      (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n    // DEPRECATED: Use Vm's `expectRevert` without any arguments instead\n    bytes public constant lowLevelError = bytes(\"\"); // `0x`\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-STORAGE\n//////////////////////////////////////////////////////////////////////////*/\n\nstruct StdStorage {\n    mapping (address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping (address => mapping(bytes4 =>  mapping(bytes32 => bool))) finds;\n\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorage {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint slot);\n    event WARNING_UninitedSlot(address who, uint slot);\n\n    uint256 private constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    int256 private constant INT256_MAX = 57896044618658097711785492504343953926634992332820282019728792003956564819967;\n\n    Vm private constant vm_std_store = Vm(address(uint160(uint256(keccak256('hevm cheat code')))));\n\n    function sigs(\n        string memory sigStr\n    )\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(\n        StdStorage storage self\n    )\n        internal\n        returns (uint256)\n    {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm_std_store.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n\n        (bytes32[] memory reads, ) = vm_std_store.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm_std_store.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm_std_store.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm_std_store.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32*field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm_std_store.store(who, reads[i], prev);\n                    break;\n                }\n                vm_std_store.store(who, reads[i], prev);\n            }\n        } else {\n            require(false, \"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))], \"stdStorage find(StdStorage): Slot(s) not found.\");\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(\n        StdStorage storage self,\n        bytes32 set\n    ) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n        bytes32 curr = vm_std_store.load(who, slot);\n\n        if (fdat != curr) {\n            require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isn't supported.\");\n        }\n        vm_std_store.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm_std_store.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        int256 v = read_int(self);\n        if (v == 0) return false;\n        if (v == 1) return true;\n        revert(\"stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.\");\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint offset) public pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory)\n    {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-MATH\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN)\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n        return uint256(a >= 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b\n            ? a - b\n            : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        if (a >= 0 && b >= 0 || a < 0 && b < 0) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"
    },
    "node_modules/forge-std/src/Vm.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface Vm {\n    struct Log {\n        bytes32[] topics;\n        bytes data;\n    }\n\n    // Sets block.timestamp (newTimestamp)\n    function warp(uint256) external;\n    // Sets block.height (newHeight)\n    function roll(uint256) external;\n    // Sets block.basefee (newBasefee)\n    function fee(uint256) external;\n    // Sets block.chainid\n    function chainId(uint256) external;\n    // Loads a storage slot from an address (who, slot)\n    function load(address,bytes32) external returns (bytes32);\n    // Stores a value to an address' storage slot, (who, slot, value)\n    function store(address,bytes32,bytes32) external;\n    // Signs data, (privateKey, digest) => (v, r, s)\n    function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n    // Gets the address for a given private key, (privateKey) => (address)\n    function addr(uint256) external returns (address);\n    // Gets the nonce of an account\n    function getNonce(address) external returns (uint64);\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address, uint64) external;\n    // Performs a foreign function call via the terminal, (stringInputs) => (result)\n    function ffi(string[] calldata) external returns (bytes memory);\n    // Sets environment variables, (name, value)\n    function setEnv(string calldata, string calldata) external;\n    // Reads environment variables, (name) => (value)\n    function envBool(string calldata) external returns (bool);\n    function envUint(string calldata) external returns (uint256);\n    function envInt(string calldata) external returns (int256);\n    function envAddress(string calldata) external returns (address);\n    function envBytes32(string calldata) external returns (bytes32);\n    function envString(string calldata) external returns (string memory);\n    function envBytes(string calldata) external returns (bytes memory);\n    // Reads environment variables as arrays, (name, delim) => (value[])\n    function envBool(string calldata, string calldata) external returns (bool[] memory);\n    function envUint(string calldata, string calldata) external returns (uint256[] memory);\n    function envInt(string calldata, string calldata) external returns (int256[] memory);\n    function envAddress(string calldata, string calldata) external returns (address[] memory);\n    function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n    function envString(string calldata, string calldata) external returns (string[] memory);\n    function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address,address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address,address) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Sets an address' balance, (who, newBalance)\n    function deal(address, uint256) external;\n    // Sets an address' code, (who, newCode)\n    function etch(address, bytes calldata) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata) external;\n    function expectRevert(bytes4) external;\n    function expectRevert() external;\n    // Records all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)\n    function expectEmit(bool,bool,bool,bool) external;\n    function expectEmit(bool,bool,bool,bool,address) external;\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address,bytes calldata,bytes calldata) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expects a call to an address with the specified calldata.\n    // Calldata can either be a strict or a partial match\n    function expectCall(address,bytes calldata) external;\n    // Expects a call to an address with the specified msg.value and calldata\n    function expectCall(address,uint256,bytes calldata) external;\n    // Gets the code from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata) external returns (bytes memory);\n    // Labels an address in call traces\n    function label(address, string calldata) external;\n    // If the condition is false, discard this run's fuzz inputs and generate new ones\n    function assume(bool) external;\n    // Sets block.coinbase (who)\n    function coinbase(address) external;\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address) external;\n    // Using the address that calls the test contract, has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast(address) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n    // Reads the entire content of file to string, (path) => (data)\n    function readFile(string calldata) external returns (string memory);\n    // Reads next line of file to string, (path) => (line)\n    function readLine(string calldata) external returns (string memory);\n    // Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.\n    // (path, data) => ()\n    function writeFile(string calldata, string calldata) external;\n    // Writes line to file, creating a file if it does not exist.\n    // (path, data) => ()\n    function writeLine(string calldata, string calldata) external;\n    // Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.\n    // (path) => ()\n    function closeFile(string calldata) external;\n    // Removes file. This cheatcode will revert in the following situations, but is not limited to just these cases:\n    // - Path points to a directory.\n    // - The file doesn't exist.\n    // - The user lacks permissions to remove the file.\n    // (path) => ()\n    function removeFile(string calldata) external;\n    // Convert values to a string, (value) => (stringified value)\n    function toString(address) external returns(string memory);\n    function toString(bytes calldata) external returns(string memory);\n    function toString(bytes32) external returns(string memory);\n    function toString(bool) external returns(string memory);\n    function toString(uint256) external returns(string memory);\n    function toString(int256) external returns(string memory);\n    // Record all the transaction logs\n    function recordLogs() external;\n    // Gets all the recorded logs, () => (logs)\n    function getRecordedLogs() external returns (Log[] memory);\n}\n"
    },
    "node_modules/forge-std/src/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "node_modules/forge-std/src/console2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n// The orignal console.sol uses `int` and `uint` for computing function selectors, but it should\n// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\n\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    }
  },
  "settings": {
    "remappings": [
      "@eth-optimism/contracts-periphery/=node_modules/@eth-optimism/contracts-periphery/contracts/",
      "@openzeppelin/=node_modules/@openzeppelin/",
      "@openzeppelin/contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/",
      "@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/",
      "@rari-capital/=node_modules/@rari-capital/",
      "@rari-capital/solmate/=node_modules/@rari-capital/solmate/",
      "ds-test/=node_modules/ds-test/src/",
      "forge-std/=node_modules/forge-std/src/",
      "contracts/=contracts/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "metadata": {
      "bytecodeHash": "none"
    },
    "outputSelection": {
      "*": {
        "": [
          "ast"
        ],
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}