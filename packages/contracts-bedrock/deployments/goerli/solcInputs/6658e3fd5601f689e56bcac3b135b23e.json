{
  "language": "Solidity",
  "sources": {
    "contracts/L1/L1CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { Lib_PredeployAddresses } from \"../libraries/Lib_PredeployAddresses.sol\";\nimport { OptimismPortal } from \"./OptimismPortal.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\n\n/**\n * @custom:proxied\n * @title L1CrossDomainMessenger\n * @notice The L1CrossDomainMessenger is a message passing interface between L1 and L2 responsible\n *         for sending and receiving data on the L1 side. Users are encouraged to use this\n *         interface instead of interacting with lower-level contracts directly.\n */\ncontract L1CrossDomainMessenger is CrossDomainMessenger {\n    /**\n     * @notice Contract version number.\n     */\n    uint8 public constant VERSION = 1;\n\n    /**\n     * @notice Address of the OptimismPortal.\n     */\n    OptimismPortal public portal;\n\n    /**\n     * @param _portal Address of the OptimismPortal to send and receive messages through.\n     */\n    constructor(OptimismPortal _portal) public {\n        // Mutables\n        initialize(_portal);\n    }\n\n    /**\n     * @notice Intializes mutable variables.\n     *\n     * @param _portal Address of the OptimismPortal to send and receive messages through.\n     */\n    function initialize(OptimismPortal _portal) public reinitializer(VERSION) {\n        portal = _portal;\n        address[] memory blockedSystemAddresses = new address[](1);\n        blockedSystemAddresses[0] = address(this);\n        _initialize(Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER, blockedSystemAddresses);\n    }\n\n    /**\n     * @notice Checks whether the message being sent from the other messenger.\n     *\n     * @return True if the message was sent from the messenger, false otherwise.\n     */\n    function _isSystemMessageSender() internal view override returns (bool) {\n        return msg.sender == address(portal) && portal.l2Sender() == otherMessenger;\n    }\n\n    /**\n     * @notice Sends a message via the OptimismPortal contract.\n     *\n     * @param _to       Address of the recipient on L2.\n     * @param _gasLimit Minimum gas limit that the message can be executed with.\n     * @param _value    ETH value to attach to the message and send to the recipient.\n     * @param _data     Data to attach to the message and call the recipient with.\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal override {\n        portal.depositTransaction{ value: _value }(_to, _value, _gasLimit, false, _data);\n    }\n}\n"
    },
    "contracts/L1/L1StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { Lib_PredeployAddresses } from \"../libraries/Lib_PredeployAddresses.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\n\n/**\n * @custom:proxied\n * @title L1StandardBridge\n * @notice The L1StandardBridge is responsible for transfering ETH and ERC20 tokens between L1 and\n *         L2. ERC20 tokens deposited into L2 are escrowed within this contract until withdrawal.\n *         ETH is transferred to and escrowed within the OptimismPortal contract.\n */\ncontract L1StandardBridge is StandardBridge, Initializable {\n    /**\n     * @notice Contract version number.\n     */\n    uint8 public constant VERSION = 1;\n\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever a deposit of ETH from L1 into L2 is initiated.\n     *\n     * @param _from      Address of the depositor.\n     * @param _to        Address of the recipient on L2.\n     * @param _amount    Amount of ETH deposited.\n     * @param _extraData Extra data attached to the deposit.\n     */\n    event ETHDepositInitiated(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _extraData\n    );\n\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever a withdrawal of ETH from L2 to L1 is finalized.\n     *\n     * @param _from      Address of the withdrawer.\n     * @param _to        Address of the recipient on L1.\n     * @param _amount    Amount of ETH withdrawn.\n     * @param _extraData Extra data attached to the withdrawal.\n     */\n    event ETHWithdrawalFinalized(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _extraData\n    );\n\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever an ERC20 deposit is initiated.\n     *\n     * @param _l1Token   Address of the token on L1.\n     * @param _l2Token   Address of the corresponding token on L2.\n     * @param _from      Address of the depositor.\n     * @param _to        Address of the recipient on L2.\n     * @param _amount    Amount of the ERC20 deposited.\n     * @param _extraData Extra data attached to the deposit.\n     */\n    event ERC20DepositInitiated(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _extraData\n    );\n\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever an ERC20 withdrawal is finalized.\n     *\n     * @param _l1Token   Address of the token on L1.\n     * @param _l2Token   Address of the corresponding token on L2.\n     * @param _from      Address of the withdrawer.\n     * @param _to        Address of the recipient on L1.\n     * @param _amount    Amount of the ERC20 withdrawn.\n     * @param _extraData Extra data attached to the withdrawal.\n     */\n    event ERC20WithdrawalFinalized(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _extraData\n    );\n\n    /**\n     * @param _messenger Address of the L1CrossDomainMessenger.\n     */\n    constructor(address payable _messenger) public {\n        // Mutables\n        initialize(_messenger);\n    }\n\n    /**\n     * @notice Intializes mutable variables.\n     *\n     * @param _messenger Address of the L1CrossDomainMessenger.\n     */\n    function initialize(address payable _messenger) public reinitializer(VERSION) {\n        _initialize(_messenger, payable(Lib_PredeployAddresses.L2_STANDARD_BRIDGE));\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Retrieves the access of the corresponding L2 bridge contract.\n     *\n     * @return Address of the corresponding L2 bridge contract.\n     */\n    function l2TokenBridge() external returns (address) {\n        return address(otherBridge);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Deposits some amount of ETH into the sender's account on L2.\n     *\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\n     *                     execute any code on L2 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function depositETH(uint32 _minGasLimit, bytes calldata _extraData) external payable onlyEOA {\n        _initiateETHDeposit(msg.sender, msg.sender, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Deposits some amount of ETH into a target account on L2.\n     *         Note that if ETH is sent to a contract on L2 and the call fails, then that ETH will\n     *         be locked in the L2StandardBridge. ETH may be recoverable if the call can be\n     *         successfully replayed by increasing the amount of gas supplied to the call. If the\n     *         call will fail for any amount of gas, then the ETH will be locked permanently.\n     *\n     * @param _to          Address of the recipient on L2.\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\n     *                     execute any code on L2 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function depositETHTo(\n        address _to,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external payable {\n        _initiateETHDeposit(msg.sender, _to, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Deposits some amount of ERC20 tokens into the sender's account on L2.\n     *\n     * @param _l1Token     Address of the L1 token being deposited.\n     * @param _l2Token     Address of the corresponding token on L2.\n     * @param _amount      Amount of the ERC20 to deposit.\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\n     *                     execute any code on L2 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function depositERC20(\n        address _l1Token,\n        address _l2Token,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external virtual onlyEOA {\n        _initiateERC20Deposit(\n            _l1Token,\n            _l2Token,\n            msg.sender,\n            msg.sender,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Deposits some amount of ERC20 tokens into a target account on L2.\n     *\n     * @param _l1Token     Address of the L1 token being deposited.\n     * @param _l2Token     Address of the corresponding token on L2.\n     * @param _to          Address of the recipient on L2.\n     * @param _amount      Amount of the ERC20 to deposit.\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\n     * @param _extraData   Optional data to forward to L2. Data supplied here will not be used to\n     *                     execute any code on L2 and is only emitted as extra data for the\n     *                     convenience of off-chain tooling.\n     */\n    function depositERC20To(\n        address _l1Token,\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external virtual {\n        _initiateERC20Deposit(\n            _l1Token,\n            _l2Token,\n            msg.sender,\n            _to,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Finalizes a withdrawal of ETH from L2.\n     *\n     * @param _from      Address of the withdrawer on L2.\n     * @param _to        Address of the recipient on L1.\n     * @param _amount    Amount of ETH to withdraw.\n     * @param _extraData Optional data forwarded from L2.\n     */\n    function finalizeETHWithdrawal(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) external payable onlyOtherBridge {\n        emit ETHWithdrawalFinalized(_from, _to, _amount, _extraData);\n        finalizeBridgeETH(_from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Finalizes a withdrawal of ERC20 tokens from L2.\n     *\n     * @param _l1Token   Address of the token on L1.\n     * @param _l2Token   Address of the corresponding token on L2.\n     * @param _from      Address of the withdrawer on L2.\n     * @param _to        Address of the recipient on L1.\n     * @param _amount    Amount of ETH to withdraw.\n     * @param _extraData Optional data forwarded from L2.\n     */\n    function finalizeERC20Withdrawal(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) external onlyOtherBridge {\n        emit ERC20WithdrawalFinalized(_l1Token, _l2Token, _from, _to, _amount, _extraData);\n        finalizeBridgeERC20(_l1Token, _l2Token, _from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @notice Internal function for initiating an ETH deposit.\n     *\n     * @param _from        Address of the sender on L1.\n     * @param _to          Address of the recipient on L2.\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\n     * @param _extraData   Optional data to forward to L2.\n     */\n    function _initiateETHDeposit(\n        address _from,\n        address _to,\n        uint32 _minGasLimit,\n        bytes memory _extraData\n    ) internal {\n        emit ETHDepositInitiated(_from, _to, msg.value, _extraData);\n        _initiateBridgeETH(_from, _to, msg.value, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @notice Internal function for initiating an ERC20 deposit.\n     *\n     * @param _l1Token     Address of the L1 token being deposited.\n     * @param _l2Token     Address of the corresponding token on L2.\n     * @param _from        Address of the sender on L1.\n     * @param _to          Address of the recipient on L2.\n     * @param _amount      Amount of the ERC20 to deposit.\n     * @param _minGasLimit Minimum gas limit for the deposit message on L2.\n     * @param _extraData   Optional data to forward to L2.\n     */\n    function _initiateERC20Deposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal {\n        emit ERC20DepositInitiated(_l1Token, _l2Token, _from, _to, _amount, _extraData);\n        _initiateBridgeERC20(_l1Token, _l2Token, _from, _to, _amount, _minGasLimit, _extraData);\n    }\n}\n"
    },
    "contracts/L1/L2OutputOracle.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @custom:proxied\n * @title L2OutputOracle\n * @notice The L2 state is committed to in this contract\n *         The payable keyword is used on appendL2Output to save gas on the msg.value check.\n *         This contract should be deployed behind an upgradable proxy\n */\n// slither-disable-next-line locked-ether\ncontract L2OutputOracle is OwnableUpgradeable {\n    /**\n     * @notice Contract version number.\n     */\n    uint8 public constant VERSION = 1;\n\n    /**\n     * @notice OutputProposal represents a commitment to the L2 state.\n     *         The timestamp is the L1 timestamp that the output root is posted.\n     *         This timestamp is used to verify that the finalization period\n     *         has passed since the output root was submitted.\n     */\n    struct OutputProposal {\n        bytes32 outputRoot;\n        uint256 timestamp;\n    }\n\n    // TODO: Events should NOT be underscore prefixed.\n    /**\n     * @notice Emitted when an output is appended.\n     *\n     * @param _l2Output      The output root.\n     * @param _l1Timestamp   The L1 timestamp when appended.\n     * @param _l2BlockNumber The L2 block number of the output root.\n     */\n    event L2OutputAppended(\n        bytes32 indexed _l2Output,\n        uint256 indexed _l1Timestamp,\n        uint256 indexed _l2BlockNumber\n    );\n\n    /**\n     * @notice Emitted when an output is deleted.\n     *\n     * @param _l2Output      The output root.\n     * @param _l1Timestamp   The L1 timestamp when appended.\n     * @param _l2BlockNumber The L2 block number of the output root.\n     */\n    event L2OutputDeleted(\n        bytes32 indexed _l2Output,\n        uint256 indexed _l1Timestamp,\n        uint256 indexed _l2BlockNumber\n    );\n\n    /**\n     * @notice Emitted when the sequencer address is changed.\n     *\n     * @param previousSequencer The previous sequencer address.\n     * @param newSequencer      The new sequencer address.\n     */\n    event SequencerChanged(address indexed previousSequencer, address indexed newSequencer);\n\n    /**\n     * @notice The interval in L2 blocks at which checkpoints must be submitted.\n     */\n    uint256 public immutable SUBMISSION_INTERVAL;\n\n    /**\n     * @notice The number of blocks in the chain before the first block in this contract.\n     */\n    uint256 public immutable HISTORICAL_TOTAL_BLOCKS;\n\n    /**\n     * @notice The number of the first L2 block recorded in this contract.\n     */\n    uint256 public immutable STARTING_BLOCK_NUMBER;\n\n    /**\n     * @notice The timestamp of the first L2 block recorded in this contract.\n     */\n    uint256 public immutable STARTING_TIMESTAMP;\n\n    /**\n     * @notice The time between L2 blocks in seconds.\n     */\n    uint256 public immutable L2_BLOCK_TIME;\n\n    /**\n     * @notice The address of the sequencer;\n     */\n    address public sequencer;\n\n    /**\n     * @notice The number of the most recent L2 block recorded in this contract.\n     */\n    uint256 public latestBlockNumber;\n\n    /**\n     * @notice A mapping from L2 block numbers to the respective output root. Note that these\n     *         outputs should not be considered finalized until the finalization period (as defined\n     *         in the Optimism Portal) has passed.\n     */\n    mapping(uint256 => OutputProposal) internal l2Outputs;\n\n    /**\n     * @notice Reverts if called by any account other than the sequencer.\n     */\n    modifier onlySequencer() {\n        require(sequencer == msg.sender, \"OutputOracle: caller is not the sequencer\");\n        _;\n    }\n\n    /**\n     * @param _submissionInterval    Interval in blocks at which checkpoints must be submitted.\n     * @param _genesisL2Output       The initial L2 output of the L2 chain.\n     * @param _historicalTotalBlocks Number of blocks preceding this L2 chain.\n     * @param _startingBlockNumber   The number of the first L2 block.\n     * @param _startingTimestamp     The timestamp of the first L2 block.\n     * @param _l2BlockTime           The timestamp of the first L2 block.\n     * @param _sequencer             The address of the sequencer.\n     * @param _owner                 The address of the owner.\n     */\n    constructor(\n        uint256 _submissionInterval,\n        bytes32 _genesisL2Output,\n        uint256 _historicalTotalBlocks,\n        uint256 _startingBlockNumber,\n        uint256 _startingTimestamp,\n        uint256 _l2BlockTime,\n        address _sequencer,\n        address _owner\n    ) {\n        require(\n            _l2BlockTime < block.timestamp,\n            \"Output Oracle: Initial L2 block time must be less than current time\"\n        );\n\n        // Immutables\n        SUBMISSION_INTERVAL = _submissionInterval;\n        HISTORICAL_TOTAL_BLOCKS = _historicalTotalBlocks;\n        STARTING_BLOCK_NUMBER = _startingBlockNumber;\n        STARTING_TIMESTAMP = _startingTimestamp;\n        L2_BLOCK_TIME = _l2BlockTime;\n\n        // Mutables\n        initialize(_genesisL2Output, _startingBlockNumber, _sequencer, _owner);\n    }\n\n    /**\n     * @notice Intializes mutable variables.\n     *\n     * @param _genesisL2Output     The initial L2 output of the L2 chain.\n     * @param _startingBlockNumber The timestamp to start L2 block at.\n     * @param _sequencer           The address of the sequencer.\n     * @param _owner               The address of the owner.\n     */\n    function initialize(\n        bytes32 _genesisL2Output,\n        uint256 _startingBlockNumber,\n        address _sequencer,\n        address _owner\n    ) public reinitializer(VERSION) {\n        l2Outputs[_startingBlockNumber] = OutputProposal(_genesisL2Output, block.timestamp);\n        latestBlockNumber = _startingBlockNumber;\n        __Ownable_init();\n        changeSequencer(_sequencer);\n        _transferOwnership(_owner);\n    }\n\n    /**\n     * @notice Accepts an L2 outputRoot and the timestamp of the corresponding L2 block. The\n     *         timestamp must be equal to the current value returned by `nextTimestamp()` in order\n     *         to be accepted. This function may only be called by the Sequencer.\n     *\n     * @param _l2Output      The L2 output of the checkpoint block.\n     * @param _l2BlockNumber The L2 block number that resulted in _l2Output.\n     * @param _l1Blockhash   A block hash which must be included in the current chain.\n     * @param _l1BlockNumber The block number with the specified block hash.\n     */\n    function appendL2Output(\n        bytes32 _l2Output,\n        uint256 _l2BlockNumber,\n        bytes32 _l1Blockhash,\n        uint256 _l1BlockNumber\n    ) external payable onlySequencer {\n        require(\n            _l2BlockNumber == nextBlockNumber(),\n            \"OutputOracle: Block number must be equal to next expected block number.\"\n        );\n        require(\n            computeL2Timestamp(_l2BlockNumber) < block.timestamp,\n            \"OutputOracle: Cannot append L2 output in future.\"\n        );\n        require(_l2Output != bytes32(0), \"OutputOracle: Cannot submit empty L2 output.\");\n\n        if (_l1Blockhash != bytes32(0)) {\n            // This check allows the sequencer to append an output based on a given L1 block,\n            // without fear that it will be reorged out.\n            // It will also revert if the blockheight provided is more than 256 blocks behind the\n            // chain tip (as the hash will return as zero). This does open the door to a griefing\n            // attack in which the sequencer's submission is censored until the block is no longer\n            // retrievable, if the sequencer is experiencing this attack it can simply leave out the\n            // blockhash value, and delay submission until it is confident that the L1 block is\n            // finalized.\n            require(\n                blockhash(_l1BlockNumber) == _l1Blockhash,\n                \"OutputOracle: Blockhash does not match the hash at the expected height.\"\n            );\n        }\n\n        l2Outputs[_l2BlockNumber] = OutputProposal(_l2Output, block.timestamp);\n        latestBlockNumber = _l2BlockNumber;\n\n        emit L2OutputAppended(_l2Output, block.timestamp, _l2BlockNumber);\n    }\n\n    /**\n     * @notice Deletes the most recent output. This is used to remove the most recent output in the\n     *         event that an erreneous output is submitted. It can only be called by the contract's\n     *         owner, not the sequencer. Longer term, this should be replaced with a more robust\n     *         mechanism which will allow deletion of proposals shown to be invalid by a fault\n     *         proof.\n     *\n     * @param _proposal Represents the output proposal to delete\n     */\n    function deleteL2Output(OutputProposal memory _proposal) external onlyOwner {\n        OutputProposal memory outputToDelete = l2Outputs[latestBlockNumber];\n\n        require(\n            _proposal.outputRoot == outputToDelete.outputRoot,\n            \"OutputOracle: The output root to delete does not match the latest output proposal.\"\n        );\n        require(\n            _proposal.timestamp == outputToDelete.timestamp,\n            \"OutputOracle: The timestamp to delete does not match the latest output proposal.\"\n        );\n\n        emit L2OutputDeleted(\n            outputToDelete.outputRoot,\n            outputToDelete.timestamp,\n            latestBlockNumber\n        );\n\n        delete l2Outputs[latestBlockNumber];\n        latestBlockNumber = latestBlockNumber - SUBMISSION_INTERVAL;\n    }\n\n    /**\n     * @notice Computes the block number of the next L2 block that needs to be checkpointed.\n     */\n    function nextBlockNumber() public view returns (uint256) {\n        return latestBlockNumber + SUBMISSION_INTERVAL;\n    }\n\n    /**\n     * @notice Returns the L2 output proposal given a target L2 block number.\n     *         Returns a null output proposal if none is found.\n     *\n     * @param _l2BlockNumber The L2 block number of the target block.\n     */\n    function getL2Output(uint256 _l2BlockNumber) external view returns (OutputProposal memory) {\n        return l2Outputs[_l2BlockNumber];\n    }\n\n    /**\n     * @notice Returns the L2 timestamp corresponding to a given L2 block number.\n     *         Returns a null output proposal if none is found.\n     *\n     * @param _l2BlockNumber The L2 block number of the target block.\n     */\n    function computeL2Timestamp(uint256 _l2BlockNumber) public view returns (uint256) {\n        require(\n            _l2BlockNumber >= STARTING_BLOCK_NUMBER,\n            \"OutputOracle: Block number must be greater than or equal to the starting block number.\"\n        );\n\n        return\n            STARTING_TIMESTAMP + ((_l2BlockNumber - STARTING_BLOCK_NUMBER) * SUBMISSION_INTERVAL);\n    }\n\n    /**\n     * @notice Transfers the sequencer role to a new account (`newSequencer`).\n     *         Can only be called by the current owner.\n     */\n    function changeSequencer(address _newSequencer) public onlyOwner {\n        require(_newSequencer != address(0), \"OutputOracle: new sequencer is the zero address\");\n        require(_newSequencer != owner(), \"OutputOracle: sequencer cannot be same as the owner\");\n        emit SequencerChanged(sequencer, _newSequencer);\n        sequencer = _newSequencer;\n    }\n}\n"
    },
    "contracts/L1/OptimismPortal.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport { ExcessivelySafeCall } from \"excessively-safe-call/src/ExcessivelySafeCall.sol\";\nimport { L2OutputOracle } from \"./L2OutputOracle.sol\";\nimport { WithdrawalVerifier } from \"../libraries/Lib_WithdrawalVerifier.sol\";\nimport { AddressAliasHelper } from \"../libraries/AddressAliasHelper.sol\";\nimport { ResourceMetering } from \"./ResourceMetering.sol\";\n\n/**\n * @custom:proxied\n * @title OptimismPortal\n * @notice The OptimismPortal is a low-level contract responsible for passing messages between L1\n *         and L2. Messages sent directly to the OptimismPortal have no form of replayability.\n *         Users are encouraged to use the L1CrossDomainMessenger for a higher-level interface.\n */\ncontract OptimismPortal is Initializable, ResourceMetering {\n    /**\n     * @notice Contract version number.\n     */\n    uint8 public constant VERSION = 1;\n\n    /**\n     * @notice Emitted when a transaction is deposited from L1 to L2. The parameters of this event\n     *         are read by the rollup node and used to derive deposit transactions on L2.\n     *\n     * @param from       Address that triggered the deposit transaction.\n     * @param to         Address that the deposit transaction is directed to.\n     * @param mint       Amount of ETH to mint to the sender on L2.\n     * @param value      Amount of ETH to send to the recipient.\n     * @param gasLimit   Minimum gas limit that the message can be executed with.\n     * @param isCreation Whether the message is a contract creation.\n     * @param data       Data to attach to the message and call the recipient with.\n     */\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 mint,\n        uint256 value,\n        uint64 gasLimit,\n        bool isCreation,\n        bytes data\n    );\n\n    /**\n     * @notice Emitted when a withdrawal transaction is finalized.\n     *\n     * @param withdrawalHash Hash of the withdrawal transaction.\n     * @param success        Whether the withdrawal transaction was successful.\n     */\n    event WithdrawalFinalized(bytes32 indexed withdrawalHash, bool success);\n\n    /**\n     * @notice Value used to reset the l2Sender, this is more efficient than setting it to zero.\n     */\n    address internal constant DEFAULT_L2_SENDER = 0x000000000000000000000000000000000000dEaD;\n\n    /**\n     * @notice Minimum time (in seconds) that must elapse before a withdrawal can be finalized.\n     */\n    uint256 public immutable FINALIZATION_PERIOD_SECONDS;\n\n    /**\n     * @notice Address of the L2OutputOracle.\n     */\n    L2OutputOracle public immutable L2_ORACLE;\n\n    /**\n     * @notice Address of the L2 account which initiated a withdrawal in this transaction. If the\n     *         of this variable is the default L2 sender address, then we are NOT inside of a call\n     *         to finalizeWithdrawalTransaction.\n     */\n    address public l2Sender;\n\n    /**\n     * @notice The L2 gas limit set when eth is deposited using the receive() function.\n     */\n    uint64 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\n\n    /**\n     * @notice Additional gas reserved for clean up after finalizing a transaction withdrawal.\n     */\n    uint256 internal constant FINALIZE_GAS_BUFFER = 20_000;\n\n    /**\n     * @notice A list of withdrawal hashes which have been successfully finalized.\n     */\n    mapping(bytes32 => bool) public finalizedWithdrawals;\n\n    /**\n     * @notice Reserve extra slots (to to a total of 50) in the storage layout for future upgrades.\n     */\n    uint256[48] private __gap;\n\n    /**\n     * @param _l2Oracle                  Address of the L2OutputOracle contract.\n     * @param _finalizationPeriodSeconds Output finalization time in seconds.\n     */\n    constructor(L2OutputOracle _l2Oracle, uint256 _finalizationPeriodSeconds) {\n        // Immutables\n        L2_ORACLE = _l2Oracle;\n        FINALIZATION_PERIOD_SECONDS = _finalizationPeriodSeconds;\n\n        // Mutables\n        initialize();\n    }\n\n    /**\n     * @notice Intializes mutable variables.\n     */\n    function initialize() public reinitializer(VERSION) {\n        l2Sender = DEFAULT_L2_SENDER;\n        __ResourceMetering_init();\n    }\n\n    /**\n     * @notice Accepts value so that users can send ETH directly to this contract and have the\n     *         funds be deposited to their address on L2. This is intended as a convenience\n     *         function for EOAs. Contracts should call the depositTransaction() function directly\n     *         otherwise any deposited funds will be lost due to address aliasing.\n     */\n    receive() external payable {\n        depositTransaction(msg.sender, msg.value, RECEIVE_DEFAULT_GAS_LIMIT, false, bytes(\"\"));\n    }\n\n    /**\n     * @notice Accepts deposits of ETH and data, and emits a TransactionDeposited event for use in\n     *         deriving deposit transactions. Note that if a deposit is made by a contract, its\n     *         address will be aliased when retrieved using `tx.origin` or `msg.sender`. Consider\n     *         using the CrossDomainMessenger contracts for a simpler developer experience.\n     *\n     * @param _to         Target address on L2.\n     * @param _value      ETH value to send to the recipient.\n     * @param _gasLimit   Minimum L2 gas limit (can be greater than or equal to this value).\n     * @param _isCreation Whether or not the transaction is a contract creation.\n     * @param _data       Data to trigger the recipient with.\n     */\n    function depositTransaction(\n        address _to,\n        uint256 _value,\n        uint64 _gasLimit,\n        bool _isCreation,\n        bytes memory _data\n    ) public payable metered(_gasLimit) {\n        // Just to be safe, make sure that people specify address(0) as the target when doing\n        // contract creations.\n        // TODO: Do we really need this? Prevents some user error, but adds gas.\n        if (_isCreation) {\n            require(\n                _to == address(0),\n                \"OptimismPortal: must send to address(0) when creating a contract\"\n            );\n        }\n\n        // Transform the from-address to its alias if the caller is a contract.\n        address from = msg.sender;\n        if (msg.sender != tx.origin) {\n            from = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        // Emit a TransactionDeposited event so that the rollup node can derive a deposit\n        // transaction for this deposit.\n        emit TransactionDeposited(from, _to, msg.value, _value, _gasLimit, _isCreation, _data);\n    }\n\n    /**\n     * @notice Determine if an L2 Output is finalized.\n     *\n     * @param _l2BlockNumber The number of the L2 block.\n     */\n\n    function isOutputFinalized(uint256 _l2BlockNumber) external view returns (bool) {\n        L2OutputOracle.OutputProposal memory proposal = L2_ORACLE.getL2Output(_l2BlockNumber);\n\n        if (proposal.outputRoot == bytes32(uint256(0))) {\n            uint256 interval = L2_ORACLE.SUBMISSION_INTERVAL();\n            uint256 startingBlockNumber = L2_ORACLE.STARTING_BLOCK_NUMBER();\n\n            // Prevent underflow\n            if (startingBlockNumber > _l2BlockNumber) {\n                return false;\n            }\n\n            // Find the distance between the _l2BlockNumber, and the checkpoint block before it.\n            uint256 offset = (_l2BlockNumber - startingBlockNumber) % interval;\n            // Look up the checkpoint block after it.\n            proposal = L2_ORACLE.getL2Output(_l2BlockNumber + (interval - offset));\n            // False if that block is not yet appended.\n            if (proposal.outputRoot == bytes32(uint256(0))) {\n                return false;\n            }\n        }\n        return block.timestamp > proposal.timestamp + FINALIZATION_PERIOD_SECONDS;\n    }\n\n    /**\n     * @notice Finalizes a withdrawal transaction.\n     *\n     * @param _nonce           Nonce for the provided message.\n     * @param _sender          Message sender address on L2.\n     * @param _target          Target address on L1.\n     * @param _value           ETH to send to the target.\n     * @param _gasLimit        Minumum gas to be forwarded to the target.\n     * @param _data            Data to send to the target.\n     * @param _l2BlockNumber   L2 block number of the outputRoot.\n     * @param _outputRootProof Inclusion proof of the withdrawer contracts storage root.\n     * @param _withdrawalProof Inclusion proof for the given withdrawal in the withdrawer contract.\n     */\n    function finalizeWithdrawalTransaction(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes calldata _data,\n        uint256 _l2BlockNumber,\n        WithdrawalVerifier.OutputRootProof calldata _outputRootProof,\n        bytes calldata _withdrawalProof\n    ) external payable {\n        // Prevent nested withdrawals within withdrawals.\n        require(\n            l2Sender == DEFAULT_L2_SENDER,\n            \"OptimismPortal: can only trigger one withdrawal per transaction\"\n        );\n\n        // Prevent users from creating a deposit transaction where this address is the message\n        // sender on L2.\n        require(\n            _target != address(this),\n            \"OptimismPortal: you cannot send messages to the portal contract\"\n        );\n\n        // Get the output root.\n        L2OutputOracle.OutputProposal memory proposal = L2_ORACLE.getL2Output(_l2BlockNumber);\n\n        // Ensure that enough time has passed since the proposal was submitted before allowing a\n        // withdrawal. Under the assumption that the fault proof mechanism is operating correctly,\n        // we can infer that any withdrawal that has passed the finalization period must be valid\n        // and can therefore be operated on.\n        require(\n            block.timestamp > proposal.timestamp + FINALIZATION_PERIOD_SECONDS,\n            \"OptimismPortal: proposal is not yet finalized\"\n        );\n\n        // Verify that the output root can be generated with the elements in the proof.\n        require(\n            proposal.outputRoot == WithdrawalVerifier._deriveOutputRoot(_outputRootProof),\n            \"OptimismPortal: invalid output root proof\"\n        );\n\n        // All withdrawals have a unique hash, we'll use this as the identifier for the withdrawal\n        // and to prevent replay attacks.\n        bytes32 withdrawalHash = WithdrawalVerifier.withdrawalHash(\n            _nonce,\n            _sender,\n            _target,\n            _value,\n            _gasLimit,\n            _data\n        );\n\n        // Verify that the hash of this withdrawal was stored in the withdrawal contract on L2. If\n        // this is true, then we know that this withdrawal was actually triggered on L2 can can\n        // therefore be relayed on L1.\n        require(\n            WithdrawalVerifier._verifyWithdrawalInclusion(\n                withdrawalHash,\n                _outputRootProof.withdrawerStorageRoot,\n                _withdrawalProof\n            ),\n            \"OptimismPortal: invalid withdrawal inclusion proof\"\n        );\n\n        // Check that this withdrawal has not already been finalized, this is replay protection.\n        require(\n            finalizedWithdrawals[withdrawalHash] == false,\n            \"OptimismPortal: withdrawal has already been finalized\"\n        );\n\n        // Mark the withdrawal as finalized so it can't be replayed.\n        finalizedWithdrawals[withdrawalHash] = true;\n\n        // We want to maintain the property that the amount of gas supplied to the call to the\n        // target contract is at least the gas limit specified by the user. We can do this by\n        // enforcing that, at this point in time, we still have gaslimit + buffer gas available.\n        require(\n            gasleft() >= _gasLimit + FINALIZE_GAS_BUFFER,\n            \"OptimismPortal: insufficient gas to finalize withdrawal\"\n        );\n\n        // Set the l2Sender so contracts know who triggered this withdrawal on L2.\n        l2Sender = _sender;\n\n        // Trigger the call to the target contract. We use excessivelySafeCall because we don't\n        // care about the returndata and we don't want target contracts to be able to force this\n        // call to run out of gas.\n        (bool success, ) = ExcessivelySafeCall.excessivelySafeCall(\n            _target,\n            _gasLimit,\n            _value,\n            0,\n            _data\n        );\n\n        // Reset the l2Sender back to the default value.\n        l2Sender = DEFAULT_L2_SENDER;\n\n        // All withdrawals are immediately finalized. Replayability can\n        // be achieved through contracts built on top of this contract\n        emit WithdrawalFinalized(withdrawalHash, success);\n    }\n}\n"
    },
    "contracts/L1/ResourceMetering.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { Math } from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport { SignedMath } from \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport { FixedPointMathLib } from \"@rari-capital/solmate/src/utils/FixedPointMathLib.sol\";\nimport { Burn } from \"../libraries/Burn.sol\";\n\n/**\n * @title ResourceMetering\n * @notice ResourceMetering implements an EIP-1559 style resource metering system where pricing\n *         updates automatically based on current demand.\n */\ncontract ResourceMetering {\n    /**\n     * @notice Represents the various parameters that control the way in which resources are\n     *         metered. Corresponds to the EIP-1559 resource metering system.\n     */\n    struct ResourceParams {\n        uint128 prevBaseFee;\n        uint64 prevBoughtGas;\n        uint64 prevBlockNum;\n    }\n\n    /**\n     * @notice Maximum amount of the resource that can be used within this block.\n     */\n    int256 public constant MAX_RESOURCE_LIMIT = 8_000_000;\n\n    /**\n     * @notice Along with the resource limit, determines the target resource limit.\n     */\n    int256 public constant ELASTICITY_MULTIPLIER = 4;\n\n    /**\n     * @notice Target amount of the resource that should be used within this block.\n     */\n    int256 public constant TARGET_RESOURCE_LIMIT = MAX_RESOURCE_LIMIT / ELASTICITY_MULTIPLIER;\n\n    /**\n     * @notice Denominator that determines max change on fee per block.\n     */\n    int256 public constant BASE_FEE_MAX_CHANGE_DENOMINATOR = 8;\n\n    /**\n     * @notice Minimum base fee value, cannot go lower than this.\n     */\n    int256 public constant MINIMUM_BASE_FEE = 10_000;\n\n    /**\n     * @notice Initial base fee value.\n     */\n    uint128 public constant INITIAL_BASE_FEE = 1_000_000_000;\n\n    /**\n     * @notice EIP-1559 style gas parameters.\n     */\n    ResourceParams public params;\n\n    /**\n     * @notice Reserve extra slots (to a total of 50) in the storage layout for future upgrades.\n     */\n    uint256[49] private __gap;\n\n    /**\n     * @notice Set the initial values. In order to enable this contract to be used in an upgradable\n     *         context, the constructor calls a separate init function.\n     */\n    constructor() {\n        __ResourceMetering_init();\n    }\n\n    /**\n     * @notice Sets initial resource parameter values. This function must either be called by the\n     *         initializer function of an upgradeable child contract.\n     */\n    function __ResourceMetering_init() internal {\n        params = ResourceParams({\n            prevBaseFee: INITIAL_BASE_FEE,\n            prevBoughtGas: 0,\n            prevBlockNum: uint64(block.number)\n        });\n    }\n\n    /**\n     * @notice Meters access to a function based an amount of a requested resource.\n     *\n     * @param _amount Amount of the resource requested.\n     */\n    modifier metered(uint64 _amount) {\n        // Record initial gas amount so we can refund for it later.\n        uint256 initialGas = gasleft();\n\n        // Run the underlying function.\n        _;\n\n        // Update block number and base fee if necessary.\n        uint256 blockDiff = block.number - params.prevBlockNum;\n        if (blockDiff > 0) {\n            // Handle updating EIP-1559 style gas parameters. We use EIP-1559 to restrict the rate\n            // at which deposits can be created and therefore limit the potential for deposits to\n            // spam the L2 system. Fee scheme is very similar to EIP-1559 with minor changes.\n            int256 gasUsedDelta = int256(uint256(params.prevBoughtGas)) - TARGET_RESOURCE_LIMIT;\n            int256 baseFeeDelta = (int256(uint256(params.prevBaseFee)) * gasUsedDelta) /\n                TARGET_RESOURCE_LIMIT /\n                BASE_FEE_MAX_CHANGE_DENOMINATOR;\n\n            // Update base fee by adding the base fee delta and clamp the resulting value between\n            // min and max.\n            int256 newBaseFee = SignedMath.min(\n                SignedMath.max(\n                    int256(uint256(params.prevBaseFee)) + baseFeeDelta,\n                    int256(MINIMUM_BASE_FEE)\n                ),\n                int256(uint256(type(uint128).max))\n            );\n\n            // If we skipped more than one block, we also need to account for every empty block.\n            // Empty block means there was no demand for deposits in that block, so we should\n            // reflect this lack of demand in the fee.\n            if (blockDiff > 1) {\n                // Update the base fee by repeatedly applying the exponent 1-(1/change_denominator)\n                // blockDiff - 1 times. Simulates multiple empty blocks. Clamp the resulting value\n                // between min and max.\n                newBaseFee = SignedMath.min(\n                    SignedMath.max(\n                        int256(\n                            (newBaseFee *\n                                (\n                                    FixedPointMathLib.powWad(\n                                        1e18 - (1e18 / BASE_FEE_MAX_CHANGE_DENOMINATOR),\n                                        int256((blockDiff - 1) * 1e18)\n                                    )\n                                )) / 1e18\n                        ),\n                        int256(MINIMUM_BASE_FEE)\n                    ),\n                    int256(uint256(type(uint128).max))\n                );\n            }\n\n            // Update new base fee, reset bought gas, and update block number.\n            params.prevBaseFee = uint128(uint256(newBaseFee));\n            params.prevBoughtGas = 0;\n            params.prevBlockNum = uint64(block.number);\n        }\n\n        // Make sure we can actually buy the resource amount requested by the user.\n        params.prevBoughtGas += _amount;\n        require(\n            int256(uint256(params.prevBoughtGas)) <= MAX_RESOURCE_LIMIT,\n            \"OptimismPortal: cannot buy more gas than available gas limit\"\n        );\n\n        // Determine the amount of ETH to be paid.\n        uint256 resourceCost = _amount * params.prevBaseFee;\n\n        // We currently charge for this ETH amount as an L1 gas burn, so we convert the ETH amount\n        // into gas by dividing by the L1 base fee. We assume a minimum base fee of 1 gwei to avoid\n        // division by zero for L1s that don't support 1559 or to avoid excessive gas burns during\n        // periods of extremely low L1 demand. One-day average gas fee hasn't dipped below 1 gwei\n        // during any 1 day period in the last 5 years, so should be fine.\n        uint256 gasCost = resourceCost / Math.max(block.basefee, 1000000000);\n\n        // Give the user a refund based on the amount of gas they used to do all of the work up to\n        // this point. Since we're at the end of the modifier, this should be pretty accurate. Acts\n        // effectively like a dynamic stipend (with a minimum value).\n        uint256 usedGas = initialGas - gasleft();\n        if (gasCost > usedGas) {\n            Burn.gas(gasCost - usedGas);\n        }\n    }\n}\n"
    },
    "contracts/L2/DeployerWhitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @custom:legacy\n * @custom:proxied\n * @custom:predeployed 0x4200000000000000000000000000000000000002\n * @title DeployerWhitelist\n * @notice DeployerWhitelist is a legacy contract that was originally used to act as a whitelist of\n *         addresses allowed to the Optimism network. The DeployerWhitelist has since been\n *         disabled, but the code is kept in state for the sake of full backwards compatibility.\n *         As of the Bedrock upgrade, the DeployerWhitelist is completely unused by the Optimism\n *         system and could, in theory, be removed entirely.\n */\ncontract DeployerWhitelist {\n    /**\n     * @notice Emitted when the owner of this contract changes.\n     *\n     * @param oldOwner Address of the previous owner.\n     * @param newOwner Address of the new owner.\n     */\n    event OwnerChanged(address oldOwner, address newOwner);\n\n    /**\n     * @notice Emitted when the whitelist status of a deployer changes.\n     *\n     * @param deployer    Address of the deployer.\n     * @param whitelisted Boolean indicating whether the deployer is whitelisted.\n     */\n    event WhitelistStatusChanged(address deployer, bool whitelisted);\n\n    /**\n     * @notice Emitted when the whitelist is disabled.\n     *\n     * @param oldOwner Address of the final owner of the whitelist.\n     */\n    event WhitelistDisabled(address oldOwner);\n\n    /**\n     * @notice Address of the owner of this contract. Note that when this address is set to\n     *         address(0), the whitelist is disabled.\n     */\n    address public owner;\n\n    /**\n     * @notice Mapping of deployer addresses to boolean whitelist status.\n     */\n    mapping(address => bool) public whitelist;\n\n    /**\n     * @notice Blocks functions to anyone except the contract owner.\n     */\n    modifier onlyOwner() {\n        require(\n            msg.sender == owner,\n            \"DeployerWhitelist: function can only be called by the owner of this contract\"\n        );\n        _;\n    }\n\n    /**\n     * @notice Adds or removes an address from the deployment whitelist.\n     *\n     * @param _deployer      Address to update permissions for.\n     * @param _isWhitelisted Whether or not the address is whitelisted.\n     */\n    function setWhitelistedDeployer(address _deployer, bool _isWhitelisted) external onlyOwner {\n        whitelist[_deployer] = _isWhitelisted;\n        emit WhitelistStatusChanged(_deployer, _isWhitelisted);\n    }\n\n    /**\n     * @notice Updates the owner of this contract.\n     *\n     * @param _owner Address of the new owner.\n     */\n    function setOwner(address _owner) external onlyOwner {\n        // Prevent users from setting the whitelist owner to address(0) except via\n        // enableArbitraryContractDeployment. If you want to burn the whitelist owner, send it to\n        // any other address that doesn't have a corresponding knowable private key.\n        require(\n            _owner != address(0),\n            \"DeployerWhitelist: can only be disabled via enableArbitraryContractDeployment\"\n        );\n\n        emit OwnerChanged(owner, _owner);\n        owner = _owner;\n    }\n\n    /**\n     * @notice Permanently enables arbitrary contract deployment and deletes the owner.\n     */\n    function enableArbitraryContractDeployment() external onlyOwner {\n        emit WhitelistDisabled(owner);\n        owner = address(0);\n    }\n\n    /**\n     * @notice Checks whether an address is allowed to deploy contracts.\n     *\n     * @param _deployer Address to check.\n     *\n     * @return Whether or not the address can deploy contracts.\n     */\n    function isDeployerAllowed(address _deployer) external view returns (bool) {\n        return (owner == address(0) || whitelist[_deployer]);\n    }\n}\n"
    },
    "contracts/L2/GasPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Lib_PredeployAddresses } from \"../libraries/Lib_PredeployAddresses.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x420000000000000000000000000000000000000F\n * @title GasPriceOracle\n * @notice This contract maintains the variables responsible for computing the L1 portion of the\n *         total fee charged on L2. The values stored in the contract are looked up as part of the\n *         L2 state transition function and used to compute the total fee paid by the user. The\n *         contract exposes an API that is useful for knowing how large the L1 portion of their\n *         transaction fee will be.\n */\ncontract GasPriceOracle is Ownable {\n    /**\n     * @custom:legacy\n     * @notice Spacer for backwards compatibility.\n     */\n    uint256 internal spacer0;\n\n    /**\n     * @custom:legacy\n     * @notice Spacer for backwards compatibility.\n     */\n    uint256 internal spacer1;\n\n    /**\n     * @notice Constant L1 gas overhead per transaction.\n     */\n    uint256 public overhead;\n\n    /**\n     * @notice Dynamic L1 gas overhead per transaction.\n     */\n    uint256 public scalar;\n\n    /**\n     * @notice Number of decimals used in the scalar.\n     */\n    uint256 public decimals;\n\n    /**\n     * @param _owner Address that will initially own this contract.\n     */\n    constructor(address _owner) Ownable() {\n        transferOwnership(_owner);\n    }\n\n    /**\n     * @notice Emitted when the overhead value is updated.\n     */\n    event OverheadUpdated(uint256 overhead);\n\n    /**\n     * @notice Emitted when the scalar value is updated.\n     */\n    event ScalarUpdated(uint256 scalar);\n\n    /**\n     * @notice Emitted when the decimals value is updated.\n     */\n    event DecimalsUpdated(uint256 decimals);\n\n    /**\n     * @notice Retrieves the current gas price (base fee).\n     *\n     * @return Current L2 gas price (base fee).\n     */\n    function gasPrice() public returns (uint256) {\n        return block.basefee;\n    }\n\n    /**\n     * @notice Retrieves the current base fee.\n     *\n     * @return Current L2 base fee.\n     */\n    function baseFee() public returns (uint256) {\n        return block.basefee;\n    }\n\n    /**\n     * @notice Retrieves the latest known L1 base fee.\n     *\n     * @return Latest known L1 base fee.\n     */\n    function l1BaseFee() public view returns (uint256) {\n        return L1Block(Lib_PredeployAddresses.L1_BLOCK_ATTRIBUTES).basefee();\n    }\n\n    /**\n     * @notice Allows the owner to modify the overhead.\n     *\n     * @param _overhead New overhead value.\n     */\n    function setOverhead(uint256 _overhead) external onlyOwner {\n        overhead = _overhead;\n        emit OverheadUpdated(_overhead);\n    }\n\n    /**\n     * @notice Allows the owner to modify the scalar.\n     *\n     * @param _scalar New scalar value.\n     */\n    function setScalar(uint256 _scalar) external onlyOwner {\n        scalar = _scalar;\n        emit ScalarUpdated(_scalar);\n    }\n\n    /**\n     * @notice Allows the owner to modify the decimals.\n     *\n     * @param _decimals New decimals value.\n     */\n    function setDecimals(uint256 _decimals) external onlyOwner {\n        decimals = _decimals;\n        emit DecimalsUpdated(_decimals);\n    }\n\n    /**\n     * @notice Computes the L1 portion of the fee based on the size of the rlp encoded input\n     *         transaction, the current L1 base fee, and the various dynamic parameters.\n     *\n     * @param _data Unsigned fully RLP-encoded transaction to get the L1 fee for.\n     *\n     * @return L1 fee that should be paid for the tx\n     */\n    function getL1Fee(bytes memory _data) external view returns (uint256) {\n        uint256 l1GasUsed = getL1GasUsed(_data);\n        uint256 l1Fee = l1GasUsed * l1BaseFee();\n        uint256 divisor = 10**decimals;\n        uint256 unscaled = l1Fee * scalar;\n        uint256 scaled = unscaled / divisor;\n        return scaled;\n    }\n\n    /**\n     * @notice Computes the amount of L1 gas used for a transaction. Adds the overhead which\n     *         represents the per-transaction gas overhead of posting the transaction and state\n     *         roots to L1. Adds 68 bytes of padding to account for the fact that the input does\n     *         not have a signature.\n     *\n     * @param _data Unsigned fully RLP-encoded transaction to get the L1 gas for.\n     *\n     * @return Amount of L1 gas used to publish the transaction.\n     */\n    function getL1GasUsed(bytes memory _data) public view returns (uint256) {\n        uint256 total = 0;\n        uint256 length = _data.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (_data[i] == 0) {\n                total += 4;\n            } else {\n                total += 16;\n            }\n        }\n        uint256 unsigned = total + overhead;\n        return unsigned + (68 * 16);\n    }\n}\n"
    },
    "contracts/L2/L1Block.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000015\n * @title L1Block\n * @notice The L1Block predeploy gives users access to information about the last known L1 block.\n *         Values within this contract are updated once per epoch (every L1 block) and can only be\n *         set by the \"depositor\" account, a special system address. Depositor account transactions\n *         are created by the protocol whenever we move to a new epoch.\n */\ncontract L1Block {\n    /**\n     * @notice Address of the special depositor account.\n     */\n    address public constant DEPOSITOR_ACCOUNT = 0xDeaDDEaDDeAdDeAdDEAdDEaddeAddEAdDEAd0001;\n\n    /**\n     * @notice The latest L1 block number known by the L2 system.\n     */\n    uint64 public number;\n\n    /**\n     * @notice The latest L1 timestamp known by the L2 system.\n     */\n    uint64 public timestamp;\n\n    /**\n     * @notice The latest L1 basefee.\n     */\n    uint256 public basefee;\n\n    /**\n     * @notice The latest L1 blockhash.\n     */\n    bytes32 public hash;\n\n    /**\n     * @notice The number of L2 blocks in the same epoch.\n     */\n    uint64 public sequenceNumber;\n\n    /**\n     * @notice Updates the L1 block values.\n     *\n     * @param _number         L1 blocknumber.\n     * @param _timestamp      L1 timestamp.\n     * @param _basefee        L1 basefee.\n     * @param _hash           L1 blockhash.\n     * @param _sequenceNumber Number of L2 blocks since epoch start.\n     */\n    function setL1BlockValues(\n        uint64 _number,\n        uint64 _timestamp,\n        uint256 _basefee,\n        bytes32 _hash,\n        uint64 _sequenceNumber\n    ) external {\n        require(\n            msg.sender == DEPOSITOR_ACCOUNT,\n            \"L1Block: only the depositor account can set L1 block values\"\n        );\n\n        number = _number;\n        timestamp = _timestamp;\n        basefee = _basefee;\n        hash = _hash;\n        sequenceNumber = _sequenceNumber;\n    }\n}\n"
    },
    "contracts/L2/L1BlockNumber.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { L1Block } from \"./L1Block.sol\";\nimport { Lib_PredeployAddresses } from \"../libraries/Lib_PredeployAddresses.sol\";\n\n/**\n * @custom:legacy\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000013\n * @title L1BlockNumber\n * @notice L1BlockNumber is a legacy contract that fills the roll of the OVM_L1BlockNumber contract\n *         in the old version of the Optimism system. Only necessary for backwards compatibility.\n *         If you want to access the L1 block number going forward, you should use the L1Block\n *         contract instead.\n */\ncontract L1BlockNumber {\n    /**\n     * @notice Returns the L1 block number.\n     */\n    receive() external payable {\n        uint256 l1BlockNumber = getL1BlockNumber();\n        assembly {\n            mstore(0, l1BlockNumber)\n            return(0, 32)\n        }\n    }\n\n    /**\n     * @notice Returns the L1 block number.\n     */\n    fallback() external payable {\n        uint256 l1BlockNumber = getL1BlockNumber();\n        assembly {\n            mstore(0, l1BlockNumber)\n            return(0, 32)\n        }\n    }\n\n    /**\n     * @notice Retrieves the latest L1 block number.\n     *\n     * @return Latest L1 block number.\n     */\n    function getL1BlockNumber() public view returns (uint256) {\n        return L1Block(Lib_PredeployAddresses.L1_BLOCK_ATTRIBUTES).number();\n    }\n}\n"
    },
    "contracts/L2/L2CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { AddressAliasHelper } from \"../libraries/AddressAliasHelper.sol\";\nimport { Lib_PredeployAddresses } from \"../libraries/Lib_PredeployAddresses.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { L2ToL1MessagePasser } from \"./L2ToL1MessagePasser.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000007\n * @title L2CrossDomainMessenger\n * @notice The L2CrossDomainMessenger is a high-level interface for message passing between L1 and\n *         L2 on the L2 side. Users are generally encouraged to use this contract instead of lower\n *         level message passing contracts.\n */\ncontract L2CrossDomainMessenger is CrossDomainMessenger {\n    /**\n     * @notice Initializes the L2CrossDomainMessenger.\n     *\n     * @param _l1CrossDomainMessenger Address of the L1CrossDomainMessenger contract.\n     */\n    function initialize(address _l1CrossDomainMessenger) external initializer {\n        address[] memory blockedSystemAddresses = new address[](2);\n        blockedSystemAddresses[0] = address(this);\n        blockedSystemAddresses[1] = Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER;\n\n        _initialize(_l1CrossDomainMessenger, blockedSystemAddresses);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Legacy getter for the remote messenger. Use otherMessenger going forward.\n     *\n     * @return Address of the L1CrossDomainMessenger contract.\n     */\n    function l1CrossDomainMessenger() public returns (address) {\n        return otherMessenger;\n    }\n\n    /**\n     * @notice Checks that the message sender is the L1CrossDomainMessenger on L1.\n     *\n     * @return True if the message sender is the L1CrossDomainMessenger on L1.\n     */\n    function _isSystemMessageSender() internal view override returns (bool) {\n        return AddressAliasHelper.undoL1ToL2Alias(msg.sender) == otherMessenger;\n    }\n\n    /**\n     * @notice Sends a message from L2 to L1.\n     *\n     * @param _to       Address to send the message to.\n     * @param _gasLimit Minimum gas limit to execute the message with.\n     * @param _value    ETH value to send with the message.\n     * @param _data     Data to trigger the recipient with.\n     */\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal override {\n        L2ToL1MessagePasser(payable(Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER))\n            .initiateWithdrawal{ value: _value }(_to, _gasLimit, _data);\n    }\n}\n"
    },
    "contracts/L2/L2StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { Lib_PredeployAddresses } from \"../libraries/Lib_PredeployAddresses.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { OptimismMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000010\n * @title L2StandardBridge\n * @notice The L2StandardBridge is responsible for transfering ETH and ERC20 tokens between L1 and\n *         L2. ERC20 tokens sent to L1 are escrowed within this contract.\n *         Note that this contract is not intended to support all variations of ERC20 tokens.\n *         Examples of some token types that may not be properly supported by this contract include,\n *         but are not limited to: tokens with transfer fees, rebasing tokens, and\n *         tokens with blocklists.\n *         TODO: ensure that this has 1:1 backwards compatibility\n */\ncontract L2StandardBridge is StandardBridge {\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever a withdrawal from L2 to L1 is initiated.\n     *\n     * @param _l1Token   Address of the token on L1.\n     * @param _l2Token   Address of the corresponding token on L2.\n     * @param _from      Address of the withdrawer.\n     * @param _to        Address of the recipient on L1.\n     * @param _amount    Amount of the ERC20 withdrawn.\n     * @param _extraData Extra data attached to the withdrawal.\n     */\n    event WithdrawalInitiated(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _extraData\n    );\n\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever an ERC20 deposit is finalized.\n     *\n     * @param _l1Token   Address of the token on L1.\n     * @param _l2Token   Address of the corresponding token on L2.\n     * @param _from      Address of the depositor.\n     * @param _to        Address of the recipient on L2.\n     * @param _amount    Amount of the ERC20 deposited.\n     * @param _extraData Extra data attached to the deposit.\n     */\n    event DepositFinalized(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _extraData\n    );\n\n    /**\n     * @custom:legacy\n     * @notice Emitted whenever a deposit fails.\n     *\n     * @param _l1Token   Address of the token on L1.\n     * @param _l2Token   Address of the corresponding token on L2.\n     * @param _from      Address of the depositor.\n     * @param _to        Address of the recipient on L2.\n     * @param _amount    Amount of the ERC20 deposited.\n     * @param _extraData Extra data attached to the deposit.\n     */\n    event DepositFailed(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _extraData\n    );\n\n    /**\n     * @notice Initializes the L2StandardBridge.\n     *\n     * @param _otherBridge Address of the L1StandardBridge.\n     */\n    function initialize(address payable _otherBridge) public {\n        _initialize(payable(Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER), _otherBridge);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Initiates a withdrawal from L2 to L1.\n     *\n     * @param _l2Token     Address of the L2 token to withdraw.\n     * @param _amount      Amount of the L2 token to withdraw.\n     * @param _minGasLimit Minimum gas limit to use for the transaction.\n     * @param _extraData   Extra data attached to the withdrawal.\n     */\n    function withdraw(\n        address _l2Token,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external payable virtual onlyEOA {\n        _initiateWithdrawal(_l2Token, msg.sender, msg.sender, _amount, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Initiates a withdrawal from L2 to L1 to a target account on L1.\n     *         Note that if ETH is sent to a contract on L1 and the call fails, then that ETH will\n     *         be locked in the L1StandardBridge. ETH may be recoverable if the call can be\n     *         successfully replayed by increasing the amount of gas supplied to the call. If the\n     *         call will fail for any amount of gas, then the ETH will be locked permanently.\n     *\n     * @param _l2Token     Address of the L2 token to withdraw.\n     * @param _to          Recipient account on L1.\n     * @param _amount      Amount of the L2 token to withdraw.\n     * @param _minGasLimit Minimum gas limit to use for the transaction.\n     * @param _extraData   Extra data attached to the withdrawal.\n     */\n    function withdrawTo(\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) external payable virtual {\n        _initiateWithdrawal(_l2Token, msg.sender, _to, _amount, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Finalizes a deposit from L1 to L2.\n     *\n     * @param _l1Token   Address of the L1 token to deposit.\n     * @param _l2Token   Address of the corresponding L2 token.\n     * @param _from      Address of the depositor.\n     * @param _to        Address of the recipient.\n     * @param _amount    Amount of the tokens being deposited.\n     * @param _extraData Extra data attached to the deposit.\n     */\n    function finalizeDeposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) external payable virtual {\n        if (_l1Token == address(0) && _l2Token == Lib_PredeployAddresses.OVM_ETH) {\n            finalizeBridgeETH(_from, _to, _amount, _extraData);\n        } else {\n            finalizeBridgeERC20(_l2Token, _l1Token, _from, _to, _amount, _extraData);\n        }\n        emit DepositFinalized(_l1Token, _l2Token, _from, _to, _amount, _extraData);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Internal function to a withdrawal from L2 to L1 to a target account on L1.\n     *\n     * @param _l2Token     Address of the L2 token to withdraw.\n     * @param _from        Address of the withdrawer.\n     * @param _to          Recipient account on L1.\n     * @param _amount      Amount of the L2 token to withdraw.\n     * @param _minGasLimit Minimum gas limit to use for the transaction.\n     * @param _extraData   Extra data attached to the withdrawal.\n     */\n    function _initiateWithdrawal(\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal {\n        address l1Token = OptimismMintableERC20(_l2Token).l1Token();\n        if (_l2Token == Lib_PredeployAddresses.OVM_ETH) {\n            require(msg.value == _amount, \"ETH withdrawals must include sufficient ETH value.\");\n            _initiateBridgeETH(_from, _to, _amount, _minGasLimit, _extraData);\n        } else {\n            _initiateBridgeERC20(_l2Token, l1Token, _from, _to, _amount, _minGasLimit, _extraData);\n        }\n        emit WithdrawalInitiated(l1Token, _l2Token, _from, _to, _amount, _extraData);\n    }\n}\n"
    },
    "contracts/L2/L2ToL1MessagePasser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { WithdrawalVerifier } from \"../libraries/Lib_WithdrawalVerifier.sol\";\nimport { Burn } from \"../libraries/Burn.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000000\n * @title L2ToL1MessagePasser\n * @notice The L2ToL1MessagePasser is a dedicated contract where messages that are being sent from\n *         L2 to L1 can be stored. The storage root of this contract is pulled up to the top level\n *         of the L2 output to reduce the cost of proving the existence of sent messages.\n */\ncontract L2ToL1MessagePasser {\n    /**\n     * @notice Emitted any time a withdrawal is initiated.\n     *\n     * @param nonce    Unique value corresponding to each withdrawal.\n     * @param sender   The L2 account address which initiated the withdrawal.\n     * @param target   The L1 account address the call will be send to.\n     * @param value    The ETH value submitted for withdrawal, to be forwarded to the target.\n     * @param gasLimit The minimum amount of gas that must be provided when withdrawing on L1.\n     * @param data     The data to be forwarded to the target on L1.\n     */\n    event WithdrawalInitiated(\n        uint256 indexed nonce,\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    /**\n     * @notice Emitted when the balance of this contract is burned.\n     *\n     * @param amount Amount of ETh that was burned.\n     */\n    event WithdrawerBalanceBurnt(uint256 indexed amount);\n\n    /**\n     * @notice The L1 gas limit set when eth is withdrawn using the receive() function.\n     */\n    uint256 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 100_000;\n\n    /**\n     * @notice Includes the message hashes for all withdrawals\n     */\n    mapping(bytes32 => bool) public sentMessages;\n\n    /**\n     * @notice A unique value hashed with each withdrawal.\n     */\n    uint256 public nonce;\n\n    /**\n     * @notice Allows users to withdraw ETH by sending directly to this contract.\n     */\n    receive() external payable {\n        initiateWithdrawal(msg.sender, RECEIVE_DEFAULT_GAS_LIMIT, bytes(\"\"));\n    }\n\n    /**\n     * @notice Sends a message from L2 to L1.\n     *\n     * @param _target   Address to call on L1 execution.\n     * @param _gasLimit Minimum gas limit for executing the message on L1.\n     * @param _data     Data to forward to L1 target.\n     */\n    function initiateWithdrawal(\n        address _target,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) public payable {\n        bytes32 withdrawalHash = WithdrawalVerifier.withdrawalHash(\n            nonce,\n            msg.sender,\n            _target,\n            msg.value,\n            _gasLimit,\n            _data\n        );\n\n        sentMessages[withdrawalHash] = true;\n\n        emit WithdrawalInitiated(nonce, msg.sender, _target, msg.value, _gasLimit, _data);\n        unchecked {\n            ++nonce;\n        }\n    }\n\n    /**\n     * @notice Removes all ETH held by this contract from the state. Used to prevent the amount of\n     *         ETH on L2 inflating when ETH is withdrawn. Currently only way to do this is to\n     *         create a contract and self-destruct it to itself. Anyone can call this function. Not\n     *         incentivized since this function is very cheap.\n     */\n    function burn() external {\n        uint256 balance = address(this).balance;\n        Burn.eth(balance);\n        emit WithdrawerBalanceBurnt(balance);\n    }\n}\n"
    },
    "contracts/L2/OVM_ETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_PredeployAddresses } from \"../libraries/Lib_PredeployAddresses.sol\";\n\n/* Contract Imports */\nimport { OptimismMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\n\n/**\n * @custom:legacy\n * @custom:proxied\n * @custom:predeploy 0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000\n * @title OVM_ETH\n * @notice OVM_ETH is a legacy contract that held ETH balances before the Bedrock upgrade. All\n *         ETH balances held within this contract were migrated to the state trie as part of the\n *         Bedrock upgrade. Functions within this contract that mutate state were already disabled\n *         as part of the EVM equivalence upgrade.\n */\ncontract OVM_ETH is OptimismMintableERC20 {\n    /**\n     * @notice Initializes the contract as an Optimism Mintable ERC20.\n     */\n    constructor()\n        OptimismMintableERC20(Lib_PredeployAddresses.L2_STANDARD_BRIDGE, address(0), \"Ether\", \"ETH\")\n    {}\n\n    /**\n     * @notice Mints some amount of ETH.\n     *\n     * @param _to     Address of the recipient.\n     * @param _amount Amount of ETH to mint.\n     */\n    function mint(address _to, uint256 _amount) public virtual override {\n        revert(\"OVM_ETH: mint is disabled\");\n    }\n\n    /**\n     * @notice Burns some amount of ETH.\n     *\n     * @param _from   Address to burn from.\n     * @param _amount Amount of ETH to burn.\n     */\n    function burn(address _from, uint256 _amount) public virtual override {\n        revert(\"OVM_ETH: burn is disabled\");\n    }\n\n    /**\n     * @notice Transfers some amount of ETH.\n     *\n     * @param _recipient Address to send to.\n     * @param _amount    Amount of ETH to send.\n     */\n    function transfer(address _recipient, uint256 _amount) public virtual override returns (bool) {\n        revert(\"OVM_ETH: transfer is disabled\");\n    }\n\n    /**\n     * @notice Approves a spender to spend some amount of ETH.\n     *\n     * @param _spender Address of the spender.\n     * @param _amount  Amount of ETH to approve.\n     */\n    function approve(address _spender, uint256 _amount) public virtual override returns (bool) {\n        revert(\"OVM_ETH: approve is disabled\");\n    }\n\n    /**\n     * @notice Transfers funds from some sender account.\n     *\n     * @param _sender    Address of the sender.\n     * @param _recipient Address of the recipient.\n     * @param _amount    Amount of ETH to transfer.\n     */\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) public virtual override returns (bool) {\n        revert(\"OVM_ETH: transferFrom is disabled\");\n    }\n\n    /**\n     * @notice Increases the allowance of a spender.\n     *\n     * @param _spender    Address of the spender.\n     * @param _addedValue Amount of ETH to increase the allowance by.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        revert(\"OVM_ETH: increaseAllowance is disabled\");\n    }\n\n    /**\n     * @notice Decreases the allowance of a spender.\n     *\n     * @param _spender         Address of the spender.\n     * @param _subtractedValue Amount of ETH to decrease the allowance by.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        revert(\"OVM_ETH: decreaseAllowance is disabled\");\n    }\n}\n"
    },
    "contracts/L2/SequencerFeeVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_PredeployAddresses } from \"../libraries/Lib_PredeployAddresses.sol\";\n\n/* Contract Imports */\nimport { L2StandardBridge } from \"./L2StandardBridge.sol\";\n\n/**\n * @custom:proxied\n * @custom:predeploy 0x4200000000000000000000000000000000000011\n * @title SequencerFeeVault\n * @notice The SequencerFeeVault is the contract that holds any fees paid to the Sequencer during\n *         transaction processing and block production.\n */\ncontract SequencerFeeVault {\n    /**\n     * @notice Minimum balance before a withdrawal can be triggered.\n     */\n    uint256 public constant MIN_WITHDRAWAL_AMOUNT = 15 ether;\n\n    /**\n     * @notice Wallet that will receive the fees on L1.\n     */\n    address public l1FeeWallet;\n\n    /**\n     * @notice Allow the contract to receive ETH.\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Triggers a withdrawal of funds to the L1 fee wallet.\n     */\n    function withdraw() external {\n        require(\n            address(this).balance >= MIN_WITHDRAWAL_AMOUNT,\n            // solhint-disable-next-line max-line-length\n            \"OVM_SequencerFeeVault: withdrawal amount must be greater than minimum withdrawal amount\"\n        );\n\n        uint256 balance = address(this).balance;\n\n        L2StandardBridge(payable(Lib_PredeployAddresses.L2_STANDARD_BRIDGE)).withdrawTo{\n            value: balance\n        }(Lib_PredeployAddresses.OVM_ETH, l1FeeWallet, balance, 0, bytes(\"\"));\n    }\n}\n"
    },
    "contracts/legacy/L1ChugSplashProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title iL1ChugSplashDeployer\n */\ninterface iL1ChugSplashDeployer {\n    function isUpgrading() external view returns (bool);\n}\n\n/**\n * @title L1ChugSplashProxy\n * @dev Basic ChugSplash proxy contract for L1. Very close to being a normal proxy but has added\n * functions `setCode` and `setStorage` for changing the code or storage of the contract. Nifty!\n *\n * Note for future developers: do NOT make anything in this contract 'public' unless you know what\n * you're doing. Anything public can potentially have a function signature that conflicts with a\n * signature attached to the implementation contract. Public functions SHOULD always have the\n * 'proxyCallIfNotOwner' modifier unless there's some *really* good reason not to have that\n * modifier. And there almost certainly is not a good reason to not have that modifier. Beware!\n */\ncontract L1ChugSplashProxy {\n    /*************\n     * Constants *\n     *************/\n\n    // \"Magic\" prefix. When prepended to some arbitrary bytecode and used to create a contract, the\n    // appended bytecode will be deployed as given.\n    bytes13 internal constant DEPLOY_CODE_PREFIX = 0x600D380380600D6000396000f3;\n\n    // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n    bytes32 internal constant IMPLEMENTATION_KEY =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    // bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\n    bytes32 internal constant OWNER_KEY =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _owner Address of the initial contract owner.\n     */\n    constructor(address _owner) {\n        _setOwner(_owner);\n    }\n\n    /**********************\n     * Function Modifiers *\n     **********************/\n\n    /**\n     * Blocks a function from being called when the parent signals that the system should be paused\n     * via an isUpgrading function.\n     */\n    modifier onlyWhenNotPaused() {\n        address owner = _getOwner();\n\n        // We do a low-level call because there's no guarantee that the owner actually *is* an\n        // L1ChugSplashDeployer contract and Solidity will throw errors if we do a normal call and\n        // it turns out that it isn't the right type of contract.\n        (bool success, bytes memory returndata) = owner.staticcall(\n            abi.encodeWithSelector(iL1ChugSplashDeployer.isUpgrading.selector)\n        );\n\n        // If the call was unsuccessful then we assume that there's no \"isUpgrading\" method and we\n        // can just continue as normal. We also expect that the return value is exactly 32 bytes\n        // long. If this isn't the case then we can safely ignore the result.\n        if (success && returndata.length == 32) {\n            // Although the expected value is a *boolean*, it's safer to decode as a uint256 in the\n            // case that the isUpgrading function returned something other than 0 or 1. But we only\n            // really care about the case where this value is 0 (= false).\n            uint256 ret = abi.decode(returndata, (uint256));\n            require(ret == 0, \"L1ChugSplashProxy: system is currently being upgraded\");\n        }\n\n        _;\n    }\n\n    /**\n     * Makes a proxy call instead of triggering the given function when the caller is either the\n     * owner or the zero address. Caller can only ever be the zero address if this function is\n     * being called off-chain via eth_call, which is totally fine and can be convenient for\n     * client-side tooling. Avoids situations where the proxy and implementation share a sighash\n     * and the proxy function ends up being called instead of the implementation one.\n     *\n     * Note: msg.sender == address(0) can ONLY be triggered off-chain via eth_call. If there's a\n     * way for someone to send a transaction with msg.sender == address(0) in any real context then\n     * we have much bigger problems. Primary reason to include this additional allowed sender is\n     * because the owner address can be changed dynamically and we do not want clients to have to\n     * keep track of the current owner in order to make an eth_call that doesn't trigger the\n     * proxied contract.\n     */\n    // slither-disable-next-line incorrect-modifier\n    modifier proxyCallIfNotOwner() {\n        if (msg.sender == _getOwner() || msg.sender == address(0)) {\n            _;\n        } else {\n            // This WILL halt the call frame on completion.\n            _doProxyCall();\n        }\n    }\n\n    /*********************\n     * Fallback Function *\n     *********************/\n\n    // slither-disable-next-line locked-ether\n    fallback() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sets the code that should be running behind this proxy. Note that this scheme is a bit\n     * different from the standard proxy scheme where one would typically deploy the code\n     * separately and then set the implementation address. We're doing it this way because it gives\n     * us a lot more freedom on the client side. Can only be triggered by the contract owner.\n     * @param _code New contract code to run inside this contract.\n     */\n    // slither-disable-next-line external-function\n    function setCode(bytes memory _code) public proxyCallIfNotOwner {\n        // Get the code hash of the current implementation.\n        address implementation = _getImplementation();\n\n        // If the code hash matches the new implementation then we return early.\n        if (keccak256(_code) == _getAccountCodeHash(implementation)) {\n            return;\n        }\n\n        // Create the deploycode by appending the magic prefix.\n        bytes memory deploycode = abi.encodePacked(DEPLOY_CODE_PREFIX, _code);\n\n        // Deploy the code and set the new implementation address.\n        address newImplementation;\n        assembly {\n            newImplementation := create(0x0, add(deploycode, 0x20), mload(deploycode))\n        }\n\n        // Check that the code was actually deployed correctly. I'm not sure if you can ever\n        // actually fail this check. Should only happen if the contract creation from above runs\n        // out of gas but this parent execution thread does NOT run out of gas. Seems like we\n        // should be doing this check anyway though.\n        require(\n            _getAccountCodeHash(newImplementation) == keccak256(_code),\n            \"L1ChugSplashProxy: code was not correctly deployed.\"\n        );\n\n        _setImplementation(newImplementation);\n    }\n\n    /**\n     * Modifies some storage slot within the proxy contract. Gives us a lot of power to perform\n     * upgrades in a more transparent way. Only callable by the owner.\n     * @param _key Storage key to modify.\n     * @param _value New value for the storage key.\n     */\n    // slither-disable-next-line external-function\n    function setStorage(bytes32 _key, bytes32 _value) public proxyCallIfNotOwner {\n        assembly {\n            sstore(_key, _value)\n        }\n    }\n\n    /**\n     * Changes the owner of the proxy contract. Only callable by the owner.\n     * @param _owner New owner of the proxy contract.\n     */\n    // slither-disable-next-line external-function\n    function setOwner(address _owner) public proxyCallIfNotOwner {\n        _setOwner(_owner);\n    }\n\n    /**\n     * Queries the owner of the proxy contract. Can only be called by the owner OR by making an\n     * eth_call and setting the \"from\" address to address(0).\n     * @return Owner address.\n     */\n    // slither-disable-next-line external-function\n    function getOwner() public proxyCallIfNotOwner returns (address) {\n        return _getOwner();\n    }\n\n    /**\n     * Queries the implementation address. Can only be called by the owner OR by making an\n     * eth_call and setting the \"from\" address to address(0).\n     * @return Implementation address.\n     */\n    // slither-disable-next-line external-function\n    function getImplementation() public proxyCallIfNotOwner returns (address) {\n        return _getImplementation();\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Sets the implementation address.\n     * @param _implementation New implementation address.\n     */\n    function _setImplementation(address _implementation) internal {\n        assembly {\n            sstore(IMPLEMENTATION_KEY, _implementation)\n        }\n    }\n\n    /**\n     * Queries the implementation address.\n     * @return Implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        address implementation;\n        assembly {\n            implementation := sload(IMPLEMENTATION_KEY)\n        }\n        return implementation;\n    }\n\n    /**\n     * Changes the owner of the proxy contract.\n     * @param _owner New owner of the proxy contract.\n     */\n    function _setOwner(address _owner) internal {\n        assembly {\n            sstore(OWNER_KEY, _owner)\n        }\n    }\n\n    /**\n     * Queries the owner of the proxy contract.\n     * @return Owner address.\n     */\n    function _getOwner() internal view returns (address) {\n        address owner;\n        assembly {\n            owner := sload(OWNER_KEY)\n        }\n        return owner;\n    }\n\n    /**\n     * Gets the code hash for a given account.\n     * @param _account Address of the account to get a code hash for.\n     * @return Code hash for the account.\n     */\n    function _getAccountCodeHash(address _account) internal view returns (bytes32) {\n        bytes32 codeHash;\n        assembly {\n            codeHash := extcodehash(_account)\n        }\n        return codeHash;\n    }\n\n    /**\n     * Performs the proxy call via a delegatecall.\n     */\n    function _doProxyCall() internal onlyWhenNotPaused {\n        address implementation = _getImplementation();\n\n        require(implementation != address(0), \"L1ChugSplashProxy: implementation is not set yet\");\n\n        assembly {\n            // Copy calldata into memory at 0x0....calldatasize.\n            calldatacopy(0x0, 0x0, calldatasize())\n\n            // Perform the delegatecall, make sure to pass all available gas.\n            let success := delegatecall(gas(), implementation, 0x0, calldatasize(), 0x0, 0x0)\n\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\n            // overwrite the calldata that we just copied into memory but that doesn't really\n            // matter because we'll be returning in a second anyway.\n            returndatacopy(0x0, 0x0, returndatasize())\n\n            // Success == 0 means a revert. We'll revert too and pass the data up.\n            if iszero(success) {\n                revert(0x0, returndatasize())\n            }\n\n            // Otherwise we'll just return and pass the data up.\n            return(0x0, returndatasize())\n        }\n    }\n}\n"
    },
    "contracts/legacy/Lib_AddressManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* External Imports */\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title Lib_AddressManager\n */\ncontract Lib_AddressManager is Ownable {\n    /**********\n     * Events *\n     **********/\n\n    event AddressSet(string indexed _name, address _newAddress, address _oldAddress);\n\n    /*************\n     * Variables *\n     *************/\n\n    mapping(bytes32 => address) private addresses;\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Changes the address associated with a particular name.\n     * @param _name String name to associate an address with.\n     * @param _address Address to associate with the name.\n     */\n    function setAddress(string memory _name, address _address) external onlyOwner {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(_name, _address, oldAddress);\n    }\n\n    /**\n     * Retrieves the address associated with a given name.\n     * @param _name Name to retrieve an address for.\n     * @return Address associated with the given name.\n     */\n    function getAddress(string memory _name) external view returns (address) {\n        return addresses[_getNameHash(_name)];\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Computes the hash of a name.\n     * @param _name Name to compute a hash for.\n     * @return Hash of the given name.\n     */\n    function _getNameHash(string memory _name) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_name));\n    }\n}\n"
    },
    "contracts/legacy/Lib_AddressResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_AddressManager } from \"./Lib_AddressManager.sol\";\n\n/**\n * @title Lib_AddressResolver\n */\nabstract contract Lib_AddressResolver {\n    /*************\n     * Variables *\n     *************/\n\n    Lib_AddressManager public libAddressManager;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _libAddressManager Address of the Lib_AddressManager.\n     */\n    constructor(address _libAddressManager) {\n        libAddressManager = Lib_AddressManager(_libAddressManager);\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Resolves the address associated with a given name.\n     * @param _name Name to resolve an address for.\n     * @return Address associated with the given name.\n     */\n    function resolve(string memory _name) public view returns (address) {\n        return libAddressManager.getAddress(_name);\n    }\n}\n"
    },
    "contracts/legacy/Lib_ResolvedDelegateProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { Lib_AddressManager } from \"./Lib_AddressManager.sol\";\n\n/**\n * @title Lib_ResolvedDelegateProxy\n */\ncontract Lib_ResolvedDelegateProxy {\n    /*************\n     * Variables *\n     *************/\n\n    // Using mappings to store fields to avoid overwriting storage slots in the\n    // implementation contract. For example, instead of storing these fields at\n    // storage slot `0` & `1`, they are stored at `keccak256(key + slot)`.\n    // See: https://solidity.readthedocs.io/en/v0.7.0/internals/layout_in_storage.html\n    // NOTE: Do not use this code in your own contract system.\n    //      There is a known flaw in this contract, and we will remove it from the repository\n    //      in the near future. Due to the very limited way that we are using it, this flaw is\n    //      not an issue in our system.\n    mapping(address => string) private implementationName;\n    mapping(address => Lib_AddressManager) private addressManager;\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _libAddressManager Address of the Lib_AddressManager.\n     * @param _implementationName implementationName of the contract to proxy to.\n     */\n    constructor(address _libAddressManager, string memory _implementationName) {\n        addressManager[address(this)] = Lib_AddressManager(_libAddressManager);\n        implementationName[address(this)] = _implementationName;\n    }\n\n    /*********************\n     * Fallback Function *\n     *********************/\n\n    fallback() external payable {\n        address target = addressManager[address(this)].getAddress(\n            (implementationName[address(this)])\n        );\n\n        require(target != address(0), \"Target address must be initialized.\");\n\n        // slither-disable-next-line controlled-delegatecall\n        (bool success, bytes memory returndata) = target.delegatecall(msg.data);\n\n        if (success == true) {\n            assembly {\n                return(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            assembly {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/AddressAliasHelper.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity ^0.8.7;\n\nlibrary AddressAliasHelper {\n    uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + offset);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - offset);\n        }\n    }\n}\n"
    },
    "contracts/libraries/Burn.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/**\n * @title Burner\n * @notice Burner self-destructs on creation and sends all ETH to itself, removing all ETH given to\n * the contract from the circulating supply.\n */\ncontract Burner {\n    constructor() payable {\n        selfdestruct(payable(address(this)));\n    }\n}\n\n/**\n * @title Burn\n * @notice Utilities for burning stuff.\n */\nlibrary Burn {\n    /**\n     * Burns a given amount of ETH.\n     *\n     * @param _amount Amount of ETH to burn.\n     */\n    function eth(uint256 _amount) internal {\n        new Burner{ value: _amount }();\n    }\n\n    /**\n     * Burns a given amount of gas.\n     *\n     * @param _amount Amount of gas to burn.\n     */\n    function gas(uint256 _amount) internal {\n        uint256 i = 0;\n        uint256 initialGas = gasleft();\n        while (initialGas - gasleft() < _amount) {\n            ++i;\n        }\n    }\n}\n"
    },
    "contracts/libraries/Lib_BytesUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_BytesUtils\n */\nlibrary Lib_BytesUtils {\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_start + _length >= _start, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\n        if (_start >= _bytes.length) {\n            return bytes(\"\");\n        }\n\n        return slice(_bytes, _start, _bytes.length - _start);\n    }\n\n    function toBytes32(bytes memory _bytes) internal pure returns (bytes32) {\n        if (_bytes.length < 32) {\n            bytes32 ret;\n            assembly {\n                ret := mload(add(_bytes, 32))\n            }\n            return ret;\n        }\n\n        return abi.decode(_bytes, (bytes32)); // will truncate if input length > 32 bytes\n    }\n\n    function toUint256(bytes memory _bytes) internal pure returns (uint256) {\n        return uint256(toBytes32(_bytes));\n    }\n\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\n        bytes memory nibbles = new bytes(_bytes.length * 2);\n\n        for (uint256 i = 0; i < _bytes.length; i++) {\n            nibbles[i * 2] = _bytes[i] >> 4;\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\n        }\n\n        return nibbles;\n    }\n\n    function fromNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\n        bytes memory ret = new bytes(_bytes.length / 2);\n\n        for (uint256 i = 0; i < ret.length; i++) {\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\n        }\n\n        return ret;\n    }\n\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\n        return keccak256(_bytes) == keccak256(_other);\n    }\n}\n"
    },
    "contracts/libraries/Lib_CrossDomainHashing.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { Lib_CrossDomainUtils } from \"./Lib_CrossDomainUtils.sol\";\nimport { Lib_RLPWriter } from \"./rlp/Lib_RLPWriter.sol\";\n\n/**\n * @title CrossDomainHashing\n * This library is responsible for holding cross domain utility\n * functions.\n * TODO(tynes): merge with Lib_CrossDomainUtils\n * TODO(tynes): fill out more devdocs\n */\nlibrary CrossDomainHashing {\n    /**\n     * @notice Compute the L2 transaction hash given\n     * data about an L1 deposit transaction. This is useful for\n     * environments that do not have access to arbitrary\n     * RLP encoding functionality but have access to the\n     * standard web3 API\n     * TODO: rearrange args in a sane way\n     * @param _l1BlockHash The L1 block hash corresponding to the block\n     * the deposit was included in\n     * @param _logIndex The log index of the event that the deposit was\n     * created from. This can be found on the transaction receipt\n     * @param _from The sender of the deposit\n     * @param _to The L2 contract to be called by the deposit transaction\n     * @param _isCreate Indicates if the deposit creates a contract\n     * @param _mint The amount of ETH being minted by the transaction\n     * @param _value The amount of ETH send in the L2 call\n     * @param _gas The gas limit for the L2 call\n     */\n    function L2TransactionHash(\n        bytes32 _l1BlockHash,\n        uint256 _logIndex,\n        address _from,\n        address _to,\n        bool _isCreate,\n        uint256 _mint,\n        uint256 _value,\n        uint256 _gas,\n        bytes memory _data\n    ) internal pure returns (bytes32) {\n        bytes memory raw = L2Transaction(\n            _l1BlockHash,\n            _logIndex,\n            _from,\n            _to,\n            _isCreate,\n            _mint,\n            _value,\n            _gas,\n            _data\n        );\n\n        return keccak256(raw);\n    }\n\n    /**\n     * @notice Compute the deposit transaction source hash.\n     * This value ensures that the L2 transaction hash is unique\n     * and deterministic based on L1 execution\n     * @param l1BlockHash The L1 blockhash corresponding to the block including\n     * the deposit\n     * @param logIndex The index of the log that created the deposit transaction\n     */\n    function sourceHash(bytes32 l1BlockHash, uint256 logIndex) internal pure returns (bytes32) {\n        bytes32 depositId = keccak256(abi.encode(l1BlockHash, logIndex));\n        return keccak256(abi.encode(bytes32(0), depositId));\n    }\n\n    /**\n     * @notice RLP encode a deposit transaction\n     * This only works for user deposits, not system deposits\n     * TODO: better name + rearrange the input param ordering?\n     */\n    function L2Transaction(\n        bytes32 _l1BlockHash,\n        uint256 _logIndex,\n        address _from,\n        address _to,\n        bool _isCreate,\n        uint256 _mint,\n        uint256 _value,\n        uint256 _gas,\n        bytes memory _data\n    ) internal pure returns (bytes memory) {\n        bytes32 source = sourceHash(_l1BlockHash, _logIndex);\n\n        bytes[] memory raw = new bytes[](7);\n\n        raw[0] = Lib_RLPWriter.writeBytes(bytes32ToBytes(source));\n        raw[1] = Lib_RLPWriter.writeAddress(_from);\n\n        if (_isCreate == true) {\n            require(_to == address(0));\n            raw[2] = Lib_RLPWriter.writeBytes(\"\");\n        } else {\n            raw[2] = Lib_RLPWriter.writeAddress(_to);\n        }\n\n        raw[3] = Lib_RLPWriter.writeUint(_mint);\n        raw[4] = Lib_RLPWriter.writeUint(_value);\n        raw[5] = Lib_RLPWriter.writeUint(_gas);\n        raw[6] = Lib_RLPWriter.writeBytes(_data);\n\n        bytes memory encoded = Lib_RLPWriter.writeList(raw);\n        return abi.encodePacked(uint8(0x7e), encoded);\n    }\n\n    /**\n     * @notice Helper function to turn bytes32 into bytes\n     */\n    function bytes32ToBytes(bytes32 input) internal pure returns (bytes memory) {\n        bytes memory b = new bytes(32);\n        assembly {\n            mstore(add(b, 32), input) // set the bytes data\n        }\n        return b;\n    }\n\n    /**\n     * @notice Adds the version to the nonce\n     */\n    function addVersionToNonce(uint256 _nonce, uint16 _version)\n        internal\n        pure\n        returns (uint256 nonce)\n    {\n        assembly {\n            nonce := or(shl(240, _version), _nonce)\n        }\n    }\n\n    /**\n     * @notice Gets the version out of the nonce\n     */\n    function getVersionFromNonce(uint256 _nonce) internal pure returns (uint16 version) {\n        assembly {\n            version := shr(240, _nonce)\n        }\n    }\n\n    /**\n     * @notice Encodes the cross domain message based on the version that\n     * is encoded in the nonce\n     */\n    function getVersionedEncoding(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes memory) {\n        uint16 version = getVersionFromNonce(_nonce);\n        if (version == 0) {\n            return getEncodingV0(_target, _sender, _data, _nonce);\n        } else if (version == 1) {\n            return getEncodingV1(_nonce, _sender, _target, _value, _gasLimit, _data);\n        }\n\n        revert(\"Unknown version.\");\n    }\n\n    /**\n     * @notice Compute the cross domain hash based on the versioned nonce\n     */\n    function getVersionedHash(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes32) {\n        uint16 version = getVersionFromNonce(_nonce);\n        if (version == 0) {\n            return getHashV0(_target, _sender, _data, _nonce);\n        } else if (version == 1) {\n            return getHashV1(_nonce, _sender, _target, _value, _gasLimit, _data);\n        }\n\n        revert(\"Unknown version.\");\n    }\n\n    /**\n     * @notice Compute the legacy cross domain serialization\n     */\n    function getEncodingV0(\n        address _target,\n        address _sender,\n        bytes memory _data,\n        uint256 _nonce\n    ) internal pure returns (bytes memory) {\n        return Lib_CrossDomainUtils.encodeXDomainCalldata(_target, _sender, _data, _nonce);\n    }\n\n    /**\n     * @notice Compute the V1 cross domain serialization\n     */\n    function getEncodingV1(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                \"relayMessage(uint256,address,address,uint256,uint256,bytes)\",\n                _nonce,\n                _sender,\n                _target,\n                _value,\n                _gasLimit,\n                _data\n            );\n    }\n\n    /**\n     * @notice Compute the legacy hash of a cross domain message\n     */\n    function getHashV0(\n        address _target,\n        address _sender,\n        bytes memory _data,\n        uint256 _nonce\n    ) internal pure returns (bytes32) {\n        return keccak256(getEncodingV0(_target, _sender, _data, _nonce));\n    }\n\n    /**\n     * @notice Compute the V1 hash of a cross domain message\n     */\n    function getHashV1(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes32) {\n        return keccak256(getEncodingV1(_nonce, _sender, _target, _value, _gasLimit, _data));\n    }\n}\n"
    },
    "contracts/libraries/Lib_CrossDomainUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_CrossDomainUtils\n */\nlibrary Lib_CrossDomainUtils {\n    /**\n     * Generates the correct cross domain calldata for a message.\n     * @param _target Target contract address.\n     * @param _sender Message sender address.\n     * @param _message Message to send to the target.\n     * @param _messageNonce Nonce for the provided message.\n     * @return ABI encoded cross domain calldata.\n     */\n    function encodeXDomainCalldata(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodeWithSignature(\n                \"relayMessage(address,address,bytes,uint256)\",\n                _target,\n                _sender,\n                _message,\n                _messageNonce\n            );\n    }\n}\n"
    },
    "contracts/libraries/Lib_DefaultValues.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_DefaultValues\n */\nlibrary Lib_DefaultValues {\n    // The default x-domain message sender being set to a non-zero value makes\n    // deployment a bit more expensive, but in exchange the refund on every call to\n    // `relayMessage` by the L1 and L2 messengers will be higher.\n    address internal constant DEFAULT_XDOMAIN_SENDER = 0x000000000000000000000000000000000000dEaD;\n}\n"
    },
    "contracts/libraries/Lib_PredeployAddresses.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_PredeployAddresses\n */\nlibrary Lib_PredeployAddresses {\n    address internal constant L2_TO_L1_MESSAGE_PASSER = 0x4200000000000000000000000000000000000000;\n    address internal constant L1_MESSAGE_SENDER = 0x4200000000000000000000000000000000000001;\n    address internal constant DEPLOYER_WHITELIST = 0x4200000000000000000000000000000000000002;\n    address payable internal constant OVM_ETH = payable(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000);\n    address internal constant L2_CROSS_DOMAIN_MESSENGER =\n        0x4200000000000000000000000000000000000007;\n    address internal constant LIB_ADDRESS_MANAGER = 0x4200000000000000000000000000000000000008;\n    address internal constant PROXY_EOA = 0x4200000000000000000000000000000000000009;\n    address internal constant L2_STANDARD_BRIDGE = 0x4200000000000000000000000000000000000010;\n    address internal constant SEQUENCER_FEE_WALLET = 0x4200000000000000000000000000000000000011;\n    address internal constant L2_STANDARD_TOKEN_FACTORY =\n        0x4200000000000000000000000000000000000012;\n    address internal constant L1_BLOCK_NUMBER = 0x4200000000000000000000000000000000000013;\n    address internal constant L1_BLOCK_ATTRIBUTES = 0x4200000000000000000000000000000000000015;\n}\n"
    },
    "contracts/libraries/Lib_WithdrawalVerifier.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/* Library Imports */\nimport { Lib_SecureMerkleTrie } from \"./trie/Lib_SecureMerkleTrie.sol\";\nimport { Lib_CrossDomainUtils } from \"./Lib_CrossDomainUtils.sol\";\n\n/**\n * @title WithdrawalVerifier\n * @notice A library with helper functions for verifying a withdrawal on L1.\n */\nlibrary WithdrawalVerifier {\n    /// @notice A struct containing the elements hashed together to generate the output root.\n    struct OutputRootProof {\n        bytes32 version;\n        bytes32 stateRoot;\n        bytes32 withdrawerStorageRoot;\n        bytes32 latestBlockhash;\n    }\n\n    /**\n     * @notice Derives the withdrawal hash according to the encoding in the L2 Withdrawer contract\n     * @param _nonce Nonce for the provided message.\n     * @param _sender Message sender address on L2.\n     * @param _target Target address on L1.\n     * @param _value ETH to send to the target.\n     * @param _gasLimit Gas to be forwarded to the target.\n     * @param _data Data to send to the target.\n     */\n    function withdrawalHash(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(_nonce, _sender, _target, _value, _gasLimit, _data));\n    }\n\n    /**\n     * @notice Derives the output root corresponding to the elements provided in the proof.\n     * @param _outputRootProof The elements which were hashed together to generate the output root.\n     * @return Whether or not the output root matches the hashed output of the proof.\n     */\n    function _deriveOutputRoot(OutputRootProof memory _outputRootProof)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    _outputRootProof.version,\n                    _outputRootProof.stateRoot,\n                    _outputRootProof.withdrawerStorageRoot,\n                    _outputRootProof.latestBlockhash\n                )\n            );\n    }\n\n    /**\n     * @notice Verifies a proof that a given withdrawal hash is present in the Withdrawer contract's\n     * withdrawals mapping.\n     * @param _withdrawalHash Keccak256 hash of the withdrawal transaction data.\n     * @param _withdrawerStorageRoot Storage root of the withdrawer predeploy contract.\n     * @param _withdrawalProof Merkle trie inclusion proof for the desired node.\n     * @return Whether or not the inclusion proof was successful.\n     */\n    function _verifyWithdrawalInclusion(\n        bytes32 _withdrawalHash,\n        bytes32 _withdrawerStorageRoot,\n        bytes memory _withdrawalProof\n    ) internal pure returns (bool) {\n        bytes32 storageKey = keccak256(\n            abi.encode(\n                _withdrawalHash,\n                uint256(0) // The withdrawals mapping is at the first slot in the layout.\n            )\n        );\n\n        return\n            Lib_SecureMerkleTrie.verifyInclusionProof(\n                abi.encode(storageKey),\n                hex\"01\",\n                _withdrawalProof,\n                _withdrawerStorageRoot\n            );\n    }\n}\n"
    },
    "contracts/libraries/rlp/Lib_RLPReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_RLPReader\n * @dev Adapted from \"RLPReader\" by Hamdi Allam (hamdi.allam97@gmail.com).\n */\nlibrary Lib_RLPReader {\n    /*************\n     * Constants *\n     *************/\n\n    uint256 internal constant MAX_LIST_LENGTH = 32;\n\n    /*********\n     * Enums *\n     *********/\n\n    enum RLPItemType {\n        DATA_ITEM,\n        LIST_ITEM\n    }\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct RLPItem {\n        uint256 length;\n        uint256 ptr;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Converts bytes to a reference to memory position and length.\n     * @param _in Input bytes to convert.\n     * @return Output memory reference.\n     */\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {\n        uint256 ptr;\n        assembly {\n            ptr := add(_in, 32)\n        }\n\n        return RLPItem({ length: _in.length, ptr: ptr });\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {\n        (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.LIST_ITEM, \"Invalid RLP list value.\");\n\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\n        // writing to the length. Since we can't know the number of RLP items without looping over\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\n        // simply set a reasonable maximum list length and decrease the size before we finish.\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\n\n        uint256 itemCount = 0;\n        uint256 offset = listOffset;\n        while (offset < _in.length) {\n            require(itemCount < MAX_LIST_LENGTH, \"Provided RLP list exceeds max list length.\");\n\n            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(\n                RLPItem({ length: _in.length - offset, ptr: _in.ptr + offset })\n            );\n\n            out[itemCount] = RLPItem({ length: itemLength + itemOffset, ptr: _in.ptr + offset });\n\n            itemCount += 1;\n            offset += itemOffset + itemLength;\n        }\n\n        // Decrease the array size to match the actual item count.\n        assembly {\n            mstore(out, itemCount)\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {\n        return readList(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes value.\");\n\n        return _copy(_in.ptr, itemOffset, itemLength);\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(bytes memory _in) internal pure returns (bytes memory) {\n        return readBytes(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(RLPItem memory _in) internal pure returns (string memory) {\n        return string(readBytes(_in));\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(bytes memory _in) internal pure returns (string memory) {\n        return readString(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {\n        require(_in.length <= 33, \"Invalid RLP bytes32 value.\");\n\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes32 value.\");\n\n        uint256 ptr = _in.ptr + itemOffset;\n        bytes32 out;\n        assembly {\n            out := mload(ptr)\n\n            // Shift the bytes over to match the item size.\n            if lt(itemLength, 32) {\n                out := div(out, exp(256, sub(32, itemLength)))\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(bytes memory _in) internal pure returns (bytes32) {\n        return readBytes32(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(RLPItem memory _in) internal pure returns (uint256) {\n        return uint256(readBytes32(_in));\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(bytes memory _in) internal pure returns (uint256) {\n        return readUint256(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(RLPItem memory _in) internal pure returns (bool) {\n        require(_in.length == 1, \"Invalid RLP boolean value.\");\n\n        uint256 ptr = _in.ptr;\n        uint256 out;\n        assembly {\n            out := byte(0, mload(ptr))\n        }\n\n        require(out == 0 || out == 1, \"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\");\n\n        return out != 0;\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(bytes memory _in) internal pure returns (bool) {\n        return readBool(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(RLPItem memory _in) internal pure returns (address) {\n        if (_in.length == 1) {\n            return address(0);\n        }\n\n        require(_in.length == 21, \"Invalid RLP address value.\");\n\n        return address(uint160(readUint256(_in)));\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(bytes memory _in) internal pure returns (address) {\n        return readAddress(toRLPItem(_in));\n    }\n\n    /**\n     * Reads the raw bytes of an RLP item.\n     * @param _in RLP item to read.\n     * @return Raw RLP bytes.\n     */\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {\n        return _copy(_in);\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Decodes the length of an RLP item.\n     * @param _in RLP item to decode.\n     * @return Offset of the encoded data.\n     * @return Length of the encoded data.\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\n     */\n    function _decodeLength(RLPItem memory _in)\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            RLPItemType\n        )\n    {\n        require(_in.length > 0, \"RLP item cannot be null.\");\n\n        uint256 ptr = _in.ptr;\n        uint256 prefix;\n        assembly {\n            prefix := byte(0, mload(ptr))\n        }\n\n        if (prefix <= 0x7f) {\n            // Single byte.\n\n            return (0, 1, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xb7) {\n            // Short string.\n\n            // slither-disable-next-line variable-scope\n            uint256 strLen = prefix - 0x80;\n\n            require(_in.length > strLen, \"Invalid RLP short string.\");\n\n            return (1, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xbf) {\n            // Long string.\n            uint256 lenOfStrLen = prefix - 0xb7;\n\n            require(_in.length > lenOfStrLen, \"Invalid RLP long string length.\");\n\n            uint256 strLen;\n            assembly {\n                // Pick out the string length.\n                strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))\n            }\n\n            require(_in.length > lenOfStrLen + strLen, \"Invalid RLP long string.\");\n\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xf7) {\n            // Short list.\n            // slither-disable-next-line variable-scope\n            uint256 listLen = prefix - 0xc0;\n\n            require(_in.length > listLen, \"Invalid RLP short list.\");\n\n            return (1, listLen, RLPItemType.LIST_ITEM);\n        } else {\n            // Long list.\n            uint256 lenOfListLen = prefix - 0xf7;\n\n            require(_in.length > lenOfListLen, \"Invalid RLP long list length.\");\n\n            uint256 listLen;\n            assembly {\n                // Pick out the list length.\n                listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))\n            }\n\n            require(_in.length > lenOfListLen + listLen, \"Invalid RLP long list.\");\n\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\n        }\n    }\n\n    /**\n     * Copies the bytes from a memory location.\n     * @param _src Pointer to the location to read from.\n     * @param _offset Offset to start reading from.\n     * @param _length Number of bytes to read.\n     * @return Copied bytes.\n     */\n    function _copy(\n        uint256 _src,\n        uint256 _offset,\n        uint256 _length\n    ) private pure returns (bytes memory) {\n        bytes memory out = new bytes(_length);\n        if (out.length == 0) {\n            return out;\n        }\n\n        uint256 src = _src + _offset;\n        uint256 dest;\n        assembly {\n            dest := add(out, 32)\n        }\n\n        // Copy over as many complete words as we can.\n        for (uint256 i = 0; i < _length / 32; i++) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += 32;\n            dest += 32;\n        }\n\n        // Pick out the remaining bytes.\n        uint256 mask;\n        unchecked {\n            mask = 256**(32 - (_length % 32)) - 1;\n        }\n\n        assembly {\n            mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\n        }\n        return out;\n    }\n\n    /**\n     * Copies an RLP item into bytes.\n     * @param _in RLP item to copy.\n     * @return Copied bytes.\n     */\n    function _copy(RLPItem memory _in) private pure returns (bytes memory) {\n        return _copy(_in.ptr, 0, _in.length);\n    }\n}\n"
    },
    "contracts/libraries/rlp/Lib_RLPWriter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_RLPWriter\n * @author Bakaoh (with modifications)\n */\nlibrary Lib_RLPWriter {\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * RLP encodes a byte string.\n     * @param _in The byte string to encode.\n     * @return The RLP encoded string in bytes.\n     */\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\n            encoded = _in;\n        } else {\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\n        }\n\n        return encoded;\n    }\n\n    /**\n     * RLP encodes a list of RLP encoded byte byte strings.\n     * @param _in The list of RLP encoded byte strings.\n     * @return The RLP encoded list of items in bytes.\n     */\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\n        bytes memory list = _flatten(_in);\n        return abi.encodePacked(_writeLength(list.length, 192), list);\n    }\n\n    /**\n     * RLP encodes a string.\n     * @param _in The string to encode.\n     * @return The RLP encoded string in bytes.\n     */\n    function writeString(string memory _in) internal pure returns (bytes memory) {\n        return writeBytes(bytes(_in));\n    }\n\n    /**\n     * RLP encodes an address.\n     * @param _in The address to encode.\n     * @return The RLP encoded address in bytes.\n     */\n    function writeAddress(address _in) internal pure returns (bytes memory) {\n        return writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * RLP encodes a uint.\n     * @param _in The uint256 to encode.\n     * @return The RLP encoded uint256 in bytes.\n     */\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\n        return writeBytes(_toBinary(_in));\n    }\n\n    /**\n     * RLP encodes a bool.\n     * @param _in The bool to encode.\n     * @return The RLP encoded bool in bytes.\n     */\n    function writeBool(bool _in) internal pure returns (bytes memory) {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\n        return encoded;\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\n     * @param _len The length of the string or the payload.\n     * @param _offset 128 if item is string, 192 if item is list.\n     * @return RLP encoded bytes.\n     */\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\n        } else {\n            uint256 lenLen;\n            uint256 i = 1;\n            while (_len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\n            for (i = 1; i <= lenLen; i++) {\n                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\n            }\n        }\n\n        return encoded;\n    }\n\n    /**\n     * Encode integer in big endian binary form with no leading zeroes.\n     * @notice TODO: This should be optimized with assembly to save gas costs.\n     * @param _x The integer to encode.\n     * @return RLP encoded bytes.\n     */\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\n        bytes memory b = abi.encodePacked(_x);\n\n        uint256 i = 0;\n        for (; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n\n        bytes memory res = new bytes(32 - i);\n        for (uint256 j = 0; j < res.length; j++) {\n            res[j] = b[i++];\n        }\n\n        return res;\n    }\n\n    /**\n     * Copies a piece of memory to another location.\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\n     * @param _dest Destination location.\n     * @param _src Source location.\n     * @param _len Length of memory to copy.\n     */\n    function _memcpy(\n        uint256 _dest,\n        uint256 _src,\n        uint256 _len\n    ) private pure {\n        uint256 dest = _dest;\n        uint256 src = _src;\n        uint256 len = _len;\n\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint256 mask;\n        unchecked {\n            mask = 256**(32 - len) - 1;\n        }\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * Flattens a list of byte strings into one byte string.\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\n     * @param _list List of byte strings to flatten.\n     * @return The flattened byte string.\n     */\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 len;\n        uint256 i = 0;\n        for (; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint256 flattenedPtr;\n        assembly {\n            flattenedPtr := add(flattened, 0x20)\n        }\n\n        for (i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n\n            uint256 listPtr;\n            assembly {\n                listPtr := add(item, 0x20)\n            }\n\n            _memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += _list[i].length;\n        }\n\n        return flattened;\n    }\n}\n"
    },
    "contracts/libraries/trie/Lib_MerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_BytesUtils } from \"../Lib_BytesUtils.sol\";\nimport { Lib_RLPReader } from \"../rlp/Lib_RLPReader.sol\";\nimport { Lib_RLPWriter } from \"../rlp/Lib_RLPWriter.sol\";\n\n/**\n * @title Lib_MerkleTrie\n */\nlibrary Lib_MerkleTrie {\n    /*******************\n     * Data Structures *\n     *******************/\n\n    enum NodeType {\n        BranchNode,\n        ExtensionNode,\n        LeafNode\n    }\n\n    struct TrieNode {\n        bytes encoded;\n        Lib_RLPReader.RLPItem[] decoded;\n    }\n\n    /**********************\n     * Contract Constants *\n     **********************/\n\n    // TREE_RADIX determines the number of elements per branch node.\n    uint256 constant TREE_RADIX = 16;\n    // Branch nodes have TREE_RADIX elements plus an additional `value` slot.\n    uint256 constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\n    // Leaf nodes and extension nodes always have two elements, a `path` and a `value`.\n    uint256 constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\n\n    // Prefixes are prepended to the `path` within a leaf or extension node and\n    // allow us to differentiate between the two node types. `ODD` or `EVEN` is\n    // determined by the number of nibbles within the unprefixed `path`. If the\n    // number of nibbles if even, we need to insert an extra padding nibble so\n    // the resulting prefixed `path` has an even number of nibbles.\n    uint8 constant PREFIX_EXTENSION_EVEN = 0;\n    uint8 constant PREFIX_EXTENSION_ODD = 1;\n    uint8 constant PREFIX_LEAF_EVEN = 2;\n    uint8 constant PREFIX_LEAF_ODD = 3;\n\n    // Just a utility constant. RLP represents `NULL` as 0x80.\n    bytes1 constant RLP_NULL = bytes1(0x80);\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * @notice Verifies a proof that a given key/value pair is present in the\n     * Merkle trie.\n     * @param _key Key of the node to search for, as a hex string.\n     * @param _value Value of the node to search for, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike\n     * traditional Merkle trees, this proof is executed top-down and consists\n     * of a list of RLP-encoded nodes that make a path down to the target node.\n     * @param _root Known root of the Merkle trie. Used to verify that the\n     * included proof is correctly constructed.\n     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\n     */\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool _verified) {\n        (bool exists, bytes memory value) = get(_key, _proof, _root);\n\n        return (exists && Lib_BytesUtils.equal(_value, value));\n    }\n\n    /**\n     * @notice Retrieves the value associated with a given key.\n     * @param _key Key to search for, as hex bytes.\n     * @param _proof Merkle trie inclusion proof for the key.\n     * @param _root Known root of the Merkle trie.\n     * @return _exists Whether or not the key exists.\n     * @return _value Value of the key if it exists.\n     */\n    function get(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool _exists, bytes memory _value) {\n        TrieNode[] memory proof = _parseProof(_proof);\n        (uint256 pathLength, bytes memory keyRemainder, bool isFinalNode) = _walkNodePath(\n            proof,\n            _key,\n            _root\n        );\n\n        bool exists = keyRemainder.length == 0;\n\n        require(exists || isFinalNode, \"Provided proof is invalid.\");\n\n        bytes memory value = exists ? _getNodeValue(proof[pathLength - 1]) : bytes(\"\");\n\n        return (exists, value);\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * @notice Walks through a proof using a provided key.\n     * @param _proof Inclusion proof to walk through.\n     * @param _key Key to use for the walk.\n     * @param _root Known root of the trie.\n     * @return _pathLength Length of the final path\n     * @return _keyRemainder Portion of the key remaining after the walk.\n     * @return _isFinalNode Whether or not we've hit a dead end.\n     */\n    function _walkNodePath(\n        TrieNode[] memory _proof,\n        bytes memory _key,\n        bytes32 _root\n    )\n        private\n        pure\n        returns (\n            uint256 _pathLength,\n            bytes memory _keyRemainder,\n            bool _isFinalNode\n        )\n    {\n        uint256 pathLength = 0;\n        bytes memory key = Lib_BytesUtils.toNibbles(_key);\n\n        bytes32 currentNodeID = _root;\n        uint256 currentKeyIndex = 0;\n        uint256 currentKeyIncrement = 0;\n        TrieNode memory currentNode;\n\n        // Proof is top-down, so we start at the first element (root).\n        for (uint256 i = 0; i < _proof.length; i++) {\n            currentNode = _proof[i];\n            currentKeyIndex += currentKeyIncrement;\n\n            // Keep track of the proof elements we actually need.\n            // It's expensive to resize arrays, so this simply reduces gas costs.\n            pathLength += 1;\n\n            if (currentKeyIndex == 0) {\n                // First proof element is always the root node.\n                require(keccak256(currentNode.encoded) == currentNodeID, \"Invalid root hash\");\n            } else if (currentNode.encoded.length >= 32) {\n                // Nodes 32 bytes or larger are hashed inside branch nodes.\n                require(\n                    keccak256(currentNode.encoded) == currentNodeID,\n                    \"Invalid large internal hash\"\n                );\n            } else {\n                // Nodes smaller than 31 bytes aren't hashed.\n                require(\n                    Lib_BytesUtils.toBytes32(currentNode.encoded) == currentNodeID,\n                    \"Invalid internal node hash\"\n                );\n            }\n\n            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {\n                if (currentKeyIndex == key.length) {\n                    // We've hit the end of the key\n                    // meaning the value should be within this branch node.\n                    break;\n                } else {\n                    // We're not at the end of the key yet.\n                    // Figure out what the next node ID should be and continue.\n                    uint8 branchKey = uint8(key[currentKeyIndex]);\n                    Lib_RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];\n                    currentNodeID = _getNodeID(nextNode);\n                    currentKeyIncrement = 1;\n                    continue;\n                }\n            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\n                bytes memory path = _getNodePath(currentNode);\n                uint8 prefix = uint8(path[0]);\n                uint8 offset = 2 - (prefix % 2);\n                bytes memory pathRemainder = Lib_BytesUtils.slice(path, offset);\n                bytes memory keyRemainder = Lib_BytesUtils.slice(key, currentKeyIndex);\n                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);\n\n                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\n                    if (\n                        pathRemainder.length == sharedNibbleLength &&\n                        keyRemainder.length == sharedNibbleLength\n                    ) {\n                        // The key within this leaf matches our key exactly.\n                        // Increment the key index to reflect that we have no remainder.\n                        currentKeyIndex += sharedNibbleLength;\n                    }\n\n                    // We've hit a leaf node, so our next node should be NULL.\n                    currentNodeID = bytes32(RLP_NULL);\n                    break;\n                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\n                    if (sharedNibbleLength != pathRemainder.length) {\n                        // Our extension node is not identical to the remainder.\n                        // We've hit the end of this path\n                        // updates will need to modify this extension.\n                        currentNodeID = bytes32(RLP_NULL);\n                        break;\n                    } else {\n                        // Our extension shares some nibbles.\n                        // Carry on to the next node.\n                        currentNodeID = _getNodeID(currentNode.decoded[1]);\n                        currentKeyIncrement = sharedNibbleLength;\n                        continue;\n                    }\n                } else {\n                    revert(\"Received a node with an unknown prefix\");\n                }\n            } else {\n                revert(\"Received an unparseable node.\");\n            }\n        }\n\n        // If our node ID is NULL, then we're at a dead end.\n        bool isFinalNode = currentNodeID == bytes32(RLP_NULL);\n        return (pathLength, Lib_BytesUtils.slice(key, currentKeyIndex), isFinalNode);\n    }\n\n    /**\n     * @notice Parses an RLP-encoded proof into something more useful.\n     * @param _proof RLP-encoded proof to parse.\n     * @return _parsed Proof parsed into easily accessible structs.\n     */\n    function _parseProof(bytes memory _proof) private pure returns (TrieNode[] memory _parsed) {\n        Lib_RLPReader.RLPItem[] memory nodes = Lib_RLPReader.readList(_proof);\n        TrieNode[] memory proof = new TrieNode[](nodes.length);\n\n        for (uint256 i = 0; i < nodes.length; i++) {\n            bytes memory encoded = Lib_RLPReader.readBytes(nodes[i]);\n            proof[i] = TrieNode({ encoded: encoded, decoded: Lib_RLPReader.readList(encoded) });\n        }\n\n        return proof;\n    }\n\n    /**\n     * @notice Picks out the ID for a node. Node ID is referred to as the\n     * \"hash\" within the specification, but nodes < 32 bytes are not actually\n     * hashed.\n     * @param _node Node to pull an ID for.\n     * @return _nodeID ID for the node, depending on the size of its contents.\n     */\n    function _getNodeID(Lib_RLPReader.RLPItem memory _node) private pure returns (bytes32 _nodeID) {\n        bytes memory nodeID;\n\n        if (_node.length < 32) {\n            // Nodes smaller than 32 bytes are RLP encoded.\n            nodeID = Lib_RLPReader.readRawBytes(_node);\n        } else {\n            // Nodes 32 bytes or larger are hashed.\n            nodeID = Lib_RLPReader.readBytes(_node);\n        }\n\n        return Lib_BytesUtils.toBytes32(nodeID);\n    }\n\n    /**\n     * @notice Gets the path for a leaf or extension node.\n     * @param _node Node to get a path for.\n     * @return _path Node path, converted to an array of nibbles.\n     */\n    function _getNodePath(TrieNode memory _node) private pure returns (bytes memory _path) {\n        return Lib_BytesUtils.toNibbles(Lib_RLPReader.readBytes(_node.decoded[0]));\n    }\n\n    /**\n     * @notice Gets the path for a node.\n     * @param _node Node to get a value for.\n     * @return _value Node value, as hex bytes.\n     */\n    function _getNodeValue(TrieNode memory _node) private pure returns (bytes memory _value) {\n        return Lib_RLPReader.readBytes(_node.decoded[_node.decoded.length - 1]);\n    }\n\n    /**\n     * @notice Utility; determines the number of nibbles shared between two\n     * nibble arrays.\n     * @param _a First nibble array.\n     * @param _b Second nibble array.\n     * @return _shared Number of shared nibbles.\n     */\n    function _getSharedNibbleLength(bytes memory _a, bytes memory _b)\n        private\n        pure\n        returns (uint256 _shared)\n    {\n        uint256 i = 0;\n        while (_a.length > i && _b.length > i && _a[i] == _b[i]) {\n            i++;\n        }\n        return i;\n    }\n}\n"
    },
    "contracts/libraries/trie/Lib_SecureMerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_MerkleTrie } from \"./Lib_MerkleTrie.sol\";\n\n/**\n * @title Lib_SecureMerkleTrie\n */\nlibrary Lib_SecureMerkleTrie {\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * @notice Verifies a proof that a given key/value pair is present in the\n     * Merkle trie.\n     * @param _key Key of the node to search for, as a hex string.\n     * @param _value Value of the node to search for, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike\n     * traditional Merkle trees, this proof is executed top-down and consists\n     * of a list of RLP-encoded nodes that make a path down to the target node.\n     * @param _root Known root of the Merkle trie. Used to verify that the\n     * included proof is correctly constructed.\n     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\n     */\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool _verified) {\n        bytes memory key = _getSecureKey(_key);\n        return Lib_MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\n    }\n\n    /**\n     * @notice Retrieves the value associated with a given key.\n     * @param _key Key to search for, as hex bytes.\n     * @param _proof Merkle trie inclusion proof for the key.\n     * @param _root Known root of the Merkle trie.\n     * @return _exists Whether or not the key exists.\n     * @return _value Value of the key if it exists.\n     */\n    function get(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    ) internal pure returns (bool _exists, bytes memory _value) {\n        bytes memory key = _getSecureKey(_key);\n        return Lib_MerkleTrie.get(key, _proof, _root);\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Computes the secure counterpart to a key.\n     * @param _key Key to get a secure key from.\n     * @return _secureKey Secure version of the key.\n     */\n    function _getSecureKey(bytes memory _key) private pure returns (bytes memory _secureKey) {\n        return abi.encodePacked(keccak256(_key));\n    }\n}\n"
    },
    "contracts/test/CommonTest.t.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/* Testing utilities */\nimport { Test } from \"forge-std/Test.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { L1StandardBridge } from \"../L1/L1StandardBridge.sol\";\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\nimport { OptimismMintableTokenFactory } from \"../universal/OptimismMintableTokenFactory.sol\";\nimport { OptimismMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\nimport { OptimismPortal } from \"../L1/OptimismPortal.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { L2CrossDomainMessenger } from \"../L2/L2CrossDomainMessenger.sol\";\nimport { AddressAliasHelper } from \"../libraries/AddressAliasHelper.sol\";\nimport { OVM_ETH } from \"../L2/OVM_ETH.sol\";\nimport { Lib_PredeployAddresses } from \"../libraries/Lib_PredeployAddresses.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { Initializable } from \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\ncontract CommonTest is Test {\n    address alice = address(128);\n    address bob = address(256);\n\n    address immutable ZERO_ADDRESS = address(0);\n    address immutable NON_ZERO_ADDRESS = address(1);\n    uint256 immutable NON_ZERO_VALUE = 100;\n    uint256 immutable ZERO_VALUE = 0;\n    uint64 immutable NON_ZERO_GASLIMIT = 50000;\n    bytes32 nonZeroHash = keccak256(abi.encode(\"NON_ZERO\"));\n    bytes NON_ZERO_DATA = hex\"0000111122223333444455556666777788889999aaaabbbbccccddddeeeeffff0000\";\n\n    function _setUp() public {\n        // Give alice and bob some ETH\n        vm.deal(alice, 1 << 16);\n        vm.deal(bob, 1 << 16);\n\n        vm.label(alice, \"alice\");\n        vm.label(bob, \"bob\");\n\n        // Make sure we have a non-zero base fee\n        vm.fee(1000000000);\n    }\n}\n\ncontract L2OutputOracle_Initializer is CommonTest {\n    // Test target\n    L2OutputOracle oracle;\n    L2OutputOracle oracleImpl;\n\n    // Constructor arguments\n    address sequencer = 0x000000000000000000000000000000000000AbBa;\n    address owner = 0x000000000000000000000000000000000000ACDC;\n    uint256 submissionInterval = 1800;\n    uint256 l2BlockTime = 2;\n    bytes32 genesisL2Output = keccak256(abi.encode(0));\n    uint256 historicalTotalBlocks = 199;\n    uint256 startingBlockNumber = 200;\n    uint256 startingTimestamp = 1000;\n\n    // Test data\n    uint256 initL1Time;\n\n    function setUp() public virtual {\n        _setUp();\n\n        // By default the first block has timestamp and number zero, which will cause underflows in the\n        // tests, so we'll move forward to these block values.\n        initL1Time = startingTimestamp + 1;\n        vm.warp(initL1Time);\n        vm.roll(startingBlockNumber);\n        // Deploy the L2OutputOracle and transfer owernship to the sequencer\n        oracleImpl = new L2OutputOracle(\n            submissionInterval,\n            genesisL2Output,\n            historicalTotalBlocks,\n            startingBlockNumber,\n            startingTimestamp,\n            l2BlockTime,\n            sequencer,\n            owner\n        );\n        Proxy proxy = new Proxy(alice);\n        vm.prank(alice);\n        proxy.upgradeToAndCall(\n            address(oracleImpl),\n            abi.encodeWithSelector(\n                L2OutputOracle.initialize.selector,\n                genesisL2Output,\n                startingBlockNumber,\n                sequencer,\n                owner\n            )\n        );\n        oracle = L2OutputOracle(address(proxy));\n    }\n}\n\ncontract Portal_Initializer is L2OutputOracle_Initializer {\n    // Test target\n    OptimismPortal opImpl;\n    OptimismPortal op;\n\n    function setUp() public override virtual {\n        L2OutputOracle_Initializer.setUp();\n        opImpl = new OptimismPortal(oracle, 7 days);\n        Proxy proxy = new Proxy(alice);\n        vm.prank(alice);\n        proxy.upgradeToAndCall(\n            address(opImpl),\n            abi.encodeWithSelector(\n                OptimismPortal.initialize.selector\n            )\n        );\n        op = OptimismPortal(payable(address(proxy)));\n    }\n}\n\ncontract Messenger_Initializer is L2OutputOracle_Initializer {\n    OptimismPortal op;\n    L1CrossDomainMessenger L1Messenger;\n    L2CrossDomainMessenger L2Messenger =\n        L2CrossDomainMessenger(Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER);\n    L2ToL1MessagePasser messagePasser =\n        L2ToL1MessagePasser(payable(Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER));\n\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n\n    event WithdrawalInitiated(\n        uint256 indexed nonce,\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    event RelayedMessage(bytes32 indexed msgHash);\n\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 mint,\n        uint256 value,\n        uint64 gasLimit,\n        bool isCreation,\n        bytes data\n    );\n\n    event WithdrawalFinalized(bytes32 indexed, bool success);\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        // Deploy the OptimismPortal\n        op = new OptimismPortal(oracle, 7 days);\n        vm.label(address(op), \"OptimismPortal\");\n\n        L1Messenger = new L1CrossDomainMessenger(op);\n\n        vm.etch(\n            Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER,\n            address(new L2CrossDomainMessenger()).code\n        );\n\n        L2Messenger.initialize(address(L1Messenger));\n\n        // Set the L2ToL1MessagePasser at the correct address\n        vm.etch(\n            Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER,\n            address(new L2ToL1MessagePasser()).code\n        );\n\n        vm.label(Lib_PredeployAddresses.OVM_ETH, \"OVM_ETH\");\n\n        vm.label(Lib_PredeployAddresses.L2_TO_L1_MESSAGE_PASSER, \"L2ToL1MessagePasser\");\n\n        vm.label(Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER, \"L2CrossDomainMessenger\");\n\n        vm.label(\n            AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)),\n            \"L1CrossDomainMessenger_aliased\"\n        );\n    }\n}\n\ncontract Bridge_Initializer is Messenger_Initializer {\n    L1StandardBridge L1Bridge;\n    L2StandardBridge L2Bridge;\n    OptimismMintableTokenFactory L2TokenFactory;\n    OptimismMintableTokenFactory L1TokenFactory;\n    ERC20 L1Token;\n    OptimismMintableERC20 L2Token;\n    ERC20 NativeL2Token;\n    OptimismMintableERC20 RemoteL1Token;\n\n    event ETHDepositInitiated(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ETHWithdrawalFinalized(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ERC20DepositInitiated(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ERC20WithdrawalFinalized(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event WithdrawalInitiated(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event DepositFinalized(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event DepositFailed(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ETHBridgeInitiated(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ETHBridgeFinalized(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ERC20BridgeInitiated(\n        address indexed _localToken,\n        address indexed _remoteToken,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ERC20BridgeFinalized(\n        address indexed _localToken,\n        address indexed _remoteToken,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event ERC20BridgeFailed(\n        address indexed _localToken,\n        address indexed _remoteToken,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    function setUp() public virtual override {\n        super.setUp();\n\n        vm.label(Lib_PredeployAddresses.L2_STANDARD_BRIDGE, \"L2StandardBridge\");\n        vm.label(Lib_PredeployAddresses.L2_STANDARD_TOKEN_FACTORY, \"L2StandardTokenFactory\");\n\n        // Deploy the L1 bridge and initialize it with the address of the\n        // L1CrossDomainMessenger\n        L1Bridge = new L1StandardBridge(payable(address(L1Messenger)));\n        vm.label(address(L1Bridge), \"L1StandardBridge\");\n\n        // Deploy the L2StandardBridge, move it to the correct predeploy\n        // address and then initialize it\n        L2StandardBridge l2B = new L2StandardBridge();\n        vm.etch(Lib_PredeployAddresses.L2_STANDARD_BRIDGE, address(l2B).code);\n        L2Bridge = L2StandardBridge(payable(Lib_PredeployAddresses.L2_STANDARD_BRIDGE));\n        L2Bridge.initialize(payable(address(L1Bridge)));\n\n        // Set up the L2 mintable token factory\n        OptimismMintableTokenFactory factory = new OptimismMintableTokenFactory();\n        vm.etch(Lib_PredeployAddresses.L2_STANDARD_TOKEN_FACTORY, address(factory).code);\n        L2TokenFactory = OptimismMintableTokenFactory(\n            Lib_PredeployAddresses.L2_STANDARD_TOKEN_FACTORY\n        );\n        L2TokenFactory.initialize(Lib_PredeployAddresses.L2_STANDARD_BRIDGE);\n\n        vm.etch(Lib_PredeployAddresses.OVM_ETH, address(new OVM_ETH()).code);\n\n        L1Token = new ERC20(\"Native L1 Token\", \"L1T\");\n\n        // Deploy the L2 ERC20 now\n        L2Token = OptimismMintableERC20(\n            L2TokenFactory.createStandardL2Token(\n                address(L1Token),\n                string(abi.encodePacked(\"L2-\", L1Token.name())),\n                string(abi.encodePacked(\"L2-\", L1Token.symbol()))\n            )\n        );\n\n        NativeL2Token = new ERC20(\"Native L2 Token\", \"L2T\");\n        L1TokenFactory = new OptimismMintableTokenFactory();\n        L1TokenFactory.initialize(address(L1Bridge));\n\n        RemoteL1Token = OptimismMintableERC20(\n            L1TokenFactory.createStandardL2Token(\n                address(NativeL2Token),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.name())),\n                string(abi.encodePacked(\"L1-\", NativeL2Token.symbol()))\n            )\n        );\n    }\n}\n\n// Used for testing a future upgrade beyond the current implementations.\n// We include some variables so that we can sanity check accessing storage values after an upgrade.\ncontract NextImpl is Initializable {\n    // Initializable occupies the zero-th slot.\n    bytes32 slot1;\n    bytes32[19] __gap;\n    bytes32 slot21;\n    bytes32 public constant slot21Init = bytes32(hex\"1337\");\n\n    function initialize() public reinitializer(2) {\n        // Slot21 is unused by an of our upgradeable contracts.\n        // This is used to verify that we can access this value after an upgrade.\n        slot21 = slot21Init;\n    }\n}\n"
    },
    "contracts/test/CrossDomainHashing.t.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { CrossDomainHashing } from \"../libraries/Lib_CrossDomainHashing.sol\";\n\ncontract CrossDomainHashing_Test is CommonTest {\n    function test_nonceVersioning(uint240 _nonce, uint16 _version) external {\n        uint256 nonce = CrossDomainHashing.addVersionToNonce(uint256(_nonce), _version);\n        uint16 version = CrossDomainHashing.getVersionFromNonce(nonce);\n        assertEq(version, _version);\n    }\n\n    // TODO(tynes): turn this into differential fuzzing\n    // it is very easy to do so with the typescript\n    function test_l2TransactionHash() external {\n        bytes32 l1BlockHash = 0xd1a498e053451fc90bd8a597051a1039010c8e55e2659b940d3070b326e4f4c5;\n        uint256 logIndex = 0x0;\n        address from =  address(0xDe3829A23DF1479438622a08a116E8Eb3f620BB5);\n        address to = address(0xB7e390864a90b7b923C9f9310C6F98aafE43F707);\n        bool isCreate = false;\n        uint256 mint = 0xe043da617250000;\n        uint256 value = 0xde0b6b3a7640000;\n        uint256 gas = 0x2dc6c0;\n        bytes memory data = hex\"\";\n\n        bytes32 sourceHash = CrossDomainHashing.sourceHash(\n            l1BlockHash,\n            logIndex\n        );\n\n        assertEq(\n            sourceHash,\n            0x77fc5994647d128a4d131d273a5e89e0306aac472494068a4f1fceab83dd0735\n        );\n\n        bytes memory raw = CrossDomainHashing.L2Transaction(\n            l1BlockHash,\n            logIndex,\n            from,\n            to,\n            isCreate,\n            mint,\n            value,\n            gas,\n            data\n        );\n\n        assertEq(\n            raw,\n            hex\"7ef862a077fc5994647d128a4d131d273a5e89e0306aac472494068a4f1fceab83dd073594de3829a23df1479438622a08a116e8eb3f620bb594b7e390864a90b7b923c9f9310c6f98aafe43f707880e043da617250000880de0b6b3a7640000832dc6c080\"\n        );\n\n        bytes32 digest = CrossDomainHashing.L2TransactionHash(\n            l1BlockHash,\n           logIndex,\n           from,\n           to,\n           isCreate,\n           mint,\n           value,\n           gas,\n           data\n        );\n\n        assertEq(\n            digest,\n            0xf5f97d03e8be48a4b20ed70c9d8b11f1c851bf949bf602b7580985705bb09077\n        );\n    }\n}\n"
    },
    "contracts/test/DeployerWhitelist.t.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { DeployerWhitelist } from \"../L2/DeployerWhitelist.sol\";\n\ncontract DeployerWhitelist_Test is CommonTest {\n    DeployerWhitelist list;\n\n    function setUp() external {\n        list = new DeployerWhitelist();\n    }\n\n    // The owner should be address(0)\n    function test_owner() external {\n        assertEq(list.owner(), address(0));\n    }\n\n    // The storage slot for the owner must be the same\n    function test_storageSlots() external {\n        vm.prank(list.owner());\n        list.setOwner(address(1));\n\n        assertEq(\n            bytes32(uint256(1)),\n            vm.load(address(list), bytes32(uint256(0)))\n        );\n    }\n}\n"
    },
    "contracts/test/GasPriceOracle.t.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { GasPriceOracle } from \"../L2/GasPriceOracle.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\nimport { Lib_PredeployAddresses } from \"../libraries/Lib_PredeployAddresses.sol\";\n\ncontract GasPriceOracle_Test is CommonTest {\n\n    event OverheadUpdated(uint256);\n    event ScalarUpdated(uint256);\n    event DecimalsUpdated(uint256);\n\n    GasPriceOracle gasOracle;\n    L1Block l1Block;\n    address depositor;\n\n    function setUp() external {\n        // place the L1Block contract at the predeploy address\n        vm.etch(\n            Lib_PredeployAddresses.L1_BLOCK_ATTRIBUTES,\n            address(new L1Block()).code\n        );\n\n        l1Block = L1Block(Lib_PredeployAddresses.L1_BLOCK_ATTRIBUTES);\n        depositor = l1Block.DEPOSITOR_ACCOUNT();\n\n        // We are not setting the gas oracle at its predeploy\n        // address for simplicity purposes. Nothing in this test\n        // requires it to be at a particular address\n        gasOracle = new GasPriceOracle(alice);\n\n        // set the initial L1 context values\n        uint64 number = 10;\n        uint64 timestamp = 11;\n        uint256 basefee = 100;\n        bytes32 hash = bytes32(uint256(64));\n        uint64 sequenceNumber = 0;\n\n        vm.prank(depositor);\n        l1Block.setL1BlockValues(\n            number,\n            timestamp,\n            basefee,\n            hash,\n            sequenceNumber\n        );\n    }\n\n    function test_owner() external {\n        // alice is passed into the constructor of the gasOracle\n        assertEq(gasOracle.owner(), alice);\n    }\n\n    function test_storageLayout() external {\n        // the overhead is at slot 3\n        vm.prank(gasOracle.owner());\n        gasOracle.setOverhead(456);\n        assertEq(\n            456,\n            uint256(vm.load(address(gasOracle), bytes32(uint256(3))))\n        );\n\n        // scalar is at slot 4\n        vm.prank(gasOracle.owner());\n        gasOracle.setScalar(333);\n        assertEq(\n            333,\n            uint256(vm.load(address(gasOracle), bytes32(uint256(4))))\n        );\n\n        // decimals is at slot 5\n        vm.prank(gasOracle.owner());\n        gasOracle.setDecimals(222);\n        assertEq(\n            222,\n            uint256(vm.load(address(gasOracle), bytes32(uint256(5))))\n        );\n    }\n\n    function test_l1BaseFee() external {\n        uint256 l1BaseFee = gasOracle.l1BaseFee();\n        assertEq(l1BaseFee, 100);\n    }\n\n    function test_gasPrice() external {\n        vm.fee(100);\n        uint256 gasPrice = gasOracle.gasPrice();\n        assertEq(gasPrice, 100);\n    }\n\n    function test_baseFee() external {\n        vm.fee(64);\n        uint256 gasPrice = gasOracle.baseFee();\n        assertEq(gasPrice, 64);\n    }\n\n    function test_setGasPriceReverts() external {\n        vm.prank(gasOracle.owner());\n        (bool success, bytes memory returndata) = address(gasOracle).call(\n            abi.encodeWithSignature(\n                \"setGasPrice(uint256)\",\n                1\n            )\n        );\n\n        assertEq(success, false);\n        assertEq(returndata, hex\"\");\n    }\n\n    function test_setL1BaseFeeReverts() external {\n        vm.prank(gasOracle.owner());\n        (bool success, bytes memory returndata) = address(gasOracle).call(\n            abi.encodeWithSignature(\n                \"setL1BaseFee(uint256)\",\n                1\n            )\n        );\n\n        assertEq(success, false);\n        assertEq(returndata, hex\"\");\n    }\n\n    function test_setOverhead() external {\n        vm.expectEmit(true, true, true, true);\n        emit OverheadUpdated(1234);\n\n        vm.prank(gasOracle.owner());\n        gasOracle.setOverhead(1234);\n        assertEq(gasOracle.overhead(), 1234);\n    }\n\n    function test_onlyOwnerSetOverhead() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        gasOracle.setOverhead(0);\n    }\n\n    function test_setScalar() external {\n        vm.expectEmit(true, true, true, true);\n        emit ScalarUpdated(666);\n\n        vm.prank(gasOracle.owner());\n        gasOracle.setScalar(666);\n        assertEq(gasOracle.scalar(), 666);\n    }\n\n    function test_onlyOwnerSetScalar() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        gasOracle.setScalar(0);\n    }\n\n    function test_setDecimals() external {\n        vm.expectEmit(true, true, true, true);\n        emit DecimalsUpdated(18);\n\n        vm.prank(gasOracle.owner());\n        gasOracle.setDecimals(18);\n        assertEq(gasOracle.decimals(), 18);\n    }\n\n    function test_onlyOwnerSetDecimals() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        gasOracle.setDecimals(0);\n    }\n}\n"
    },
    "contracts/test/L1Block.t.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\n\ncontract L1BlockTest is CommonTest {\n    L1Block lb;\n    address depositor;\n    bytes32 immutable NON_ZERO_HASH = keccak256(abi.encode(1));\n\n    function setUp() external {\n        lb = new L1Block();\n        depositor = lb.DEPOSITOR_ACCOUNT();\n        vm.prank(depositor);\n        lb.setL1BlockValues(uint64(1), uint64(2), 3, NON_ZERO_HASH, uint64(4));\n    }\n\n    function test_updatesValues(uint64 n, uint64 t, uint256 b, bytes32 h, uint64 s) external {\n        vm.prank(depositor);\n        lb.setL1BlockValues(n, t, b, h, s);\n        assertEq(lb.number(), n);\n        assertEq(lb.timestamp(), t);\n        assertEq(lb.basefee(), b);\n        assertEq(lb.hash(), h);\n        assertEq(lb.sequenceNumber(), s);\n    }\n\n    function test_number() external {\n        assertEq(lb.number(), uint64(1));\n    }\n\n    function test_timestamp() external {\n        assertEq(lb.timestamp(), uint64(2));\n    }\n\n    function test_basefee() external {\n        assertEq(lb.basefee(), 3);\n    }\n\n    function test_hash() external {\n        assertEq(lb.hash(), NON_ZERO_HASH);\n    }\n\n    function test_sequenceNumber() external {\n        assertEq(lb.sequenceNumber(), uint64(4));\n    }\n\n    function test_updateValues() external {\n        vm.prank(depositor);\n        lb.setL1BlockValues(type(uint64).max, type(uint64).max, type(uint256).max, keccak256(abi.encode(1)), type(uint64).max);\n    }\n}\n"
    },
    "contracts/test/L1BlockNumber.t.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { L1Block } from \"../L2/L1Block.sol\";\nimport { L1BlockNumber } from \"../L2/L1BlockNumber.sol\";\nimport { Lib_PredeployAddresses } from \"../libraries/Lib_PredeployAddresses.sol\";\n\ncontract L1BlockNumberTest is Test {\n    L1Block lb;\n    L1BlockNumber bn;\n\n    function setUp() external {\n        vm.etch(Lib_PredeployAddresses.L1_BLOCK_ATTRIBUTES, address(new L1Block()).code);\n        lb = L1Block(Lib_PredeployAddresses.L1_BLOCK_ATTRIBUTES);\n        bn = new L1BlockNumber();\n        vm.prank(lb.DEPOSITOR_ACCOUNT());\n        lb.setL1BlockValues(uint64(999), uint64(2), 3, keccak256(abi.encode(1)), uint64(4));\n    }\n\n    function test_getL1BlockNumber() external {\n        assertEq(bn.getL1BlockNumber(), 999);\n    }\n\n    function test_fallback() external {\n        (bool success, bytes memory ret) = address(bn).call(hex\"\");\n        assertEq(success, true);\n        assertEq(ret, abi.encode(999));\n    }\n\n    function test_receive() external {\n        (bool success, bytes memory ret) = address(bn).call{ value: 1 }(hex\"\");\n        assertEq(success, true);\n        assertEq(ret, abi.encode(999));\n    }\n}\n"
    },
    "contracts/test/L1CrossDomainMessenger.t.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/* Testing utilities */\nimport { Messenger_Initializer } from \"./CommonTest.t.sol\";\nimport { L2OutputOracle_Initializer } from \"./L2OutputOracle.t.sol\";\n\n/* Libraries */\nimport { AddressAliasHelper } from \"../libraries/AddressAliasHelper.sol\";\nimport { Lib_DefaultValues } from \"../libraries/Lib_DefaultValues.sol\";\nimport { Lib_PredeployAddresses } from \"../libraries/Lib_PredeployAddresses.sol\";\nimport { Lib_CrossDomainUtils } from \"../libraries/Lib_CrossDomainUtils.sol\";\nimport { WithdrawalVerifier } from \"../libraries/Lib_WithdrawalVerifier.sol\";\n\n/* Target contract dependencies */\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { OptimismPortal } from \"../L1/OptimismPortal.sol\";\n\nimport { CrossDomainHashing } from \"../libraries/Lib_CrossDomainHashing.sol\";\n\n/* Target contract */\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\n\ncontract L1CrossDomainMessenger_Test is Messenger_Initializer {\n    // Receiver address for testing\n    address recipient = address(0xabbaacdc);\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    // pause: should pause the contract when called by the current owner\n    function test_L1MessengerPause() external {\n        L1Messenger.pause();\n        assert(L1Messenger.paused());\n    }\n\n    // pause: should not pause the contract when called by account other than the owner\n    function testCannot_L1MessengerPause() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(0xABBA));\n        L1Messenger.pause();\n    }\n\n    // unpause: should unpause the contract when called by the current owner\n    function test_L1MessengerUnpause() external {\n        L1Messenger.pause();\n        assert(L1Messenger.paused());\n        L1Messenger.unpause();\n        assert(!L1Messenger.paused());\n    }\n\n    // unpause: should not unpause the contract when called by account other than the owner\n    function testCannot_L1MessengerUnpause() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(0xABBA));\n        L1Messenger.unpause();\n    }\n\n    // the version is encoded in the nonce\n    function test_L1MessengerMessageVersion() external {\n        assertEq(\n            CrossDomainHashing.getVersionFromNonce(L1Messenger.messageNonce()),\n            L1Messenger.MESSAGE_VERSION()\n        );\n    }\n\n    // sendMessage: should be able to send a single message\n    // TODO: this same test needs to be done with the legacy message type\n    // by setting the message version to 0\n    function test_L1MessengerSendMessage() external {\n        // deposit transaction on the optimism portal should be called\n        vm.expectCall(\n            address(op),\n            abi.encodeWithSelector(\n                OptimismPortal.depositTransaction.selector,\n                Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER,\n                0,\n                100 + L1Messenger.baseGas(hex\"ff\"),\n                false,\n                CrossDomainHashing.getVersionedEncoding(\n                    L1Messenger.messageNonce(),\n                    alice,\n                    recipient,\n                    0,\n                    100,\n                    hex\"ff\"\n                )\n            )\n        );\n\n        // TransactionDeposited event\n        vm.expectEmit(true, true, true, true);\n        emit TransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger)),\n            Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER,\n            0,\n            0,\n            100 + L1Messenger.baseGas(hex\"ff\"),\n            false,\n            CrossDomainHashing.getVersionedEncoding(\n                L1Messenger.messageNonce(),\n                alice,\n                recipient,\n                0,\n                100,\n                hex\"ff\"\n            )\n        );\n\n        // SentMessage event\n        vm.expectEmit(true, true, true, true);\n        emit SentMessage(recipient, alice, hex\"ff\", L1Messenger.messageNonce(), 100);\n\n        vm.prank(alice);\n        L1Messenger.sendMessage(recipient, hex\"ff\", uint32(100));\n    }\n\n    // sendMessage: should be able to send the same message twice\n    function test_L1MessengerTwiceSendMessage() external {\n        uint256 nonce = L1Messenger.messageNonce();\n        L1Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        L1Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        // the nonce increments for each message sent\n        assertEq(nonce + 2, L1Messenger.messageNonce());\n    }\n\n    function test_L1MessengerXDomainSenderReverts() external {\n        vm.expectRevert(\"xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n    }\n\n    // xDomainMessageSender: should return the xDomainMsgSender address\n    // TODO: might need a test contract\n    // function test_xDomainSenderSetCorrectly() external {}\n\n    // relayMessage: should send a successful call to the target contract\n    function test_L1MessengerRelayMessageSucceeds() external {\n        address target = address(0xabcd);\n        address sender = Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER;\n\n        vm.expectCall(target, hex\"1111\");\n\n        // set the value of op.l2Sender() to be the L2 Cross Domain Messenger.\n        uint256 senderSlotIndex = 51;\n        vm.store(address(op), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.prank(address(op));\n\n        vm.expectEmit(true, true, true, true);\n\n        bytes32 hash = CrossDomainHashing.getVersionedHash(0, sender, target, 0, 0, hex\"1111\");\n\n        emit RelayedMessage(hash);\n\n        L1Messenger.relayMessage(\n            0, // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n\n        // the message hash is in the successfulMessages mapping\n        assert(L1Messenger.successfulMessages(hash));\n        // it is not in the received messages mapping\n        assertEq(L1Messenger.receivedMessages(hash), false);\n    }\n\n    // relayMessage: should revert if attempting to relay a message sent to an L1 system contract\n    function test_L1MessengerRelayMessageToSystemContract() external {\n        // set the target to be the OptimismPortal\n        address target = address(op);\n        address sender = Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER;\n        bytes memory message = hex\"1111\";\n\n        // set the value of op.l2Sender() to be the L2 Cross Domain Messenger.\n        vm.prank(address(op));\n        vm.expectRevert(\"Message cannot be replayed.\");\n        L1Messenger.relayMessage(0, sender, target, 0, 0, message);\n\n        vm.store(address(op), 0, bytes32(abi.encode(sender)));\n        vm.expectRevert(\"Message cannot be replayed.\");\n        L1Messenger.relayMessage(0, sender, target, 0, 0, message);\n    }\n\n    // relayMessage: the xDomainMessageSender is reset to the original value\n    function test_L1MessengerxDomainMessageSenderResets() external {\n        vm.expectRevert(\"xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n\n        address sender = Lib_PredeployAddresses.L2_CROSS_DOMAIN_MESSENGER;\n\n        uint256 senderSlotIndex = 51;\n        bytes32 slotValue = vm.load(address(op), bytes32(senderSlotIndex));\n\n        vm.store(address(op), bytes32(senderSlotIndex), bytes32(abi.encode(sender)));\n        vm.prank(address(op));\n        L1Messenger.relayMessage(0, address(0), address(0), 0, 0, hex\"\");\n\n        vm.expectRevert(\"xDomainMessageSender is not set\");\n        L1Messenger.xDomainMessageSender();\n    }\n\n    // relayMessage: should revert if paused\n    function test_L1MessengerRelayShouldRevertIfPaused() external {\n        vm.prank(L1Messenger.owner());\n        L1Messenger.pause();\n\n        vm.expectRevert(\"Pausable: paused\");\n        L1Messenger.relayMessage(0, address(0), address(0), 0, 0, hex\"\");\n    }\n}\n"
    },
    "contracts/test/L1StandardBridge.t.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport { StandardBridge } from \"../universal/StandardBridge.sol\";\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { Lib_PredeployAddresses } from \"../libraries/Lib_PredeployAddresses.sol\";\nimport { AddressAliasHelper } from \"../libraries/AddressAliasHelper.sol\";\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport { stdStorage, StdStorage } from \"forge-std/Test.sol\";\n\ncontract L1StandardBridge_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_initialize() external {\n        assertEq(\n            address(L1Bridge.messenger()),\n            address(L1Messenger)\n        );\n\n        assertEq(\n            address(L1Bridge.otherBridge()),\n            Lib_PredeployAddresses.L2_STANDARD_BRIDGE\n        );\n\n        assertEq(\n            address(L2Bridge),\n            Lib_PredeployAddresses.L2_STANDARD_BRIDGE\n        );\n    }\n\n    // receive\n    // - can accept ETH\n    function test_receive() external {\n        assertEq(address(op).balance, 0);\n\n        vm.expectEmit(true, true, true, true);\n        emit ETHBridgeInitiated(alice, alice, 100, hex\"\");\n\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                abi.encodeWithSelector(\n                    StandardBridge.finalizeBridgeETH.selector,\n                    alice,\n                    alice,\n                    100,\n                    hex\"\"\n                ),\n                200_000\n            )\n        );\n\n        vm.prank(alice, alice);\n        address(L1Bridge).call{ value: 100 }(hex\"\");\n        assertEq(address(op).balance, 100);\n    }\n\n    // depositETH\n    // - emits ETHDepositInitiated\n    // - calls optimismPortal.depositTransaction\n    // - only EOA\n    // - ETH ends up in the optimismPortal\n    function test_depositETH() external {\n        assertEq(address(op).balance, 0);\n\n        vm.expectEmit(true, true, true, true);\n        emit ETHBridgeInitiated(alice, alice, 500, hex\"ff\");\n\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                abi.encodeWithSelector(\n                    StandardBridge.finalizeBridgeETH.selector,\n                    alice,\n                    alice,\n                    500,\n                    hex\"ff\"\n                ),\n                50000\n            )\n        );\n\n        vm.prank(alice, alice);\n        L1Bridge.depositETH{ value: 500 }(50000, hex\"ff\");\n        assertEq(address(op).balance, 500);\n    }\n\n    function test_onlyEOADepositETH() external {\n        // turn alice into a contract\n        vm.etch(alice, address(L1Token).code);\n\n        vm.expectRevert(\"Account not EOA\");\n        vm.prank(alice);\n        L1Bridge.depositETH{ value: 1 }(300, hex\"\");\n    }\n\n    // depositETHTo\n    // - emits ETHDepositInitiated\n    // - calls optimismPortal.depositTransaction\n    // - EOA or contract can call\n    // - ETH ends up in the optimismPortal\n    function test_depositETHTo() external {\n        assertEq(address(op).balance, 0);\n\n        vm.expectEmit(true, true, true, true);\n        emit ETHDepositInitiated(alice, bob, 600, hex\"dead\");\n\n        vm.expectEmit(true, true, true, true);\n        emit ETHBridgeInitiated(alice, bob, 600, hex\"dead\");\n\n        // depositETHTo on the L1 bridge should be called\n        vm.expectCall(\n            address(L1Bridge),\n            abi.encodeWithSelector(\n                L1Bridge.depositETHTo.selector,\n                bob,\n                1000,\n                hex\"dead\"\n            )\n        );\n\n        // the L1 bridge should call\n        // L1CrossDomainMessenger.sendMessage\n        vm.expectCall(\n            address(L1Messenger),\n            abi.encodeWithSelector(\n                CrossDomainMessenger.sendMessage.selector,\n                address(L2Bridge),\n                abi.encodeWithSelector(\n                    StandardBridge.finalizeBridgeETH.selector,\n                    alice,\n                    bob,\n                    600,\n                    hex\"dead\"\n                ),\n                1000\n            )\n        );\n\n        // TODO: assert on OptimismPortal being called\n        // and the event being emitted correctly\n\n        // deposit eth to bob\n        vm.prank(alice, alice);\n        L1Bridge.depositETHTo{ value: 600 }(bob, 1000, hex\"dead\");\n    }\n\n    // depositERC20\n    // - updates bridge.deposits\n    // - emits ERC20DepositInitiated\n    // - calls optimismPortal.depositTransaction\n    // - only callable by EOA\n    function test_depositERC20() external {\n        vm.expectEmit(true, true, true, true);\n        emit ERC20DepositInitiated(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n\n        deal(address(L1Token), alice, 100000, true);\n\n        vm.prank(alice);\n        L1Token.approve(address(L1Bridge), type(uint256).max);\n\n        // The L1Bridge should transfer alice's tokens\n        // to itself\n        vm.expectCall(\n            address(L1Token),\n            abi.encodeWithSelector(\n                ERC20.transferFrom.selector,\n                alice,\n                address(L1Bridge),\n                100\n            )\n        );\n\n        // TODO: optimismPortal.depositTransaction call + event\n\n        vm.prank(alice);\n        L1Bridge.depositERC20(\n            address(L1Token),\n            address(L2Token),\n            100,\n            10000,\n            hex\"\"\n        );\n\n        assertEq(L1Bridge.deposits(address(L1Token), address(L2Token)), 100);\n    }\n\n    function test_onlyEOADepositERC20() external {\n        // turn alice into a contract\n        vm.etch(alice, hex\"ffff\");\n\n        vm.expectRevert(\"Account not EOA\");\n        vm.prank(alice, alice);\n        L1Bridge.depositERC20(\n            address(0),\n            address(0),\n            100,\n            100,\n            hex\"\"\n        );\n    }\n\n    // depositERC20To\n    // - updates bridge.deposits\n    // - emits ERC20DepositInitiated\n    // - calls optimismPortal.depositTransaction\n    // - callable by a contract\n    function test_depositERC20To() external {\n        vm.expectEmit(true, true, true, true);\n        emit ERC20DepositInitiated(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            bob,\n            1000,\n            hex\"\"\n        );\n\n        deal(address(L1Token), alice, 100000, true);\n\n        vm.prank(alice);\n        L1Token.approve(address(L1Bridge), type(uint256).max);\n\n        vm.expectCall(\n            address(L1Token),\n            abi.encodeWithSelector(\n                ERC20.transferFrom.selector,\n                alice,\n                address(L1Bridge),\n                1000\n            )\n        );\n\n        vm.prank(alice);\n        L1Bridge.depositERC20To(\n            address(L1Token),\n            address(L2Token),\n            bob,\n            1000,\n            10000,\n            hex\"\"\n        );\n\n        assertEq(L1Bridge.deposits(address(L1Token), address(L2Token)), 1000);\n    }\n\n    // finalizeETHWithdrawal\n    // - emits ETHWithdrawalFinalized\n    // - only callable by L2 bridge\n    function test_finalizeETHWithdrawal() external {\n        uint256 aliceBalance = alice.balance;\n\n        vm.expectEmit(true, true, true, true);\n        emit ETHWithdrawalFinalized(\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n\n        vm.expectCall(\n            alice,\n            hex\"\"\n        );\n\n        vm.mockCall(\n            address(L1Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.otherBridge()))\n        );\n        // ensure that the messenger has ETH to call with\n        vm.deal(address(L1Bridge.messenger()), 100);\n        vm.prank(address(L1Bridge.messenger()));\n        L1Bridge.finalizeETHWithdrawal{ value: 100 }(\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n\n        assertEq(address(L1Bridge.messenger()).balance, 0);\n        assertEq(aliceBalance + 100, alice.balance);\n    }\n\n    // finalizeERC20Withdrawal\n    // - updates bridge.deposits\n    // - emits ERC20WithdrawalFinalized\n    // - only callable by L2 bridge\n    function test_finalizeERC20Withdrawal() external {\n        deal(address(L1Token), address(L1Bridge), 100, true);\n\n        uint256 slot = stdstore\n            .target(address(L1Bridge))\n            .sig(\"deposits(address,address)\")\n            .with_key(address(L1Token))\n            .with_key(address(L2Token))\n            .find();\n\n        // Give the L1 bridge some ERC20 tokens\n        vm.store(address(L1Bridge), bytes32(slot), bytes32(uint256(100)));\n        assertEq(L1Bridge.deposits(address(L1Token), address(L2Token)), 100);\n\n        vm.expectEmit(true, true, true, true);\n        emit ERC20WithdrawalFinalized(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n\n        vm.expectCall(\n            address(L1Token),\n            abi.encodeWithSelector(\n                ERC20.transfer.selector,\n                alice,\n                100\n            )\n        );\n\n        vm.mockCall(\n            address(L1Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.otherBridge()))\n        );\n        vm.prank(address(L1Bridge.messenger()));\n        L1Bridge.finalizeERC20Withdrawal(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n\n        assertEq(L1Token.balanceOf(address(L1Bridge)), 0);\n        assertEq(L1Token.balanceOf(address(alice)), 100);\n    }\n\n    function test_onlyPortalFinalizeERC20Withdrawal() external {\n        vm.mockCall(\n            address(L1Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L1Bridge.otherBridge()))\n        );\n        vm.prank(address(28));\n        vm.expectRevert(\"Could not authenticate bridge message.\");\n        L1Bridge.finalizeERC20Withdrawal(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n    }\n\n    function test_onlyL2BridgeFinalizeERC20Withdrawal() external {\n        vm.mockCall(\n            address(L1Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(address(0)))\n        );\n        vm.prank(address(L1Bridge.messenger()));\n        vm.expectRevert(\"Could not authenticate bridge message.\");\n        L1Bridge.finalizeERC20Withdrawal(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n    }\n}\n"
    },
    "contracts/test/L2CrossDomainMessenger.t.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { Messenger_Initializer } from \"./CommonTest.t.sol\";\n\nimport { Lib_CrossDomainUtils } from \"../libraries/Lib_CrossDomainUtils.sol\";\nimport { AddressAliasHelper } from \"../libraries/AddressAliasHelper.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { L2CrossDomainMessenger } from \"../L2/L2CrossDomainMessenger.sol\";\nimport { L1CrossDomainMessenger } from \"../L1/L1CrossDomainMessenger.sol\";\nimport { CrossDomainHashing } from \"../libraries/Lib_CrossDomainHashing.sol\";\nimport { Lib_DefaultValues } from \"../libraries/Lib_DefaultValues.sol\";\n\ncontract L2CrossDomainMessenger_Test is Messenger_Initializer {\n    // Receiver address for testing\n    address recipient = address(0xabbaacdc);\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_L2MessengerPause() external {\n        L2Messenger.pause();\n        assert(L2Messenger.paused());\n    }\n\n    function testCannot_L2MessengerPause() external {\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        vm.prank(address(0xABBA));\n        L2Messenger.pause();\n    }\n\n    function test_L2MessengerMessageVersion() external {\n        assertEq(\n            CrossDomainHashing.getVersionFromNonce(L2Messenger.messageNonce()),\n            L2Messenger.MESSAGE_VERSION()\n        );\n    }\n\n    function test_L2MessengerSendMessage() external {\n        vm.expectCall(\n            address(messagePasser),\n            abi.encodeWithSelector(\n                L2ToL1MessagePasser.initiateWithdrawal.selector,\n                address(L1Messenger),\n                100 + L2Messenger.baseGas(hex\"ff\"),\n                CrossDomainHashing.getVersionedEncoding(\n                    L2Messenger.messageNonce(),\n                    alice,\n                    recipient,\n                    0,\n                    100,\n                    hex\"ff\"\n                )\n            )\n        );\n\n        // WithdrawalInitiated event\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalInitiated(\n            messagePasser.nonce(),\n            address(L2Messenger),\n            address(L1Messenger),\n            0,\n            100 + L2Messenger.baseGas(hex\"ff\"),\n            CrossDomainHashing.getVersionedEncoding(\n                L2Messenger.messageNonce(),\n                alice,\n                recipient,\n                0,\n                100,\n                hex\"ff\"\n            )\n        );\n\n        vm.prank(alice);\n        L2Messenger.sendMessage(recipient, hex\"ff\", uint32(100));\n    }\n\n    function test_L2MessengerTwiceSendMessage() external {\n        uint256 nonce = L2Messenger.messageNonce();\n        L2Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        L2Messenger.sendMessage(recipient, hex\"aa\", uint32(500_000));\n        // the nonce increments for each message sent\n        assertEq(\n            nonce + 2,\n            L2Messenger.messageNonce()\n        );\n    }\n\n    function test_L2MessengerXDomainSenderReverts() external {\n        vm.expectRevert(\"xDomainMessageSender is not set\");\n        L2Messenger.xDomainMessageSender();\n    }\n\n    function test_L2MessengerRelayMessageSucceeds() external {\n        address target = address(0xabcd);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n\n        vm.expectCall(target, hex\"1111\");\n\n        vm.prank(caller);\n\n        vm.expectEmit(true, true, true, true);\n\n        bytes32 hash = CrossDomainHashing.getVersionedHash(\n            0,\n            sender,\n            target,\n            0,\n            0,\n            hex\"1111\"\n        );\n\n        emit RelayedMessage(hash);\n\n        L2Messenger.relayMessage(\n            0, // nonce\n            sender,\n            target,\n            0, // value\n            0,\n            hex\"1111\"\n        );\n\n        // the message hash is in the successfulMessages mapping\n        assert(L2Messenger.successfulMessages(hash));\n        // it is not in the received messages mapping\n        assertEq(L2Messenger.receivedMessages(hash), false);\n    }\n\n    // relayMessage: should revert if attempting to relay a message sent to an L1 system contract\n    function test_L2MessengerRelayMessageToSystemContract() external {\n        address target = address(messagePasser);\n        address sender = address(L1Messenger);\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n        bytes memory message = hex\"1111\";\n\n        vm.prank(caller);\n        vm.expectRevert(\"Message cannot be replayed.\");\n        L1Messenger.relayMessage(0, sender, target, 0, 0, message);\n    }\n\n    // relayMessage: the xDomainMessageSender is reset to the original value\n    function test_L2MessengerxDomainMessageSenderResets() external {\n        vm.expectRevert(\"xDomainMessageSender is not set\");\n        L2Messenger.xDomainMessageSender();\n\n        address caller = AddressAliasHelper.applyL1ToL2Alias(address(L1Messenger));\n        vm.prank(caller);\n        L2Messenger.relayMessage(0, address(0), address(0), 0, 0, hex\"\");\n\n        vm.expectRevert(\"xDomainMessageSender is not set\");\n        L2Messenger.xDomainMessageSender();\n    }\n\n    // relayMessage: should revert if paused\n    function test_L2MessengerRelayShouldRevertIfPaused() external {\n        vm.prank(L2Messenger.owner());\n        L2Messenger.pause();\n\n        vm.expectRevert(\"Pausable: paused\");\n        L2Messenger.relayMessage(0, address(0), address(0), 0, 0, hex\"\");\n    }\n}\n"
    },
    "contracts/test/L2OutputOracle.t.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { L2OutputOracle_Initializer, NextImpl } from \"./CommonTest.t.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\n\n\ncontract L2OutputOracleTest is L2OutputOracle_Initializer {\n    bytes32 appendedOutput1 = keccak256(abi.encode(1));\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    // Advance the evm's time to meet the L2OutputOracle's requirements for appendL2Output\n    function warpToAppendTime(uint256 _nextBlockNumber) public {\n        vm.warp(oracle.computeL2Timestamp(_nextBlockNumber) + 1);\n    }\n\n    function test_constructor() external {\n        assertEq(oracle.owner(), owner);\n        assertEq(oracle.SUBMISSION_INTERVAL(), submissionInterval);\n        assertEq(oracle.HISTORICAL_TOTAL_BLOCKS(), historicalTotalBlocks);\n        assertEq(oracle.latestBlockNumber(), startingBlockNumber);\n        assertEq(oracle.STARTING_BLOCK_NUMBER(), startingBlockNumber);\n        assertEq(oracle.STARTING_TIMESTAMP(), startingTimestamp);\n        assertEq(oracle.sequencer(), sequencer);\n        assertEq(oracle.owner(), owner);\n\n        L2OutputOracle.OutputProposal memory proposal = oracle.getL2Output(startingBlockNumber);\n        assertEq(proposal.outputRoot, genesisL2Output);\n        assertEq(proposal.timestamp, initL1Time);\n    }\n\n    /****************\n     * Getter Tests *\n     ****************/\n\n    // Test: latestBlockNumber() should return the correct value\n    function test_latestBlockNumber() external {\n        uint256 appendedNumber = oracle.nextBlockNumber();\n\n        // Roll to after the block number we'll append\n        warpToAppendTime(appendedNumber);\n        vm.prank(sequencer);\n        oracle.appendL2Output(appendedOutput1, appendedNumber, 0, 0);\n        assertEq(oracle.latestBlockNumber(), appendedNumber);\n    }\n\n    // Test: getL2Output() should return the correct value\n    function test_getL2Output() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToAppendTime(nextBlockNumber);\n        vm.prank(sequencer);\n        oracle.appendL2Output(appendedOutput1, nextBlockNumber, 0, 0);\n\n        L2OutputOracle.OutputProposal memory proposal = oracle.getL2Output(nextBlockNumber);\n        assertEq(proposal.outputRoot, appendedOutput1);\n        assertEq(proposal.timestamp, block.timestamp);\n\n        L2OutputOracle.OutputProposal memory proposal2 = oracle.getL2Output(0);\n        assertEq(proposal2.outputRoot, bytes32(0));\n        assertEq(proposal2.timestamp, 0);\n    }\n\n    // Test: nextBlockNumber() should return the correct value\n    function test_nextBlockNumber() external {\n        assertEq(\n            oracle.nextBlockNumber(),\n            // The return value should match this arithmetic\n            oracle.latestBlockNumber() + oracle.SUBMISSION_INTERVAL()\n        );\n    }\n\n    function test_computeL2Timestamp() external {\n        // reverts if timestamp is too low\n        vm.expectRevert(\n            \"OutputOracle: Block number must be greater than or equal to the starting block number.\"\n        );\n        oracle.computeL2Timestamp(startingBlockNumber - 1);\n\n        // returns the correct value...\n        // ... for the very first block\n        assertEq(oracle.computeL2Timestamp(startingBlockNumber), startingTimestamp);\n\n        // ... for the first block after the starting block\n        assertEq(\n            oracle.computeL2Timestamp(startingBlockNumber + 1),\n            startingTimestamp + submissionInterval\n        );\n\n        // ... for some other block number\n        assertEq(\n            oracle.computeL2Timestamp(startingBlockNumber + 96024),\n            startingTimestamp + submissionInterval * 96024\n        );\n    }\n\n    /*******************\n     * Ownership tests *\n     *******************/\n\n    event SequencerChanged(address indexed previousSequencer, address indexed newSequencer);\n\n    function test_changeSequencer() public {\n        address newSequencer = address(20);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        oracle.changeSequencer(newSequencer);\n\n        vm.startPrank(owner);\n        vm.expectRevert(\"OutputOracle: new sequencer is the zero address\");\n        oracle.changeSequencer(address(0));\n\n        vm.expectRevert(\"OutputOracle: sequencer cannot be same as the owner\");\n        oracle.changeSequencer(owner);\n\n        // Double check sequencer has not changed.\n        assertEq(sequencer, oracle.sequencer());\n\n        vm.expectEmit(true, true, true, true);\n        emit SequencerChanged(sequencer, newSequencer);\n        oracle.changeSequencer(newSequencer);\n        vm.stopPrank();\n    }\n\n    event OwnershipTransferred(address indexed, address indexed);\n\n    function test_updateOwner() public {\n        address newOwner = address(21);\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        oracle.transferOwnership(newOwner);\n        // Double check owner has not changed.\n        assertEq(owner, oracle.owner());\n\n        vm.startPrank(owner);\n        vm.expectEmit(true, true, true, true);\n        emit OwnershipTransferred(owner, newOwner);\n        oracle.transferOwnership(newOwner);\n        vm.stopPrank();\n    }\n\n    /*****************************\n     * Append Tests - Happy Path *\n     *****************************/\n\n    // Test: appendL2Output succeeds when given valid input, and no block hash and number are\n    // specified.\n    function test_appendingAnotherOutput() public {\n        bytes32 appendedOutput2 = keccak256(abi.encode(2));\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToAppendTime(nextBlockNumber);\n        uint256 appendedNumber = oracle.latestBlockNumber();\n\n        // Ensure the submissionInterval is enforced\n        assertEq(nextBlockNumber, appendedNumber + submissionInterval);\n\n        vm.roll(nextBlockNumber + 1);\n        vm.prank(sequencer);\n        oracle.appendL2Output(appendedOutput2, nextBlockNumber, 0, 0);\n    }\n\n    // Test: appendL2Output succeeds when given valid input, and when a block hash and number are\n    // specified for reorg protection.\n    function test_appendWithBlockhashAndHeight() external {\n        // Get the number and hash of a previous block in the chain\n        uint256 prevL1BlockNumber = block.number - 1;\n        bytes32 prevL1BlockHash = blockhash(prevL1BlockNumber);\n\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToAppendTime(nextBlockNumber);\n        vm.prank(sequencer);\n        oracle.appendL2Output(nonZeroHash, nextBlockNumber, prevL1BlockHash, prevL1BlockNumber);\n    }\n\n    /***************************\n     * Append Tests - Sad Path *\n     ***************************/\n\n    // Test: appendL2Output fails if called by a party that is not the sequencer.\n    function testCannot_appendOutputIfNotSequencer() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToAppendTime(nextBlockNumber);\n\n        vm.prank(address(128));\n        vm.expectRevert(\"OutputOracle: caller is not the sequencer\");\n        oracle.appendL2Output(nonZeroHash, nextBlockNumber, 0, 0);\n    }\n\n    // Test: appendL2Output fails given a zero blockhash.\n    function testCannot_appendEmptyOutput() external {\n        bytes32 outputToAppend = bytes32(0);\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToAppendTime(nextBlockNumber);\n        vm.prank(sequencer);\n        vm.expectRevert(\"OutputOracle: Cannot submit empty L2 output.\");\n        oracle.appendL2Output(outputToAppend, nextBlockNumber, 0, 0);\n    }\n\n    // Test: appendL2Output fails if the block number doesn't match the next expected number.\n    function testCannot_appendUnexpectedBlockNumber() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToAppendTime(nextBlockNumber);\n        vm.prank(sequencer);\n        vm.expectRevert(\"OutputOracle: Block number must be equal to next expected block number.\");\n        oracle.appendL2Output(nonZeroHash, nextBlockNumber - 1, 0, 0);\n    }\n\n    // Test: appendL2Output fails if it would have a timestamp in the future.\n    function testCannot_appendFutureTimetamp() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        uint256 nextTimestamp = oracle.computeL2Timestamp(nextBlockNumber);\n        vm.warp(nextTimestamp);\n        vm.prank(sequencer);\n        vm.expectRevert(\"OutputOracle: Cannot append L2 output in future.\");\n        oracle.appendL2Output(nonZeroHash, nextBlockNumber, 0, 0);\n    }\n\n    // Test: appendL2Output fails if a non-existent L1 block hash and number are provided for reorg\n    // protection.\n    function testCannot_appendOnWrongFork() external {\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToAppendTime(nextBlockNumber);\n        vm.prank(sequencer);\n        vm.expectRevert(\"OutputOracle: Blockhash does not match the hash at the expected height.\");\n        oracle.appendL2Output(\n            nonZeroHash,\n            nextBlockNumber,\n            bytes32(uint256(0x01)),\n            block.number - 1\n        );\n    }\n\n    // Test: appendL2Output fails when given valid input, but the block hash and number do not\n    // match.\n    // This tests is disabled (w/ skip_ prefix) because all blocks in Foundry currently have a\n    // blockhash of zero.\n    function skip_testCannot_AppendWithUnmatchedBlockhash() external {\n        // Move ahead to block 100 so that we can reference historical blocks\n        vm.roll(100);\n\n        // Get the number and hash of a previous block in the chain\n        uint256 l1BlockNumber = block.number - 1;\n        bytes32 l1BlockHash = blockhash(l1BlockNumber);\n\n        uint256 nextBlockNumber = oracle.nextBlockNumber();\n        warpToAppendTime(nextBlockNumber);\n        vm.prank(sequencer);\n\n        // This will fail when foundry no longer returns zerod block hashes\n        oracle.appendL2Output(nonZeroHash, nextBlockNumber, l1BlockHash, l1BlockNumber - 1);\n    }\n\n    /*****************************\n     * Delete Tests - Happy Path *\n     *****************************/\n\n    event L2OutputDeleted(\n        bytes32 indexed _l2Output,\n        uint256 indexed _l1Timestamp,\n        uint256 indexed _l2BlockNumber\n    );\n\n    function test_deleteL2Output() external {\n        test_appendingAnotherOutput();\n\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n        L2OutputOracle.OutputProposal memory proposalToDelete = oracle.getL2Output(\n            latestBlockNumber\n        );\n        L2OutputOracle.OutputProposal memory newLatestOutput = oracle.getL2Output(\n            latestBlockNumber - submissionInterval\n        );\n\n        vm.prank(owner);\n        vm.expectEmit(true, true, false, false);\n        emit L2OutputDeleted(\n            proposalToDelete.outputRoot,\n            proposalToDelete.timestamp,\n            latestBlockNumber\n        );\n        oracle.deleteL2Output(proposalToDelete);\n\n        // validate latestBlockNumber has been reduced\n        uint256 latestBlockNumberAfter = oracle.latestBlockNumber();\n        assertEq(latestBlockNumber - submissionInterval, latestBlockNumberAfter);\n\n        L2OutputOracle.OutputProposal memory proposal = oracle.getL2Output(latestBlockNumberAfter);\n        // validate that the new latest output is as expected.\n        assertEq(newLatestOutput.outputRoot, proposal.outputRoot);\n        assertEq(newLatestOutput.timestamp, proposal.timestamp);\n    }\n\n    /***************************\n     * Delete Tests - Sad Path *\n     ***************************/\n\n    function testCannot_deleteL2Output_ifNotOwner() external {\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n        L2OutputOracle.OutputProposal memory proposal = oracle.getL2Output(latestBlockNumber);\n\n        vm.expectRevert(\"Ownable: caller is not the owner\");\n        oracle.deleteL2Output(proposal);\n    }\n\n    function testCannot_deleteL2Output_withWrongRoot() external {\n        test_appendingAnotherOutput();\n\n        uint256 previousBlockNumber = oracle.latestBlockNumber() - submissionInterval;\n        L2OutputOracle.OutputProposal memory proposalToDelete = oracle.getL2Output(\n            previousBlockNumber\n        );\n\n        vm.prank(owner);\n        vm.expectRevert(\n            \"OutputOracle: The output root to delete does not match the latest output proposal.\"\n        );\n        oracle.deleteL2Output(proposalToDelete);\n    }\n\n    function testCannot_deleteL2Output_withWrongTime() external {\n        test_appendingAnotherOutput();\n\n        uint256 latestBlockNumber = oracle.latestBlockNumber();\n        L2OutputOracle.OutputProposal memory proposalToDelete = oracle.getL2Output(\n            latestBlockNumber\n        );\n\n        // Modify the timestamp so that it does not match.\n        proposalToDelete.timestamp -= 1;\n        vm.prank(owner);\n        vm.expectRevert(\n            \"OutputOracle: The timestamp to delete does not match the latest output proposal.\"\n        );\n        oracle.deleteL2Output(proposalToDelete);\n    }\n}\n\ncontract L2OutputOracleUpgradeable_Test is L2OutputOracle_Initializer {\n    Proxy internal proxy;\n\n    function setUp() public override {\n        super.setUp();\n        proxy = Proxy(payable(address(oracle)));\n    }\n\n    function test_initValuesOnProxy() external {\n        assertEq(submissionInterval, oracleImpl.SUBMISSION_INTERVAL());\n        assertEq(historicalTotalBlocks, oracleImpl.HISTORICAL_TOTAL_BLOCKS());\n        assertEq(startingBlockNumber, oracleImpl.STARTING_BLOCK_NUMBER());\n        assertEq(startingTimestamp, oracleImpl.STARTING_TIMESTAMP());\n        assertEq(l2BlockTime, oracleImpl.L2_BLOCK_TIME());\n\n        L2OutputOracle.OutputProposal memory initOutput = oracleImpl.getL2Output(\n            startingBlockNumber\n        );\n        assertEq(genesisL2Output, initOutput.outputRoot);\n        assertEq(initL1Time, initOutput.timestamp);\n\n        assertEq(sequencer, oracleImpl.sequencer());\n        assertEq(owner, oracleImpl.owner());\n    }\n\n    function test_cannotInitProxy() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        address(proxy).call(abi.encodeWithSelector(L2OutputOracle.initialize.selector));\n    }\n\n    function test_cannotInitImpl() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        address(oracleImpl).call(abi.encodeWithSelector(L2OutputOracle.initialize.selector));\n    }\n\n    function test_upgrading() external {\n        // Check an unused slot before upgrading.\n        bytes32 slot21Before = vm.load(address(oracle), bytes32(uint256(21)));\n        assertEq(bytes32(0), slot21Before);\n\n        NextImpl nextImpl = new NextImpl();\n        vm.startPrank(alice);\n        proxy.upgradeToAndCall(\n            address(nextImpl),\n            abi.encodeWithSelector(NextImpl.initialize.selector)\n        );\n        assertEq(proxy.implementation(), address(nextImpl));\n\n        // Verify that the NextImpl contract initialized its values according as expected\n        bytes32 slot21After = vm.load(address(oracle), bytes32(uint256(21)));\n        bytes32 slot21Expected = NextImpl(address(oracle)).slot21Init();\n        assertEq(slot21Expected, slot21After);\n    }\n}\n"
    },
    "contracts/test/L2StandardBridge.t.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport { stdStorage, StdStorage } from \"forge-std/Test.sol\";\nimport { CrossDomainMessenger } from \"../universal/CrossDomainMessenger.sol\";\nimport { Lib_PredeployAddresses } from \"../libraries/Lib_PredeployAddresses.sol\";\nimport { console } from \"forge-std/console.sol\";\n\ncontract L2StandardBridge_Test is Bridge_Initializer {\n    using stdStorage for StdStorage;\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_initialize() external {\n        assertEq(\n            address(L2Bridge.messenger()),\n            address(L2Messenger)\n        );\n\n        assertEq(\n            address(L2Bridge.otherBridge()),\n            address(L1Bridge)\n        );\n    }\n\n    // receive\n    // - can accept ETH\n    function test_receive() external {\n        assertEq(address(messagePasser).balance, 0);\n\n        vm.expectEmit(true, true, true, true);\n        emit ETHBridgeInitiated(alice, alice, 100, hex\"\");\n\n        // TODO: L2Messenger should be called\n        // TODO: L2ToL1MessagePasser should be called\n        // TODO: withdrawal hash should be computed correctly\n        // TODO: events from each contract\n\n        vm.prank(alice, alice);\n        address(L2Bridge).call{ value: 100 }(hex\"\");\n        assertEq(address(messagePasser).balance, 100);\n    }\n\n    // withrdraw\n    // - requires amount == msg.value\n    function test_cannotWithdrawEthWithoutSendingIt() external {\n        assertEq(address(messagePasser).balance, 0);\n\n        vm.expectRevert(\"ETH withdrawals must include sufficient ETH value.\");\n        vm.prank(alice, alice);\n        L2Bridge.withdraw(\n            address(Lib_PredeployAddresses.OVM_ETH),\n            100,\n            1000,\n            hex\"\"\n        );\n    }\n\n    // withdraw\n    // - token is burned\n    // - emits WithdrawalInitiated\n    // - calls Withdrawer.initiateWithdrawal\n    function test_withdraw() external {\n        // Alice has 100 L2Token\n        deal(address(L2Token), alice, 100, true);\n        assertEq(L2Token.balanceOf(alice), 100);\n\n        vm.prank(alice, alice);\n        L2Bridge.withdraw(\n            address(L2Token),\n            100,\n            1000,\n            hex\"\"\n        );\n\n        // TODO: events and calls\n\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n\n    function test_withdraw_onlyEOA() external {\n        // This contract has 100 L2Token\n        deal(address(L2Token), address(this), 100, true);\n\n        vm.expectRevert(\"Account not EOA\");\n        L2Bridge.withdraw(\n            address(L2Token),\n            100,\n            1000,\n            hex\"\"\n        );\n    }\n\n    // withdrawTo\n    // - token is burned\n    // - emits WithdrawalInitiated w/ correct recipient\n    // - calls Withdrawer.initiateWithdrawal\n    function test_withdrawTo() external {\n        deal(address(L2Token), alice, 100, true);\n\n        vm.prank(alice, alice);\n        L2Bridge.withdrawTo(\n            address(L2Token),\n            bob,\n            100,\n            1000,\n            hex\"\"\n        );\n\n        // TODO: events and calls\n\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n\n    // finalizeDeposit\n    // - only callable by l1TokenBridge\n    // - supported token pair emits DepositFinalized\n    // - invalid deposit emits DepositFailed\n    // - invalid deposit calls Withdrawer.initiateWithdrawal\n    function test_finalizeDeposit() external {\n        // TODO: events and calls\n\n        vm.mockCall(\n            address(L2Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.otherBridge()))\n        );\n        vm.prank(address(L2Messenger));\n        L2Bridge.finalizeDeposit(\n            address(L1Token),\n            address(L2Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n    }\n\n    // finalizeDeposit\n    // - only callable by l1TokenBridge\n    // - supported token pair emits DepositFinalized\n    // - invalid deposit emits DepositFailed\n    // - invalid deposit calls Withdrawer.initiateWithdrawal\n    function test_finalizeDeposit_failsToCompleteOutboundTransfer() external {\n        // TODO: events and calls\n        vm.mockCall(\n            address(L2Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.otherBridge()))\n        );\n        address invalidL2Token = address(0x1234);\n        vm.prank(address(L2Messenger));\n        vm.expectEmit(true, true, true, true);\n        emit ERC20BridgeInitiated(\n            invalidL2Token,\n            address(L1Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n        vm.expectEmit(true, true, true, true);\n        emit ERC20BridgeFailed(\n            invalidL2Token,\n            address(L1Token),\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n        L2Bridge.finalizeDeposit(\n            address(L1Token),\n            invalidL2Token,\n            alice,\n            alice,\n            100,\n            hex\"\"\n        );\n    }\n\n    // finalizeBridgeERC20\n    // - fails when the local token's address equals bridge address\n    function test_ERC20BridgeFailed_whenLocalTokenIsBridge() external {\n        vm.mockCall(\n            address(L2Bridge.messenger()),\n            abi.encodeWithSelector(CrossDomainMessenger.xDomainMessageSender.selector),\n            abi.encode(address(L2Bridge.otherBridge()))\n        );\n        // fails when the local token's address equals bridge address\n        vm.expectEmit(true, true, true, true);\n        emit ERC20BridgeFailed(address(L2Bridge), address(L1Token), alice, bob, 100, hex\"\");\n\n        vm.prank(address(L2Messenger));\n        L2Bridge.finalizeDeposit(address(L1Token), address(L2Bridge), alice, bob, 100, hex\"\");\n    }\n}\n\n"
    },
    "contracts/test/L2ToL1MessagePasser.t.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { L2ToL1MessagePasser } from \"../L2/L2ToL1MessagePasser.sol\";\nimport { WithdrawalVerifier } from \"../libraries/Lib_WithdrawalVerifier.sol\";\n\ncontract L2ToL1MessagePasserTest is CommonTest {\n    L2ToL1MessagePasser messagePasser;\n\n    event WithdrawalInitiated(\n        uint256 indexed nonce,\n        address indexed sender,\n        address indexed target,\n        uint256 value,\n        uint256 gasLimit,\n        bytes data\n    );\n\n    event WithdrawerBalanceBurnt(uint256 indexed amount);\n\n    function setUp() virtual public {\n        messagePasser = new L2ToL1MessagePasser();\n    }\n\n    // Test: initiateWithdrawal should emit the correct log when called by a contract\n    function test_initiateWithdrawal_fromContract() external {\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalInitiated(\n            messagePasser.nonce(),\n            address(this),\n            address(4),\n            100,\n            64000,\n            hex\"\"\n        );\n\n        vm.deal(address(this), 2**64);\n        messagePasser.initiateWithdrawal{ value: 100 }(\n            address(4),\n            64000,\n            hex\"\"\n        );\n    }\n\n    // Test: initiateWithdrawal should emit the correct log when called by an EOA\n    function test_initiateWithdrawal_fromEOA() external {\n        uint256 gasLimit = 64000;\n        address target = address(4);\n        uint256 value = 100;\n        bytes memory data = hex\"ff\";\n        uint256 nonce = messagePasser.nonce();\n\n        // EOA emulation\n        vm.prank(alice, alice);\n        vm.deal(alice, 2**64);\n        vm.expectEmit(true, true, true, true);\n        emit WithdrawalInitiated(\n            nonce,\n            alice,\n            target,\n            value,\n            gasLimit,\n            data\n        );\n\n        bytes32 withdrawalHash = WithdrawalVerifier.withdrawalHash(\n            nonce,\n            alice,\n            target,\n            value,\n            gasLimit,\n            data\n        );\n\n        messagePasser.initiateWithdrawal{ value: value }(\n            target,\n            gasLimit,\n            data\n        );\n\n        // the sent messages mapping is filled\n        assertEq(messagePasser.sentMessages(withdrawalHash), true);\n        // the nonce increments\n        assertEq(nonce + 1, messagePasser.nonce());\n    }\n\n    // Test: burn should destroy the ETH held in the contract\n    function test_burn() external {\n        messagePasser.initiateWithdrawal{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            NON_ZERO_GASLIMIT,\n            NON_ZERO_DATA\n        );\n\n        assertEq(address(messagePasser).balance, NON_ZERO_VALUE);\n        vm.expectEmit(true, false, false, false);\n        emit WithdrawerBalanceBurnt(NON_ZERO_VALUE);\n        messagePasser.burn();\n\n        // The Withdrawer should have no balance\n        assertEq(address(messagePasser).balance, 0);\n    }\n}\n"
    },
    "contracts/test/Lib_RLP.t.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.0;\n\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\n// prettier-ignore\nlibrary LibRLP {\n    using Bytes32AddressLib for bytes32;\n\n    function computeAddress(address deployer, uint256 nonce) public pure returns (address) {\n        // The integer zero is treated as an empty byte string, and as a result it only has a length prefix, 0x80, computed via 0x80 + 0.\n        // A one byte integer uses its own value as its length prefix, there is no additional \"0x80 + length\" prefix that comes before it.\n        if (nonce == 0x00)             return keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, bytes1(0x80))).fromLast20Bytes();\n        if (nonce <= 0x7f)             return keccak256(abi.encodePacked(bytes1(0xd6), bytes1(0x94), deployer, uint8(nonce))).fromLast20Bytes();\n\n        // Nonces greater than 1 byte all follow a consistent encoding scheme, where each value is preceded by a prefix of 0x80 + length.\n        if (nonce <= type(uint8).max)  return keccak256(abi.encodePacked(bytes1(0xd7), bytes1(0x94), deployer, bytes1(0x81), uint8(nonce))).fromLast20Bytes();\n        if (nonce <= type(uint16).max) return keccak256(abi.encodePacked(bytes1(0xd8), bytes1(0x94), deployer, bytes1(0x82), uint16(nonce))).fromLast20Bytes();\n        if (nonce <= type(uint24).max) return keccak256(abi.encodePacked(bytes1(0xd9), bytes1(0x94), deployer, bytes1(0x83), uint24(nonce))).fromLast20Bytes();\n\n        // More details about RLP encoding can be found here: https://eth.wiki/fundamentals/rlp\n        // 0xda = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x84 ++ nonce)\n        // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex)\n        // 0x84 = 0x80 + 0x04 (0x04 = the bytes length of the nonce, 4 bytes, in hex)\n        // We assume nobody can have a nonce large enough to require more than 32 bytes.\n        return keccak256(abi.encodePacked(bytes1(0xda), bytes1(0x94), deployer, bytes1(0x84), uint32(nonce))).fromLast20Bytes();\n    }\n}\n"
    },
    "contracts/test/OVM_ETH.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { OVM_ETH } from \"../L2/OVM_ETH.sol\";\nimport { Lib_PredeployAddresses } from \"../libraries/Lib_PredeployAddresses.sol\";\n\ncontract OVM_ETH_Test is CommonTest {\n    OVM_ETH eth;\n\n    function setUp() external {\n        eth = new OVM_ETH();\n    }\n\n    function test_metadata() external {\n        assertEq(eth.name(), \"Ether\");\n        assertEq(eth.symbol(), \"ETH\");\n        assertEq(eth.decimals(), 18);\n    }\n\n    function test_crossDomain() external {\n        assertEq(eth.l2Bridge(), Lib_PredeployAddresses.L2_STANDARD_BRIDGE);\n        assertEq(eth.l1Token(), address(0));\n    }\n\n    function test_transfer() external {\n        vm.expectRevert(\"OVM_ETH: transfer is disabled\");\n        eth.transfer(alice, 100);\n    }\n\n    function test_approve() external {\n        vm.expectRevert(\"OVM_ETH: approve is disabled\");\n        eth.approve(alice, 100);\n    }\n\n    function test_transferFrom() external {\n        vm.expectRevert(\"OVM_ETH: transferFrom is disabled\");\n        eth.transferFrom(bob, alice, 100);\n    }\n\n    function test_increaseAllowance() external {\n        vm.expectRevert(\"OVM_ETH: increaseAllowance is disabled\");\n        eth.increaseAllowance(alice, 100);\n    }\n\n    function test_decreaseAllowance() external {\n        vm.expectRevert(\"OVM_ETH: decreaseAllowance is disabled\");\n        eth.decreaseAllowance(alice, 100);\n    }\n\n    function test_mint() external {\n        vm.expectRevert(\"OVM_ETH: mint is disabled\");\n        eth.mint(alice, 100);\n    }\n\n    function test_burn() external {\n        vm.expectRevert(\"OVM_ETH: burn is disabled\");\n        eth.burn(alice, 100);\n    }\n}\n"
    },
    "contracts/test/OptimismMintableERC20.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport { LibRLP } from \"./Lib_RLP.t.sol\";\nimport \"../universal/SupportedInterfaces.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ncontract OptimismMintableERC20_Test is Bridge_Initializer {\n    event Mint(address indexed _account, uint256 _amount);\n    event Burn(address indexed _account, uint256 _amount);\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_remoteToken() external {\n        assertEq(L2Token.remoteToken(), address(L1Token));\n    }\n\n    function test_bridge() external {\n        assertEq(L2Token.bridge(), address(L2Bridge));\n    }\n\n    function test_l1Token() external {\n        assertEq(L2Token.l1Token(), address(L1Token));\n    }\n\n    function test_l2Bridge() external {\n        assertEq(L2Token.l2Bridge(), address(L2Bridge));\n    }\n\n    function test_mint() external {\n        vm.expectEmit(true, true, true, true);\n        emit Mint(alice, 100);\n\n        vm.prank(address(L2Bridge));\n        L2Token.mint(alice, 100);\n\n        assertEq(L2Token.balanceOf(alice), 100);\n    }\n\n    function test_mintRevertsFromNotBridge() external {\n        // NOT the bridge\n        vm.expectRevert(\"Only L2 Bridge can mint and burn\");\n        vm.prank(address(alice));\n        L2Token.mint(alice, 100);\n    }\n\n    function test_burn() external {\n        vm.prank(address(L2Bridge));\n        L2Token.mint(alice, 100);\n\n        vm.expectEmit(true, true, true, true);\n        emit Burn(alice, 100);\n\n        vm.prank(address(L2Bridge));\n        L2Token.burn(alice, 100);\n\n        assertEq(L2Token.balanceOf(alice), 0);\n    }\n\n    function test_burnRevertsFromNotBridge() external {\n        // NOT the bridge\n        vm.expectRevert(\"Only L2 Bridge can mint and burn\");\n        vm.prank(address(alice));\n        L2Token.burn(alice, 100);\n    }\n\n    function test_erc165_supportsInterface() external {\n        // The assertEq calls in this test are comparing the manual calculation of the iface,\n        // with what is returned by the solidity's type().interfaceId, just to be safe.\n        bytes4 iface1 = bytes4(keccak256(\"supportsInterface(bytes4)\"));\n        assertEq(iface1, type(IERC165).interfaceId);\n        assert(L2Token.supportsInterface(iface1));\n\n        bytes4 iface2 = L2Token.l1Token.selector ^ L2Token.mint.selector ^ L2Token.burn.selector;\n        assertEq(iface2, type(IL1Token).interfaceId);\n        assert(L2Token.supportsInterface(iface2));\n\n        bytes4 iface3 = L2Token.remoteToken.selector ^ L2Token.mint.selector ^ L2Token.burn.selector;\n        assertEq(iface3, type(IRemoteToken).interfaceId);\n        assert(L2Token.supportsInterface(iface3));\n    }\n}\n"
    },
    "contracts/test/OptimismMintableTokenFactory.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\nimport { LibRLP } from \"./Lib_RLP.t.sol\";\n\ncontract OptimismMintableTokenFactory_Test is Bridge_Initializer {\n    event StandardL2TokenCreated(address indexed _remoteToken, address indexed _localToken);\n    event OptimismMintableTokenCreated(\n        address indexed _localToken,\n        address indexed _remoteToken,\n        address _deployer\n    );\n\n    function setUp() public override {\n        super.setUp();\n    }\n\n    function test_initializeShouldRevert() external {\n        vm.expectRevert(\"Already initialized.\");\n        L2TokenFactory.initialize(address(L1Bridge));\n    }\n\n    function test_bridge() external {\n        assertEq(address(L2TokenFactory.bridge()), address(L2Bridge));\n    }\n\n    function test_createStandardL2Token() external {\n        address remote = address(4);\n        address local = LibRLP.computeAddress(address(L2TokenFactory), 1);\n\n        vm.expectEmit(true, true, true, true);\n        emit StandardL2TokenCreated(\n            remote,\n            local\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit OptimismMintableTokenCreated(\n            remote,\n            local,\n            alice\n        );\n\n        vm.prank(alice);\n        L2TokenFactory.createStandardL2Token(remote, \"Beep\", \"BOOP\");\n    }\n\n    function test_createStandardL2TokenSameTwice() external {\n        address remote = address(4);\n\n        vm.prank(alice);\n        L2TokenFactory.createStandardL2Token(remote, \"Beep\", \"BOOP\");\n\n        address local = LibRLP.computeAddress(address(L2TokenFactory), 2);\n\n        vm.expectEmit(true, true, true, true);\n        emit StandardL2TokenCreated(\n            remote,\n            local\n        );\n\n        vm.expectEmit(true, true, true, true);\n        emit OptimismMintableTokenCreated(\n            remote,\n            local,\n            alice\n        );\n\n        vm.prank(alice);\n        L2TokenFactory.createStandardL2Token(remote, \"Beep\", \"BOOP\");\n    }\n\n    function test_createStandardL2TokenShouldRevertIfRemoteIsZero() external {\n        address remote = address(0);\n        vm.expectRevert(\"Must provide L1 token address\");\n        L2TokenFactory.createStandardL2Token(remote, \"Beep\", \"BOOP\");\n    }\n}\n"
    },
    "contracts/test/OptimismPortal.t.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { Portal_Initializer, CommonTest, NextImpl } from \"./CommonTest.t.sol\";\n\nimport { AddressAliasHelper } from \"../libraries/AddressAliasHelper.sol\";\nimport { L2OutputOracle } from \"../L1/L2OutputOracle.sol\";\nimport { OptimismPortal } from \"../L1/OptimismPortal.sol\";\nimport { WithdrawalVerifier } from \"../libraries/Lib_WithdrawalVerifier.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\n\ncontract OptimismPortal_Test is Portal_Initializer {\n    event TransactionDeposited(\n        address indexed from,\n        address indexed to,\n        uint256 mint,\n        uint256 value,\n        uint64 gasLimit,\n        bool isCreation,\n        bytes data\n    );\n\n    function test_OptimismPortalConstructor() external {\n        assertEq(op.FINALIZATION_PERIOD_SECONDS(), 7 days);\n        assertEq(address(op.L2_ORACLE()), address(oracle));\n        assertEq(op.l2Sender(), 0x000000000000000000000000000000000000dEaD);\n    }\n\n    function test_OptimismPortalReceiveEth() external {\n        vm.expectEmit(true, true, false, true);\n        emit TransactionDeposited(alice, alice, 100, 100, 100_000, false, hex\"\");\n\n        // give alice money and send as an eoa\n        vm.deal(alice, 2**64);\n        vm.prank(alice, alice);\n        (bool s, ) = address(op).call{ value: 100 }(hex\"\");\n\n        assert(s);\n        assertEq(address(op).balance, 100);\n    }\n\n    // function test_OptimismPortalDepositTransaction() external {}\n\n    // Test: depositTransaction fails when contract creation has a non-zero destination address\n    function test_OptimismPortalContractCreationReverts() external {\n        // contract creation must have a target of address(0)\n        vm.expectRevert(\"OptimismPortal: must send to address(0) when creating a contract\");\n        op.depositTransaction(address(1), 1, 0, true, hex\"\");\n    }\n\n    // Test: depositTransaction should emit the correct log when an EOA deposits a tx with 0 value\n    function test_depositTransaction_NoValueEOA() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n        vm.expectEmit(true, true, false, true);\n        emit TransactionDeposited(\n            address(this),\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    // Test: depositTransaction should emit the correct log when a contract deposits a tx with 0 value\n    function test_depositTransaction_NoValueContract() external {\n        vm.expectEmit(true, true, false, true);\n        emit TransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    // Test: depositTransaction should emit the correct log when an EOA deposits a contract creation with 0 value\n    function test_depositTransaction_createWithZeroValueForEOA() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n\n        vm.expectEmit(true, true, false, true);\n        emit TransactionDeposited(\n            address(this),\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction(ZERO_ADDRESS, ZERO_VALUE, NON_ZERO_GASLIMIT, true, NON_ZERO_DATA);\n    }\n\n    // Test: depositTransaction should emit the correct log when a contract deposits a contract creation with 0 value\n    function test_depositTransaction_createWithZeroValueForContract() external {\n        vm.expectEmit(true, true, false, true);\n        emit TransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction(ZERO_ADDRESS, ZERO_VALUE, NON_ZERO_GASLIMIT, true, NON_ZERO_DATA);\n    }\n\n    // Test: depositTransaction should increase its eth balance when an EOA deposits a transaction with ETH\n    function test_depositTransaction_withEthValueFromEOA() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n\n        vm.expectEmit(true, true, false, true);\n        emit TransactionDeposited(\n            address(this),\n            NON_ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n        assertEq(address(op).balance, NON_ZERO_VALUE);\n    }\n\n    // Test: depositTransaction should increase its eth balance when a contract deposits a transaction with ETH\n    function test_depositTransaction_withEthValueFromContract() external {\n        vm.expectEmit(true, true, false, true);\n        emit TransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            NON_ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction{ value: NON_ZERO_VALUE }(\n            NON_ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            false,\n            NON_ZERO_DATA\n        );\n    }\n\n    // Test: depositTransaction should increase its eth balance when an EOA deposits a contract creation with ETH\n    function test_depositTransaction_withEthValueAndEOAContractCreation() external {\n        // EOA emulation\n        vm.prank(address(this), address(this));\n\n        vm.expectEmit(true, true, false, true);\n        emit TransactionDeposited(\n            address(this),\n            ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            hex\"\"\n        );\n\n        op.depositTransaction{ value: NON_ZERO_VALUE }(\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            hex\"\"\n        );\n        assertEq(address(op).balance, NON_ZERO_VALUE);\n    }\n\n    // Test: depositTransaction should increase its eth balance when a contract deposits a contract creation with ETH\n    function test_depositTransaction_withEthValueAndContractContractCreation() external {\n        vm.expectEmit(true, true, false, true);\n        emit TransactionDeposited(\n            AddressAliasHelper.applyL1ToL2Alias(address(this)),\n            ZERO_ADDRESS,\n            NON_ZERO_VALUE,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n\n        op.depositTransaction{ value: NON_ZERO_VALUE }(\n            ZERO_ADDRESS,\n            ZERO_VALUE,\n            NON_ZERO_GASLIMIT,\n            true,\n            NON_ZERO_DATA\n        );\n        assertEq(address(op).balance, NON_ZERO_VALUE);\n    }\n\n    // TODO: test this deeply\n    // function test_verifyWithdrawal() external {}\n\n    function test_cannotVerifyRecentWithdrawal() external {\n        WithdrawalVerifier.OutputRootProof memory outputRootProof = WithdrawalVerifier\n            .OutputRootProof({\n                version: bytes32(0),\n                stateRoot: bytes32(0),\n                withdrawerStorageRoot: bytes32(0),\n                latestBlockhash: bytes32(0)\n            });\n\n        vm.expectRevert(\"OptimismPortal: proposal is not yet finalized\");\n        op.finalizeWithdrawalTransaction(0, alice, alice, 0, 0, hex\"\", 0, outputRootProof, hex\"\");\n    }\n\n    function test_invalidWithdrawalProof() external {\n        WithdrawalVerifier.OutputRootProof memory outputRootProof = WithdrawalVerifier\n            .OutputRootProof({\n                version: bytes32(0),\n                stateRoot: bytes32(0),\n                withdrawerStorageRoot: bytes32(0),\n                latestBlockhash: bytes32(0)\n            });\n\n        vm.warp(\n            oracle.getL2Output(\n                oracle.latestBlockNumber()\n            ).timestamp\n            + op.FINALIZATION_PERIOD_SECONDS()\n        );\n\n        vm.expectRevert(\"OptimismPortal: invalid output root proof\");\n        op.finalizeWithdrawalTransaction(0, alice, alice, 0, 0, hex\"\", 0, outputRootProof, hex\"\");\n    }\n\n    function test_simple_isOutputFinalized() external {\n        vm.mockCall(\n            address(op.L2_ORACLE()),\n            abi.encodeWithSelector(\n                L2OutputOracle.getL2Output.selector\n            ),\n            abi.encode(\n                L2OutputOracle.OutputProposal(\n                    bytes32(uint256(1)),\n                    0\n                )\n            )\n        );\n\n        // warp to the finalization period\n        vm.warp(op.FINALIZATION_PERIOD_SECONDS());\n        assertEq(op.isOutputFinalized(0), false);\n        // warp past the finalization period\n        vm.warp(op.FINALIZATION_PERIOD_SECONDS() + 1);\n        assertEq(op.isOutputFinalized(0), true);\n    }\n\n    function test_isOutputFinalized() external {\n        uint256 checkpoint = oracle.nextBlockNumber();\n        vm.roll(checkpoint);\n        vm.warp(oracle.computeL2Timestamp(checkpoint) + 1);\n        vm.prank(oracle.sequencer());\n        oracle.appendL2Output(keccak256(abi.encode(2)), checkpoint, 0, 0);\n\n        // warp to the final second of the finalization period\n        uint256 finalizationHorizon = block.timestamp + op.FINALIZATION_PERIOD_SECONDS();\n        vm.warp(finalizationHorizon);\n        // The checkpointed block should not be finalized until 1 second from now.\n        assertEq(op.isOutputFinalized(checkpoint), false);\n        // Nor should a block after it\n        assertEq(op.isOutputFinalized(checkpoint + 1), false);\n        // Nor a block before it, even though the finalization period has passed, there is\n        // not yet a checkpoint block on top of it for which that is true.\n        assertEq(op.isOutputFinalized(checkpoint - 1), false);\n\n        // warp past the finalization period\n        vm.warp(finalizationHorizon + 1);\n        // It should now be finalized.\n        assertEq(op.isOutputFinalized(checkpoint), true);\n        // So should the block before it.\n        assertEq(op.isOutputFinalized(checkpoint - 1), true);\n        // But not the block after it.\n        assertEq(op.isOutputFinalized(checkpoint + 1), false);\n    }\n}\n\ncontract OptimismPortalUpgradeable_Test is Portal_Initializer {\n    Proxy internal proxy;\n    uint64 initialBlockNum;\n\n    function setUp() public override {\n        super.setUp();\n        initialBlockNum = uint64(block.number);\n        proxy = Proxy(payable(address(op)));\n    }\n\n    function test_initValuesOnProxy() external {\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = OptimismPortal(\n            payable(address(proxy))\n        ).params();\n        assertEq(prevBaseFee, opImpl.INITIAL_BASE_FEE());\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum);\n    }\n\n    function test_cannotInitProxy() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        address(proxy).call(abi.encodeWithSelector(OptimismPortal.initialize.selector));\n    }\n\n    function test_cannotInitImpl() external {\n        vm.expectRevert(\"Initializable: contract is already initialized\");\n        address(opImpl).call(abi.encodeWithSelector(OptimismPortal.initialize.selector));\n    }\n\n    function test_upgrading() external {\n        // Check an unused slot before upgrading.\n        bytes32 slot21Before = vm.load(address(op), bytes32(uint256(21)));\n        assertEq(bytes32(0), slot21Before);\n\n        NextImpl nextImpl = new NextImpl();\n        vm.startPrank(alice);\n        proxy.upgradeToAndCall(\n            address(nextImpl),\n            abi.encodeWithSelector(NextImpl.initialize.selector)\n        );\n        assertEq(proxy.implementation(), address(nextImpl));\n\n        // Verify that the NextImpl contract initialized its values according as expected\n        bytes32 slot21After = vm.load(address(op), bytes32(uint256(21)));\n        bytes32 slot21Expected = NextImpl(address(op)).slot21Init();\n        assertEq(slot21Expected, slot21After);\n    }\n}\n"
    },
    "contracts/test/Proxy.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { Bytes32AddressLib } from \"@rari-capital/solmate/src/utils/Bytes32AddressLib.sol\";\n\ncontract SimpleStorage {\n    mapping(uint256 => uint256) internal store;\n\n    function get(uint256 key) external payable returns (uint256) {\n        return store[key];\n    }\n\n    function set(uint256 key, uint256 value) external payable {\n        store[key] = value;\n    }\n}\n\ncontract Clasher {\n    function upgradeTo(address _implementation) external view {\n        revert(\"upgradeTo\");\n    }\n}\n\ncontract Proxy_Test is Test {\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    address alice = address(64);\n\n    bytes32 internal constant IMPLEMENTATION_KEY =\n        bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1);\n\n    bytes32 internal constant OWNER_KEY =\n        bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1);\n\n    Proxy proxy;\n    SimpleStorage simpleStorage;\n\n    function setUp() external {\n        // Deploy a proxy and simple storage contract as\n        // the implementation\n        proxy = new Proxy(alice);\n        simpleStorage = new SimpleStorage();\n\n        vm.prank(alice);\n        proxy.upgradeTo(address(simpleStorage));\n    }\n\n    function test_implementationKey() external {\n        // The hardcoded implementation key should be correct\n        vm.prank(alice);\n        proxy.upgradeTo(address(6));\n\n        bytes32 key = vm.load(address(proxy), IMPLEMENTATION_KEY);\n        assertEq(\n            address(6),\n            Bytes32AddressLib.fromLast20Bytes(key)\n        );\n\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(6));\n    }\n\n    function test_ownerKey() external {\n        // The hardcoded owner key should be correct\n        vm.prank(alice);\n        proxy.changeAdmin(address(6));\n\n        bytes32 key = vm.load(address(proxy), OWNER_KEY);\n        assertEq(\n            address(6),\n            Bytes32AddressLib.fromLast20Bytes(key)\n        );\n\n        vm.prank(address(6));\n        address owner = proxy.admin();\n        assertEq(owner, address(6));\n    }\n\n    function test_implementationProxyCallIfNotAdmin() external {\n        // The implementation does not have a `upgradeTo`\n        // method, calling `upgradeTo` not as the owner\n        // should revert.\n        vm.expectRevert();\n        proxy.upgradeTo(address(64));\n\n        // Call `upgradeTo` as the owner, it should succeed\n        // and emit the `Upgraded` event.\n        vm.expectEmit(true, true, true, true);\n        emit Upgraded(address(64));\n        vm.prank(alice);\n        proxy.upgradeTo(address(64));\n\n        // Get the implementation as the owner\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(64));\n    }\n\n    function test_ownerProxyCallIfNotAdmin() external {\n        // Calling `changeAdmin` not as the owner should revert\n        // as the implementation does not have a `changeAdmin` method.\n        vm.expectRevert();\n        proxy.changeAdmin(address(1));\n\n        // Call `changeAdmin` as the owner, it should succeed\n        // and emit the `AdminChanged` event.\n        vm.expectEmit(true, true, true, true);\n        emit AdminChanged(alice, address(1));\n        vm.prank(alice);\n        proxy.changeAdmin(address(1));\n\n        // Calling `admin` not as the owner should\n        // revert as the implementation does not have\n        // a `admin` method.\n        vm.expectRevert();\n        proxy.admin();\n\n        // Calling `admin` as the owner should work.\n        vm.prank(address(1));\n        address owner = proxy.admin();\n        assertEq(owner, address(1));\n    }\n\n    function test_itDelegatesToTheImplementation() external {\n        // Call the storage setter on the proxy\n        SimpleStorage(address(proxy)).set(1, 1);\n\n        // The key should not be set in the implementation\n        uint256 result = simpleStorage.get(1);\n        assertEq(result, 0);\n        {\n            // The key should be set in the proxy\n            uint256 expect = SimpleStorage(address(proxy)).get(1);\n            assertEq(expect, 1);\n        }\n\n        {\n            // The owner should be able to call through the proxy\n            // when there is not a function selector crash\n            vm.prank(alice);\n            uint256 expect = SimpleStorage(address(proxy)).get(1);\n            assertEq(expect, 1);\n        }\n    }\n\n    function test_upgradeToAndCall() external {\n        {\n            // There should be nothing in the current proxy storage\n            uint256 result = SimpleStorage(address(proxy)).get(1);\n            assertEq(result, 0);\n        }\n\n        // Deploy a new SimpleStorage\n        simpleStorage = new SimpleStorage();\n\n        // Set the new SimpleStorage as the implementation\n        // and call.\n        vm.expectEmit(true, true, true, true);\n        emit Upgraded(address(simpleStorage));\n        vm.prank(alice);\n        proxy.upgradeToAndCall(\n            address(simpleStorage),\n            abi.encodeWithSelector(simpleStorage.set.selector, 1, 1)\n        );\n\n        // The call should have impacted the state\n        uint256 result = SimpleStorage(address(proxy)).get(1);\n        assertEq(result, 1);\n    }\n\n    function test_revertUpgradeToAndCall() external {\n        // Get the current implementation address\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(simpleStorage));\n\n        // Deploy a new SimpleStorage\n        simpleStorage = new SimpleStorage();\n\n        // Set the new SimpleStorage as the implementation\n        // and call. This reverts because the calldata doesn't\n        // match a function on the implementation.\n        vm.expectRevert();\n        vm.prank(alice);\n        proxy.upgradeToAndCall(\n            address(simpleStorage),\n            hex\"\"\n        );\n\n        // The implementation address should have not\n        // updated because the call to `upgradeToAndCall`\n        // reverted.\n        vm.prank(alice);\n        address postImpl = proxy.implementation();\n        assertEq(impl, postImpl);\n\n        // The attempt to `upgradeToAndCall`\n        // should revert when it is not called by the owner.\n        vm.expectRevert();\n        proxy.upgradeToAndCall(\n            address(simpleStorage),\n            abi.encodeWithSelector(simpleStorage.set.selector, 1, 1)\n        );\n    }\n\n    function test_payableUpgradeToAndCall() external {\n        // Give alice some funds\n        vm.deal(alice, 1 ether);\n        // Set the implementation and call and send\n        // value.\n        vm.prank(alice);\n        proxy.upgradeToAndCall{ value: 1 ether }(\n            address(simpleStorage),\n            abi.encodeWithSelector(simpleStorage.set.selector, 1, 1)\n        );\n\n        // The implementation address should be correct\n        vm.prank(alice);\n        address impl = proxy.implementation();\n        assertEq(impl, address(simpleStorage));\n\n        // The proxy should have a balance\n        assertEq(address(proxy).balance, 1 ether);\n    }\n\n    function test_clashingFunctionSignatures() external {\n        // Clasher has a clashing function with the proxy.\n        Clasher clasher = new Clasher();\n\n        // Set the clasher as the implementation.\n        vm.prank(alice);\n        proxy.upgradeTo(address(clasher));\n\n        {\n            // Assert that the implementation was set properly.\n            vm.prank(alice);\n            address impl = proxy.implementation();\n            assertEq(impl, address(clasher));\n        }\n\n        // Call the clashing function on the proxy\n        // not as the owner so that the call passes through.\n        // The implementation will revert so we can be\n        // sure that the call passed through.\n        vm.expectRevert(bytes(\"upgradeTo\"));\n        proxy.upgradeTo(address(0));\n\n        {\n            // Now call the clashing function as the owner\n            // and be sure that it doesn't pass through to\n            // the implementation.\n            vm.prank(alice);\n            proxy.upgradeTo(address(0));\n            vm.prank(alice);\n            address impl = proxy.implementation();\n            assertEq(impl, address(0));\n        }\n    }\n\n    // Allow for `eth_call` to call proxy methods\n    // by setting \"from\" to `address(0)`.\n    function test_zeroAddressCaller() external {\n        vm.prank(address(0));\n        address impl = proxy.implementation();\n        assertEq(impl, address(simpleStorage));\n    }\n\n    function test_implementationZeroAddress() external {\n        // Set `address(0)` as the implementation.\n        vm.prank(alice);\n        proxy.upgradeTo(address(0));\n\n        (bool success, bytes memory returndata) = address(proxy).call(hex\"\");\n        assertEq(success, false);\n\n        bytes memory err = abi.encodeWithSignature(\n            \"Error(string)\",\n            \"Proxy: implementation not initialized\"\n        );\n\n        assertEq(returndata, err);\n    }\n}\n"
    },
    "contracts/test/ProxyAdmin.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { Test } from \"forge-std/Test.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\nimport { ProxyAdmin } from \"../universal/ProxyAdmin.sol\";\nimport { SimpleStorage } from \"./Proxy.t.sol\";\nimport { L1ChugSplashProxy } from \"../legacy/L1ChugSplashProxy.sol\";\nimport { Lib_ResolvedDelegateProxy } from \"../legacy/Lib_ResolvedDelegateProxy.sol\";\nimport { Lib_AddressManager } from \"../legacy/Lib_AddressManager.sol\";\n\ncontract ProxyAdmin_Test is Test {\n    address alice = address(64);\n\n    Proxy proxy;\n    L1ChugSplashProxy chugsplash;\n    Lib_ResolvedDelegateProxy resolved;\n\n    Lib_AddressManager addressManager;\n\n    ProxyAdmin admin;\n\n    SimpleStorage implementation;\n\n    function setUp() external {\n        // Deploy the proxy admin\n        admin = new ProxyAdmin(alice);\n        // Deploy the standard proxy\n        proxy = new Proxy(address(admin));\n\n        // Deploy the legacy L1ChugSplashProxy with the admin as the owner\n        chugsplash = new L1ChugSplashProxy(address(admin));\n\n        // Deploy the legacy Lib_AddressManager\n        addressManager = new Lib_AddressManager();\n        // The proxy admin must be the new owner of the address manager\n        addressManager.transferOwnership(address(admin));\n        // Deploy a legacy Lib_ResolvedDelegateProxy with the name `a`.\n        // Whatever `a` is set to in Lib_AddressManager will be the address\n        // that is used for the implementation.\n        resolved = new Lib_ResolvedDelegateProxy(address(addressManager), \"a\");\n\n        // Impersonate alice for setting up the admin.\n        vm.startPrank(alice);\n        // Set the address of the address manager in the admin so that it\n        // can resolve the implementation address of legacy\n        // Lib_ResolvedDelegateProxy based proxies.\n        admin.setAddressManager(addressManager);\n        // Set the reverse lookup of the Lib_ResolvedDelegateProxy\n        // proxy\n        admin.setImplementationName(address(resolved), \"a\");\n\n        // Set the proxy types\n        admin.setProxyType(address(proxy), ProxyAdmin.ProxyType.ERC1967);\n        admin.setProxyType(address(chugsplash), ProxyAdmin.ProxyType.Chugsplash);\n        admin.setProxyType(address(resolved), ProxyAdmin.ProxyType.ResolvedDelegate);\n        vm.stopPrank();\n\n        implementation = new SimpleStorage();\n    }\n\n    function test_setImplementationName() external {\n        vm.prank(alice);\n        admin.setImplementationName(address(1), \"foo\");\n        assertEq(\n            admin.implementationName(address(1)),\n            \"foo\"\n        );\n    }\n\n    function test_onlyOwnerSetAddressManager() external {\n        vm.expectRevert(\"UNAUTHORIZED\");\n        admin.setAddressManager(Lib_AddressManager((address(0))));\n    }\n\n    function test_onlyOwnerSetImplementationName() external {\n        vm.expectRevert(\"UNAUTHORIZED\");\n        admin.setImplementationName(address(0), \"foo\");\n    }\n\n    function test_onlyOwnerSetProxyType() external {\n        vm.expectRevert(\"UNAUTHORIZED\");\n        admin.setProxyType(address(0), ProxyAdmin.ProxyType.Chugsplash);\n    }\n\n    function test_owner() external {\n        assertEq(admin.owner(), alice);\n    }\n\n    function test_proxyType() external {\n        assertEq(\n            uint256(admin.proxyType(address(proxy))),\n            uint256(ProxyAdmin.ProxyType.ERC1967)\n        );\n        assertEq(\n            uint256(admin.proxyType(address(chugsplash))),\n            uint256(ProxyAdmin.ProxyType.Chugsplash)\n        );\n        assertEq(\n            uint256(admin.proxyType(address(resolved))),\n            uint256(ProxyAdmin.ProxyType.ResolvedDelegate)\n        );\n    }\n\n    function test_erc1967GetProxyImplementation() external {\n        getProxyImplementation(proxy);\n    }\n\n    function test_chugsplashGetProxyImplementation() external {\n        getProxyImplementation(Proxy(payable(chugsplash)));\n    }\n\n    function test_delegateResolvedGetProxyImplementation() external {\n        getProxyImplementation(Proxy(payable(resolved)));\n    }\n\n    function getProxyImplementation(Proxy _proxy) internal {\n        {\n            address impl = admin.getProxyImplementation(_proxy);\n            assertEq(impl, address(0));\n        }\n\n        vm.prank(alice);\n        admin.upgrade(_proxy, address(implementation));\n\n        {\n            address impl = admin.getProxyImplementation(_proxy);\n            assertEq(impl, address(implementation));\n        }\n    }\n\n    function test_erc1967GetProxyAdmin() external {\n        getProxyAdmin(proxy);\n    }\n\n    function test_chugsplashGetProxyAdmin() external {\n        getProxyAdmin(Proxy(payable(chugsplash)));\n    }\n\n    function test_delegateResolvedGetProxyAdmin() external {\n        getProxyAdmin(Proxy(payable(resolved)));\n    }\n\n    function getProxyAdmin(Proxy _proxy) internal {\n        address owner = admin.getProxyAdmin(_proxy);\n        assertEq(owner, address(admin));\n    }\n\n    function test_erc1967ChangeProxyAdmin() external {\n        changeProxyAdmin(proxy);\n    }\n\n    function test_chugsplashChangeProxyAdmin() external {\n        changeProxyAdmin(Proxy(payable(chugsplash)));\n    }\n\n    function test_delegateResolvedChangeProxyAdmin() external {\n        changeProxyAdmin(Proxy(payable(resolved)));\n    }\n\n    function changeProxyAdmin(Proxy _proxy) internal {\n        ProxyAdmin.ProxyType proxyType = admin.proxyType(address(_proxy));\n\n        vm.prank(alice);\n        admin.changeProxyAdmin(_proxy, address(128));\n\n        // The proxy is no longer the admin and can\n        // no longer call the proxy interface except for\n        // the ResolvedDelegate type on which anybody can\n        // call the admin interface.\n        if (proxyType == ProxyAdmin.ProxyType.ERC1967) {\n            vm.expectRevert(\"Proxy: implementation not initialized\");\n            admin.getProxyAdmin(_proxy);\n        } else if (proxyType == ProxyAdmin.ProxyType.Chugsplash) {\n            vm.expectRevert(\"L1ChugSplashProxy: implementation is not set yet\");\n            admin.getProxyAdmin(_proxy);\n        } else if (proxyType == ProxyAdmin.ProxyType.ResolvedDelegate) {\n            // Just an empty block to show that all cases are covered\n        } else {\n            vm.expectRevert(\"ProxyAdmin: unknown proxy type\");\n        }\n\n        // Call the proxy contract directly to get the admin.\n        // Different proxy types have different interfaces.\n        vm.prank(address(128));\n        if (proxyType == ProxyAdmin.ProxyType.ERC1967) {\n            assertEq(_proxy.admin(), address(128));\n        } else if (proxyType == ProxyAdmin.ProxyType.Chugsplash) {\n            assertEq(\n                L1ChugSplashProxy(payable(_proxy)).getOwner(),\n                address(128)\n            );\n        } else if (proxyType == ProxyAdmin.ProxyType.ResolvedDelegate) {\n            assertEq(\n                addressManager.owner(),\n                address(128)\n            );\n        } else {\n            assert(false);\n        }\n    }\n\n    function test_erc1967Upgrade() external {\n        upgrade(proxy);\n    }\n\n    function test_chugsplashUpgrade() external {\n        upgrade(Proxy(payable(chugsplash)));\n    }\n\n    function test_delegateResolvedUpgrade() external {\n        upgrade(Proxy(payable(resolved)));\n    }\n\n    function upgrade(Proxy _proxy) internal {\n        vm.prank(alice);\n        admin.upgrade(_proxy, address(implementation));\n\n        address impl = admin.getProxyImplementation(_proxy);\n        assertEq(impl, address(implementation));\n    }\n\n    function test_erc1967UpgradeAndCall() external {\n        upgradeAndCall(proxy);\n    }\n\n    function test_chugsplashUpgradeAndCall() external {\n        upgradeAndCall(Proxy(payable(chugsplash)));\n    }\n\n    function test_delegateResolvedUpgradeAndCall() external {\n        upgradeAndCall(Proxy(payable(resolved)));\n    }\n\n    function upgradeAndCall(Proxy _proxy) internal {\n        vm.prank(alice);\n        admin.upgradeAndCall(\n            _proxy,\n            address(implementation),\n            abi.encodeWithSelector(SimpleStorage.set.selector, 1, 1)\n        );\n\n        address impl = admin.getProxyImplementation(_proxy);\n        assertEq(impl, address(implementation));\n\n        uint256 got = SimpleStorage(address(_proxy)).get(1);\n        assertEq(got, 1);\n    }\n\n    function test_onlyOwner() external {\n        vm.expectRevert(\"UNAUTHORIZED\");\n        admin.changeProxyAdmin(proxy, address(0));\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n        admin.upgrade(proxy, address(implementation));\n\n        vm.expectRevert(\"UNAUTHORIZED\");\n        admin.upgradeAndCall(proxy, address(implementation), hex\"\");\n    }\n\n    function test_isUpgrading() external {\n        assertEq(false, admin.isUpgrading());\n\n        vm.prank(alice);\n        admin.setUpgrading(true);\n        assertEq(true, admin.isUpgrading());\n    }\n}\n"
    },
    "contracts/test/ResourceMetering.t.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport { CommonTest } from \"./CommonTest.t.sol\";\nimport { ResourceMetering } from \"../L1/ResourceMetering.sol\";\nimport { Proxy } from \"../universal/Proxy.sol\";\n\ncontract MeterUser is ResourceMetering {\n    constructor() {\n        __ResourceMetering_init();\n    }\n\n    function use(uint64 _amount) public metered(_amount) {}\n}\n\ncontract ResourceMetering_Test is CommonTest {\n    MeterUser internal meter;\n    uint64 initialBlockNum;\n\n    function setUp() external {\n        _setUp();\n        meter = new MeterUser();\n        initialBlockNum = uint64(block.number);\n    }\n\n    function test_initialResourceParams() external {\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, meter.INITIAL_BASE_FEE());\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum);\n    }\n\n    function test_updateParamsNoChange() external {\n        meter.use(0); // equivalent to just updating the base fee and block number\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n        meter.use(0);\n        (uint128 postBaseFee, uint64 postBoughtGas, uint64 postBlockNum) = meter.params();\n\n        assertEq(postBaseFee, prevBaseFee);\n        assertEq(postBoughtGas, prevBoughtGas);\n        assertEq(postBlockNum, prevBlockNum);\n    }\n\n    function test_updateOneEmptyBlock() external {\n        vm.roll(initialBlockNum + 1);\n        meter.use(0);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        // Base fee decreases by 12.5%\n        assertEq(prevBaseFee, 875000000);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum + 1);\n    }\n\n    function test_updateTwoEmptyBlocks() external {\n        vm.roll(initialBlockNum + 2);\n        meter.use(0);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 765624999);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum + 2);\n    }\n\n    function test_updateTenEmptyBlocks() external {\n        vm.roll(initialBlockNum + 10);\n        meter.use(0);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 263075576);\n        assertEq(prevBoughtGas, 0);\n        assertEq(prevBlockNum, initialBlockNum + 10);\n    }\n\n    function test_updateNoGasDelta() external {\n        uint64 target = uint64(uint256(meter.TARGET_RESOURCE_LIMIT()));\n        meter.use(target);\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n\n        assertEq(prevBaseFee, 1000000000);\n        assertEq(prevBoughtGas, target);\n        assertEq(prevBlockNum, initialBlockNum);\n    }\n\n    function test_useMaxSucceeds() external {\n        uint64 target = uint64(uint256(meter.TARGET_RESOURCE_LIMIT()));\n        uint64 elasticity = uint64(uint256(meter.ELASTICITY_MULTIPLIER()));\n        meter.use(target * elasticity);\n\n        (uint128 prevBaseFee, uint64 prevBoughtGas, uint64 prevBlockNum) = meter.params();\n        assertEq(prevBoughtGas, target * elasticity);\n\n        vm.roll(initialBlockNum + 1);\n        meter.use(0);\n        (uint128 postBaseFee, uint64 postBoughtGas, uint64 postBlockNum) = meter.params();\n        // Base fee increases by 1/8 the difference\n        assertEq(postBaseFee, 1375000000);\n    }\n\n    function test_useMoreThanMaxReverts() external {\n        uint64 target = uint64(uint256(meter.TARGET_RESOURCE_LIMIT()));\n        uint64 elasticity = uint64(uint256(meter.ELASTICITY_MULTIPLIER()));\n        vm.expectRevert(\"OptimismPortal: cannot buy more gas than available gas limit\");\n        meter.use(target * elasticity + 1);\n    }\n}\n"
    },
    "contracts/test/SequencerFeeVault.t.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { Bridge_Initializer } from \"./CommonTest.t.sol\";\n\nimport { SequencerFeeVault } from \"../L2/SequencerFeeVault.sol\";\nimport { L2StandardBridge } from \"../L2/L2StandardBridge.sol\";\nimport { Lib_PredeployAddresses } from \"../libraries/Lib_PredeployAddresses.sol\";\n\ncontract SequencerFeeVault_Test is Bridge_Initializer {\n    SequencerFeeVault vault =\n        SequencerFeeVault(payable(Lib_PredeployAddresses.SEQUENCER_FEE_WALLET));\n    address constant recipient = address(256);\n\n    function setUp() public override {\n        super.setUp();\n\n        vm.etch(\n            Lib_PredeployAddresses.SEQUENCER_FEE_WALLET,\n            address(new SequencerFeeVault()).code\n        );\n\n        vm.store(\n            Lib_PredeployAddresses.SEQUENCER_FEE_WALLET,\n            bytes32(uint256(0)),\n            bytes32(uint256(uint160(recipient)))\n        );\n    }\n\n    function test_minWithdrawalAmount() external {\n        assertEq(\n            vault.MIN_WITHDRAWAL_AMOUNT(),\n            15 ether\n        );\n    }\n\n    function test_constructor() external {\n        assertEq(\n            vault.l1FeeWallet(),\n            recipient\n        );\n    }\n\n    function test_receive() external {\n        assertEq(\n            address(vault).balance,\n            0\n        );\n\n        vm.prank(alice);\n        address(vault).call{ value: 100 }(hex\"\");\n\n        assertEq(\n            address(vault).balance,\n            100\n        );\n    }\n\n    function test_revertWithdraw() external {\n        assert(address(vault).balance < vault.MIN_WITHDRAWAL_AMOUNT());\n\n        vm.expectRevert(\n            \"OVM_SequencerFeeVault: withdrawal amount must be greater than minimum withdrawal amount\"\n        );\n        vault.withdraw();\n    }\n\n    function test_withdraw() external {\n        vm.deal(address(vault), vault.MIN_WITHDRAWAL_AMOUNT() + 1);\n\n        vm.expectCall(\n            Lib_PredeployAddresses.L2_STANDARD_BRIDGE,\n            abi.encodeWithSelector(\n                L2StandardBridge.withdrawTo.selector,\n                Lib_PredeployAddresses.OVM_ETH,\n                vault.l1FeeWallet(),\n                address(vault).balance,\n                0,\n                bytes(\"\")\n            )\n        );\n\n        vault.withdraw();\n    }\n}\n"
    },
    "contracts/universal/CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n// solhint-disable max-line-length\n\n/* Library Imports */\nimport { Lib_DefaultValues } from \"../libraries/Lib_DefaultValues.sol\";\nimport { CrossDomainHashing } from \"../libraries/Lib_CrossDomainHashing.sol\";\n\n/* External Imports */\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    PausableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport { ExcessivelySafeCall } from \"excessively-safe-call/src/ExcessivelySafeCall.sol\";\n\n// solhint-enable max-line-length\n\n/**\n * @title CrossDomainMessenger\n * @dev The CrossDomainMessenger contract delivers messages between two layers.\n */\nabstract contract CrossDomainMessenger is\n    OwnableUpgradeable,\n    PausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n\n    event RelayedMessage(bytes32 indexed msgHash);\n\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /*************\n     * Constants *\n     *************/\n\n    uint16 public constant MESSAGE_VERSION = 1;\n\n    uint32 public constant MIN_GAS_DYNAMIC_OVERHEAD = 1;\n\n    uint32 public constant MIN_GAS_CONSTANT_OVERHEAD = 100_000;\n\n    /// @notice Minimum amount of gas required prior to relaying a message.\n    uint256 internal constant RELAY_GAS_REQUIRED = 45_000;\n\n    /// @notice Amount of gas held in reserve for accounting after relaying a message.\n    uint256 internal constant RELAY_GAS_BUFFER = RELAY_GAS_REQUIRED - 5000;\n\n    /*************\n     * Variables *\n     *************/\n\n    // blockedMessages in old L1CrossDomainMessenger\n    bytes32 internal REMOVED_VARIABLE_SPACER_1;\n\n    // relayedMessages in old L1CrossDomainMessenger\n    bytes32 internal REMOVED_VARIABLE_SPACER_2;\n\n    /// @notice Mapping of message hash to boolean success value.\n    mapping(bytes32 => bool) public successfulMessages;\n\n    /// @notice Current x-domain message sender.\n    address internal xDomainMsgSender;\n\n    /// @notice Nonce for the next message to be sent.\n    uint256 internal msgNonce;\n\n    /// @notice Address of the CrossDomainMessenger on the other chain.\n    address public otherMessenger;\n\n    /// @notice Mapping of message hash to boolean receipt value.\n    mapping(bytes32 => bool) public receivedMessages;\n\n    /// @notice Blocked system addresses that cannot be called (for security reasons).\n    mapping(address => bool) public blockedSystemAddresses;\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Pause relaying.\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * Unpause relaying.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * Retrieves the address of the x-domain message sender. Will throw an error\n     * if the sender is not currently set (equal to the default sender).\n     * This function is meant to be called on the remote side of a cross domain\n     * message so that the account that initiated the call can be known.\n     *\n     * @return Address of the x-domain message sender.\n     */\n    function xDomainMessageSender() external view returns (address) {\n        require(\n            xDomainMsgSender != Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER,\n            \"xDomainMessageSender is not set\"\n        );\n\n        return xDomainMsgSender;\n    }\n\n    /**\n     * Retrieves the next message nonce. Adds the hash version to the nonce.\n     *\n     * @return Next message nonce with added hash version.\n     */\n    function messageNonce() public view returns (uint256) {\n        return CrossDomainHashing.addVersionToNonce(msgNonce, MESSAGE_VERSION);\n    }\n\n    /**\n     * Base amount of gas required to make sure that the message will be received without\n     * running out of gas. Amount of gas provided to the L2 call will be the gas requested by\n     * the user PLUS this gas value so that if the message is not successful, it can always be\n     * replayed on the other end.\n     *\n     * @param _message Message to compute base gas for.\n     * @return Base gas required for message.\n     */\n    function baseGas(bytes memory _message) public pure returns (uint32) {\n        // TODO: Values here are meant to be good enough to get a devnet running. We need to do\n        // some simple experimentation with the smallest and largest possible message sizes to find\n        // the correct constant and dynamic overhead values.\n        return (uint32(_message.length) * MIN_GAS_DYNAMIC_OVERHEAD) + MIN_GAS_CONSTANT_OVERHEAD;\n    }\n\n    /**\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _minGasLimit Gas limit for the provided message.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _minGasLimit\n    ) external payable {\n        // Triggers a message to the other messenger. Note that the amount of gas provided to the\n        // message is the amount of gas requested by the user PLUS the base gas value. We want to\n        // guarantee the property that the call to the target contract will always have at least\n        // the minimum gas limit specified by the user.\n        _sendMessage(\n            otherMessenger,\n            _minGasLimit + baseGas(_message),\n            msg.value,\n            abi.encodeWithSelector(\n                this.relayMessage.selector,\n                messageNonce(),\n                msg.sender,\n                _target,\n                msg.value,\n                _minGasLimit,\n                _message\n            )\n        );\n\n        emit SentMessage(_target, msg.sender, _message, messageNonce(), _minGasLimit);\n\n        unchecked {\n            ++msgNonce;\n        }\n    }\n\n    function relayMessage(\n        uint256 _nonce,\n        address _sender,\n        address _target,\n        uint256 _value,\n        uint256 _minGasLimit,\n        bytes calldata _message\n    ) external payable nonReentrant whenNotPaused {\n        bytes32 versionedHash = CrossDomainHashing.getVersionedHash(\n            _nonce,\n            _sender,\n            _target,\n            _value,\n            _minGasLimit,\n            _message\n        );\n\n        if (_isSystemMessageSender()) {\n            // Should never happen.\n            require(msg.value == _value, \"Mismatched message value.\");\n        } else {\n            // TODO(tynes): could require that msg.value == 0 here\n            // to prevent eth from getting stuck\n            require(receivedMessages[versionedHash], \"Message cannot be replayed.\");\n        }\n\n        // TODO: Should blocking happen on sending or receiving side?\n        // TODO: Should this just return with an event instead of reverting?\n        require(\n            blockedSystemAddresses[_target] == false,\n            \"Cannot send message to blocked system address.\"\n        );\n\n        require(successfulMessages[versionedHash] == false, \"Message has already been relayed.\");\n\n        // TODO: Make sure this will always give us enough gas.\n        require(\n            gasleft() >= _minGasLimit + RELAY_GAS_REQUIRED,\n            \"Insufficient gas to relay message.\"\n        );\n\n        xDomainMsgSender = _sender;\n        (bool success, ) = ExcessivelySafeCall.excessivelySafeCall(\n            _target,\n            gasleft() - RELAY_GAS_BUFFER,\n            _value,\n            0,\n            _message\n        );\n        xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\n\n        if (success == true) {\n            successfulMessages[versionedHash] = true;\n            emit RelayedMessage(versionedHash);\n        } else {\n            receivedMessages[versionedHash] = true;\n            emit FailedRelayedMessage(versionedHash);\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function _isSystemMessageSender() internal view virtual returns (bool);\n\n    function _sendMessage(\n        address _to,\n        uint64 _gasLimit,\n        uint256 _value,\n        bytes memory _data\n    ) internal virtual;\n\n    /**\n     * @notice Initializes the contract. The parent contract MUST handle\n     *         preventing this from being called twice.\n     */\n    function _initialize(address _otherMessenger, address[] memory _blockedSystemAddresses)\n        internal\n    {\n        xDomainMsgSender = Lib_DefaultValues.DEFAULT_XDOMAIN_SENDER;\n        otherMessenger = _otherMessenger;\n\n        for (uint256 i = 0; i < _blockedSystemAddresses.length; i++) {\n            blockedSystemAddresses[_blockedSystemAddresses[i]] = true;\n        }\n\n        // TODO: ensure we know what these are doing and why they are here\n        // Initialize upgradable OZ contracts\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __Pausable_init_unchained();\n        __ReentrancyGuard_init_unchained();\n    }\n}\n"
    },
    "contracts/universal/OptimismMintableERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { ERC20 } from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./SupportedInterfaces.sol\";\n\n/**\n * @title OptimismMintableERC20\n * This contract represents the remote representation\n * of an ERC20 token. It is linked to the address of\n * a token in another domain and tokens can be locked\n * in the StandardBridge which will mint tokens in the\n * other domain.\n */\ncontract OptimismMintableERC20 is ERC20 {\n    event Mint(address indexed _account, uint256 _amount);\n    event Burn(address indexed _account, uint256 _amount);\n\n    /**\n     * @notice The address of the token in the remote domain\n     */\n    address public remoteToken;\n\n    /**\n     * @notice The address of the bridge responsible for\n     * minting. It is in the same domain.\n     */\n    address public bridge;\n\n    /**\n     * @param _bridge Address of the L2 standard bridge.\n     * @param _remoteToken Address of the corresponding L1 token.\n     * @param _name ERC20 name.\n     * @param _symbol ERC20 symbol.\n     */\n    constructor(\n        address _bridge,\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) {\n        remoteToken = _remoteToken;\n        bridge = _bridge;\n    }\n\n    /**\n     * @notice Returns the corresponding L1 token address.\n     * This is a legacy function and wraps the remoteToken value.\n     */\n    function l1Token() public view returns (address) {\n        return remoteToken;\n    }\n\n    /**\n     * @notice The address of the bridge contract\n     * responsible for minting tokens. This is a legacy\n     * getter function\n     */\n    function l2Bridge() public view returns (address) {\n        return bridge;\n    }\n\n    /**\n     * @notice A modifier that only allows the bridge to call\n     */\n    modifier onlyBridge() {\n        require(msg.sender == bridge, \"Only L2 Bridge can mint and burn\");\n        _;\n    }\n\n    /**\n     * @notice ERC165\n     */\n    // slither-disable-next-line external-function\n    function supportsInterface(bytes4 _interfaceId) public pure returns (bool) {\n        bytes4 iface1 = type(IERC165).interfaceId;\n        bytes4 iface2 = type(IL1Token).interfaceId;\n        bytes4 iface3 = type(IRemoteToken).interfaceId;\n        return _interfaceId == iface1 || _interfaceId == iface2 || _interfaceId == iface3;\n    }\n\n    /**\n     * @notice The bridge can mint tokens\n     */\n    // slither-disable-next-line external-function\n    function mint(address _to, uint256 _amount) public virtual onlyBridge {\n        _mint(_to, _amount);\n\n        emit Mint(_to, _amount);\n    }\n\n    /**\n     * @notice The bridge can burn tokens\n     */\n    // slither-disable-next-line external-function\n    function burn(address _from, uint256 _amount) public virtual onlyBridge {\n        _burn(_from, _amount);\n\n        emit Burn(_from, _amount);\n    }\n}\n"
    },
    "contracts/universal/OptimismMintableTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Contract Imports */\nimport { OptimismMintableERC20 } from \"../universal/OptimismMintableERC20.sol\";\nimport { Lib_PredeployAddresses } from \"../libraries/Lib_PredeployAddresses.sol\";\n\n/**\n * @title OptimismMintableTokenFactory\n * @dev Factory contract for creating standard remote token representations of\n * local ERC20s. This can be used to bridge native L1 ERC20s to L2 or native L2\n * ERC20s to L1. The tokens created through this factory are meant to operate\n * with the StandardBridge contract for deposits/withdrawals.\n * This contract is a predeploy on L2 at 0x4200000000000000000000000000000000000012\n * TODO: deploy to a deterministic address on L1 networks?\n * TODO: should this be extended for L1/L2 with hardcoded values in\n * the base contract's initialize?\n */\ncontract OptimismMintableTokenFactory {\n    event StandardL2TokenCreated(address indexed _remoteToken, address indexed _localToken);\n    event OptimismMintableTokenCreated(\n        address indexed _localToken,\n        address indexed _remoteToken,\n        address _deployer\n    );\n\n    address public bridge;\n\n    /**\n     * @dev Initialize the factory\n     * On L2 _bridge should be Lib_PredeployAddresses.L2_STANDARD_BRIDGE,\n     * On L1 _bridge should be the L1StandardBridge\n     */\n    function initialize(address _bridge) public {\n        require(bridge == address(0), \"Already initialized.\");\n        bridge = _bridge;\n    }\n\n    /**\n     * @dev Creates an instance of the standard ERC20 token on L2.\n     * @param _remoteToken Address of the corresponding L1 token.\n     * @param _name ERC20 name.\n     * @param _symbol ERC20 symbol.\n     * @return Address of the new token.\n     */\n    function createStandardL2Token(\n        address _remoteToken,\n        string memory _name,\n        string memory _symbol\n    ) external returns (address) {\n        require(_remoteToken != address(0), \"Must provide L1 token address\");\n        require(bridge != address(0), \"Must initialize first\");\n\n        OptimismMintableERC20 localToken = new OptimismMintableERC20(\n            bridge,\n            _remoteToken,\n            _name,\n            _symbol\n        );\n\n        // Legacy Purposes\n        emit StandardL2TokenCreated(_remoteToken, address(localToken));\n        emit OptimismMintableTokenCreated(_remoteToken, address(localToken), msg.sender);\n\n        return address(localToken);\n    }\n}\n"
    },
    "contracts/universal/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Proxy\n * @notice Proxy is a transparent proxy that passes through the call\n *         if the caller is the owner or if the caller is `address(0)`,\n *         meaning that the call originated from an offchain simulation.\n */\ncontract Proxy {\n    /**\n     * @notice An event that is emitted each time the implementation is changed.\n     *         This event is part of the EIP 1967 spec.\n     *\n     * @param implementation The address of the implementation contract\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @notice An event that is emitted each time the owner is upgraded.\n     *         This event is part of the EIP 1967 spec.\n     *\n     * @param previousAdmin The previous owner of the contract\n     * @param newAdmin      The new owner of the contract\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @notice The storage slot that holds the address of the implementation.\n     *         bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\n     */\n    bytes32 internal constant IMPLEMENTATION_KEY =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @notice The storage slot that holds the address of the owner.\n     *         bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1)\n     */\n    bytes32 internal constant OWNER_KEY =\n        0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @notice set the initial owner during contract deployment. The\n     *         owner is stored at the eip1967 owner storage slot so that\n     *         storage collision with the implementation is not possible.\n     *\n     * @param _admin Address of the initial contract owner. The owner has\n     *               the ability to access the transparent proxy interface.\n     */\n    constructor(address _admin) {\n        _changeAdmin(_admin);\n    }\n\n    // slither-disable-next-line locked-ether\n    fallback() external payable {\n        // Proxy call by default.\n        _doProxyCall();\n    }\n\n    /**\n     * @notice A modifier that reverts if not called by the owner\n     *         or by `address(0)` to allow `eth_call` to interact\n     *         with the proxy without needing to use low level storage\n     *         inspection. It is assumed that nobody controls the private\n     *         key for `address(0)`.\n     */\n    modifier proxyCallIfNotAdmin() {\n        if (msg.sender == _getAdmin() || msg.sender == address(0)) {\n            _;\n        } else {\n            // This WILL halt the call frame on completion.\n            _doProxyCall();\n        }\n    }\n\n    /**\n     * @notice Set the implementation contract address. The code at this\n     *         address will execute when this contract is called.\n     *\n     * @param _implementation The address of the implementation contract\n     */\n    function upgradeTo(address _implementation) external proxyCallIfNotAdmin {\n        _setImplementation(_implementation);\n    }\n\n    /**\n     * @notice Set the implementation and call a function in a single\n     *         transaction. This is useful to ensure atomic `initialize()`\n     *         based upgrades.\n     *\n     * @param _implementation The address of the implementation contract\n     * @param _data           The calldata to delegatecall the new\n     *                        implementation with\n     */\n    function upgradeToAndCall(address _implementation, bytes calldata _data)\n        external\n        payable\n        proxyCallIfNotAdmin\n        returns (bytes memory)\n    {\n        _setImplementation(_implementation);\n        (bool success, bytes memory returndata) = _implementation.delegatecall(_data);\n        require(success);\n        return returndata;\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract. Only callable by the owner.\n     *\n     * @param _admin New owner of the proxy contract.\n     */\n    function changeAdmin(address _admin) external proxyCallIfNotAdmin {\n        _changeAdmin(_admin);\n    }\n\n    /**\n     * @notice Gets the owner of the proxy contract.\n     *\n     * @return Owner address.\n     */\n    function admin() external proxyCallIfNotAdmin returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @notice Queries the implementation address.\n     *\n     * @return Implementation address.\n     */\n    function implementation() external proxyCallIfNotAdmin returns (address) {\n        return _getImplementation();\n    }\n\n    /**\n     * @notice Sets the implementation address.\n     *\n     * @param _implementation New implementation address.\n     */\n    function _setImplementation(address _implementation) internal {\n        assembly {\n            sstore(IMPLEMENTATION_KEY, _implementation)\n        }\n        emit Upgraded(_implementation);\n    }\n\n    /**\n     * @notice Queries the implementation address.\n     *\n     * @return implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        address implementation;\n        assembly {\n            implementation := sload(IMPLEMENTATION_KEY)\n        }\n        return implementation;\n    }\n\n    /**\n     * @notice Changes the owner of the proxy contract.\n     *\n     * @param _admin New owner of the proxy contract.\n     */\n    function _changeAdmin(address _admin) internal {\n        address previous = _getAdmin();\n        assembly {\n            sstore(OWNER_KEY, _admin)\n        }\n        emit AdminChanged(previous, _admin);\n    }\n\n    /**\n     * @notice Queries the owner of the proxy contract.\n     *\n     * @return owner address.\n     */\n    function _getAdmin() internal view returns (address) {\n        address owner;\n        assembly {\n            owner := sload(OWNER_KEY)\n        }\n        return owner;\n    }\n\n    /**\n     * @notice Performs the proxy call via a delegatecall.\n     */\n    function _doProxyCall() internal {\n        address implementation = _getImplementation();\n\n        require(implementation != address(0), \"Proxy: implementation not initialized\");\n\n        assembly {\n            // Copy calldata into memory at 0x0....calldatasize.\n            calldatacopy(0x0, 0x0, calldatasize())\n\n            // Perform the delegatecall, make sure to pass all available gas.\n            let success := delegatecall(gas(), implementation, 0x0, calldatasize(), 0x0, 0x0)\n\n            // Copy returndata into memory at 0x0....returndatasize. Note that this *will*\n            // overwrite the calldata that we just copied into memory but that doesn't really\n            // matter because we'll be returning in a second anyway.\n            returndatacopy(0x0, 0x0, returndatasize())\n\n            // Success == 0 means a revert. We'll revert too and pass the data up.\n            if iszero(success) {\n                revert(0x0, returndatasize())\n            }\n\n            // Otherwise we'll just return and pass the data up.\n            return(0x0, returndatasize())\n        }\n    }\n}\n"
    },
    "contracts/universal/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport { Proxy } from \"./Proxy.sol\";\nimport { Owned } from \"@rari-capital/solmate/src/auth/Owned.sol\";\nimport { Lib_AddressManager } from \"../legacy/Lib_AddressManager.sol\";\nimport { L1ChugSplashProxy } from \"../legacy/L1ChugSplashProxy.sol\";\n\n// Define static interfaces of these proxies so that we can easily\n// use staticcall on the getters we need.\ninterface IStatic_ERC1967Proxy {\n    function implementation() external view returns (address);\n\n    function admin() external view returns (address);\n}\n\ninterface IStatic_L1ChugSplashProxy {\n    function getImplementation() external view returns (address);\n\n    function getOwner() external view returns (address);\n}\n\n/**\n * @title ProxyAdmin\n * @dev This is an auxiliary contract meant to be assigned as the admin of an ERC1967 Proxy,\n *      based on the OpenZeppelin implementation. It has backwards compatibility logic to work with\n *      the various types of proxies that have been deployed by Optimism.\n */\ncontract ProxyAdmin is Owned {\n    /**\n     * @notice The proxy types that the ProxyAdmin can manage.\n     *\n     * @custom:value ERC1967          Represents an ERC1967 compliant transparent proxy\n     *                                interface, this is the default.\n     * @custom:value Chugsplash       Represents the Chugsplash proxy interface,\n     *                                this is legacy.\n     * @custom:value ResolvedDelegate Represents the ResolvedDelegate proxy\n     *                                interface, this is legacy.\n     */\n    enum ProxyType {\n        ERC1967,\n        Chugsplash,\n        ResolvedDelegate\n    }\n\n    /**\n     * @custom:legacy\n     * @notice         A mapping of proxy types, used for backwards compatibility.\n     */\n    mapping(address => ProxyType) public proxyType;\n\n    /**\n     * @custom:legacy\n     * @notice A reverse mapping of addresses to names held in the AddressManager. This must be\n     *         manually kept up to date with changes in the AddressManager for this contract\n     *         to be able to work as an admin for the Lib_ResolvedDelegateProxy type.\n     */\n    mapping(address => string) public implementationName;\n\n    /**\n     * @custom:legacy\n     * @notice The address of the address manager, this is required to manage the\n     *         Lib_ResolvedDelegateProxy type.\n     */\n    Lib_AddressManager public addressManager;\n\n    /**\n     * @custom:legacy\n     * @notice A legacy upgrading indicator used by the old Chugsplash Proxy.\n     */\n    bool internal upgrading = false;\n\n    /**\n     * @notice Set the owner of the ProxyAdmin via constructor argument.\n     */\n    constructor(address owner) Owned(owner) {}\n\n    /**\n     * @notice\n     *\n     * @param _address   The address of the proxy.\n     * @param _type The type of the proxy.\n     */\n    function setProxyType(address _address, ProxyType _type) external onlyOwner {\n        proxyType[_address] = _type;\n    }\n\n    /**\n     * @notice Set the proxy type in the mapping. This needs to be kept up to date by the owner of\n     *         the contract.\n     *\n     * @param _address The address to be named.\n     * @param _name    The name of the address.\n     */\n    function setImplementationName(address _address, string memory _name) external onlyOwner {\n        implementationName[_address] = _name;\n    }\n\n    /**\n     * @notice Set the address of the address manager. This is required to manage the legacy\n     *         `Lib_ResolvedDelegateProxy`.\n     *\n     * @param _address The address of the address manager.\n     */\n    function setAddressManager(Lib_AddressManager _address) external onlyOwner {\n        addressManager = _address;\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Set an address in the address manager. This is required because only the owner of\n     *         the AddressManager can set the addresses in it.\n     *\n     * @param _name    The name of the address to set in the address manager.\n     * @param _address The address to set in the address manager.\n     */\n    function setAddress(string memory _name, address _address) external onlyOwner {\n        addressManager.setAddress(_name, _address);\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Legacy function used by the old Chugsplash proxy to determine if an upgrade is\n     *         happening.\n     *\n     * @return Whether or not there is an upgrade going on\n     */\n    function isUpgrading() external view returns (bool) {\n        return upgrading;\n    }\n\n    /**\n     * @custom:legacy\n     * @notice Set the upgrading status for the Chugsplash proxy type.\n     *\n     * @param _upgrading Whether or not the system is upgrading.\n     */\n    function setUpgrading(bool _upgrading) external onlyOwner {\n        upgrading = _upgrading;\n    }\n\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *      This contract must be the admin of `proxy`.\n     *\n     * @param proxy The Proxy to return the implementation of.\n     * @return The address of the implementation.\n     */\n    function getProxyImplementation(Proxy proxy) external view returns (address) {\n        ProxyType proxyType = proxyType[address(proxy)];\n\n        if (proxyType == ProxyType.ERC1967) {\n            return IStatic_ERC1967Proxy(address(proxy)).implementation();\n        } else if (proxyType == ProxyType.Chugsplash) {\n            return IStatic_L1ChugSplashProxy(address(proxy)).getImplementation();\n        } else if (proxyType == ProxyType.ResolvedDelegate) {\n            return addressManager.getAddress(implementationName[address(proxy)]);\n        } else {\n            revert(\"ProxyAdmin: unknown proxy type\");\n        }\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *      This contract must be the admin of `proxy`.\n     *\n     * @param proxy The Proxy to return the admin of.\n     * @return The address of the admin.\n     */\n    function getProxyAdmin(Proxy proxy) external view returns (address) {\n        ProxyType proxyType = proxyType[address(proxy)];\n\n        if (proxyType == ProxyType.ERC1967) {\n            return IStatic_ERC1967Proxy(address(proxy)).admin();\n        } else if (proxyType == ProxyType.Chugsplash) {\n            return IStatic_L1ChugSplashProxy(address(proxy)).getOwner();\n        } else if (proxyType == ProxyType.ResolvedDelegate) {\n            return addressManager.owner();\n        } else {\n            revert(\"ProxyAdmin: unknown proxy type\");\n        }\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`. This contract must be the current admin\n     *      of `proxy`.\n     *\n     * @param proxy    The proxy that will have its admin updated.\n     * @param newAdmin The address of the admin to update to.\n     */\n    function changeProxyAdmin(Proxy proxy, address newAdmin) external onlyOwner {\n        ProxyType proxyType = proxyType[address(proxy)];\n\n        if (proxyType == ProxyType.ERC1967) {\n            proxy.changeAdmin(newAdmin);\n        } else if (proxyType == ProxyType.Chugsplash) {\n            L1ChugSplashProxy(payable(proxy)).setOwner(newAdmin);\n        } else if (proxyType == ProxyType.ResolvedDelegate) {\n            addressManager.transferOwnership(newAdmin);\n        } else {\n            revert(\"ProxyAdmin: unknown proxy type\");\n        }\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. This contract must be the admin of `proxy`.\n     *\n     * @param proxy          The address of the proxy.\n     * @param implementation The address of the implementation.\n     */\n    function upgrade(Proxy proxy, address implementation) public onlyOwner {\n        ProxyType proxyType = proxyType[address(proxy)];\n\n        if (proxyType == ProxyType.ERC1967) {\n            proxy.upgradeTo(implementation);\n        } else if (proxyType == ProxyType.Chugsplash) {\n            L1ChugSplashProxy(payable(proxy)).setStorage(\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc,\n                bytes32(uint256(uint160(implementation)))\n            );\n        } else if (proxyType == ProxyType.ResolvedDelegate) {\n            string memory name = implementationName[address(proxy)];\n            addressManager.setAddress(name, implementation);\n        } else {\n            revert(\"ProxyAdmin: unknown proxy type\");\n        }\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation.\n     *      This contract must be the admin of `proxy`.\n     *\n     * @param proxy           The proxy to call.\n     * @param implementation  The implementation to upgrade the proxy to.\n     * @param data            The calldata to pass to the implementation.\n     */\n    function upgradeAndCall(\n        Proxy proxy,\n        address implementation,\n        bytes memory data\n    ) external payable onlyOwner {\n        ProxyType proxyType = proxyType[address(proxy)];\n\n        if (proxyType == ProxyType.ERC1967) {\n            proxy.upgradeToAndCall{ value: msg.value }(implementation, data);\n        } else {\n            // reverts if proxy type is unknown\n            upgrade(proxy, implementation);\n            (bool success, ) = address(proxy).call{ value: msg.value }(data);\n            require(success);\n        }\n    }\n}\n"
    },
    "contracts/universal/StandardBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Interface Imports */\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./SupportedInterfaces.sol\";\n\n/* Library Imports */\nimport { ERC165Checker } from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport { CrossDomainMessenger } from \"./CrossDomainMessenger.sol\";\nimport { OptimismMintableERC20 } from \"./OptimismMintableERC20.sol\";\n\n/**\n * @title StandardBridge\n * This contract can manage a 1:1 bridge between two domains for both\n * ETH (native asset) and ERC20s.\n * This contract should be deployed behind a proxy.\n * TODO: do we want a donateERC20 function as well?\n */\nabstract contract StandardBridge {\n    using SafeERC20 for IERC20;\n\n    /**********\n     * Events *\n     **********/\n\n    event ETHBridgeInitiated(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _extraData\n    );\n\n    event ETHBridgeFinalized(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount,\n        bytes _extraData\n    );\n\n    event ERC20BridgeInitiated(\n        address indexed _localToken,\n        address indexed _remoteToken,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _extraData\n    );\n\n    event ERC20BridgeFinalized(\n        address indexed _localToken,\n        address indexed _remoteToken,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _extraData\n    );\n\n    event ERC20BridgeFailed(\n        address indexed _localToken,\n        address indexed _remoteToken,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _extraData\n    );\n\n    /*************\n     * Constants *\n     *************/\n\n    /**\n     * @notice The L2 gas limit set when eth is depoisited using the receive() function.\n     */\n    uint32 internal constant RECEIVE_DEFAULT_GAS_LIMIT = 200_000;\n\n    /*************\n     * Variables *\n     *************/\n\n    /**\n     * @notice The messenger contract on the same domain\n     */\n    CrossDomainMessenger public messenger;\n\n    /**\n     * @notice The corresponding bridge on the other domain\n     */\n    StandardBridge public otherBridge;\n\n    mapping(address => mapping(address => uint256)) public deposits;\n\n    /*************\n     * Modifiers *\n     *************/\n\n    /**\n     * @notice Only allow EOAs to call the functions. Note that this\n     * is not safe against contracts calling code during their constructor\n     */\n    modifier onlyEOA() {\n        require(!Address.isContract(msg.sender), \"Account not EOA\");\n        _;\n    }\n\n    /**\n     * @notice Ensures that the caller is the messenger, and that\n     * it has the l2Sender value set to the address of the remote Token Bridge.\n     */\n    modifier onlyOtherBridge() {\n        require(\n            msg.sender == address(messenger) &&\n                messenger.xDomainMessageSender() == address(otherBridge),\n            \"Could not authenticate bridge message.\"\n        );\n        _;\n    }\n\n    modifier onlySelf() {\n        require(msg.sender == address(this), \"Function can only be called by self.\");\n        _;\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @notice EOAs can simply send ETH to this contract to have it be deposited\n     * to L2 through the standard bridge.\n     */\n    receive() external payable onlyEOA {\n        _initiateBridgeETH(msg.sender, msg.sender, msg.value, RECEIVE_DEFAULT_GAS_LIMIT, bytes(\"\"));\n    }\n\n    /**\n     * @notice Send ETH to the message sender on the remote domain\n     */\n    function bridgeETH(uint32 _minGasLimit, bytes calldata _extraData) public payable onlyEOA {\n        _initiateBridgeETH(msg.sender, msg.sender, msg.value, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @notice Send ETH to a specified account on the remote domain. Note that if ETH is sent to a\n     *         contract and the call fails, then that ETH will be locked in the other bridge.\n     */\n    function bridgeETHTo(\n        address _to,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) public payable {\n        _initiateBridgeETH(msg.sender, _to, msg.value, _minGasLimit, _extraData);\n    }\n\n    /**\n     * @notice Send an ERC20 to the message sender on the remote domain\n     */\n    function bridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) public virtual onlyEOA {\n        _initiateBridgeERC20(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            msg.sender,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Send an ERC20 to a specified account on the remote domain\n     */\n    function bridgeERC20To(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) public virtual {\n        _initiateBridgeERC20(\n            _localToken,\n            _remoteToken,\n            msg.sender,\n            _to,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Finalize an ETH sending transaction sent from a remote domain\n     */\n    function finalizeBridgeETH(\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) public payable onlyOtherBridge {\n        require(msg.value == _amount, \"Amount sent does not match amount required.\");\n        require(_to != address(this), \"Cannot send to self.\");\n\n        emit ETHBridgeFinalized(_from, _to, _amount, _extraData);\n        (bool success, ) = _to.call{ value: _amount }(new bytes(0));\n        require(success, \"ETH transfer failed.\");\n    }\n\n    /**\n     * @notice Finalize an ERC20 sending transaction sent from a remote domain\n     */\n    function finalizeBridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _extraData\n    ) public onlyOtherBridge {\n        try this.completeOutboundTransfer(_localToken, _remoteToken, _to, _amount) {\n            emit ERC20BridgeFinalized(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n        } catch {\n            // Something went wrong during the bridging process, return to sender.\n            // Can happen if a bridge UI specifies the wrong L2 token.\n            // We reverse both the local and remote token addresses, as well as the to and from\n            // addresses. This will preserve the accuracy of accounting based on emitted events.\n            _initiateBridgeERC20Unchecked(\n                _localToken,\n                _remoteToken,\n                _to,\n                _from,\n                _amount,\n                0, // _minGasLimit, 0 is fine here\n                _extraData\n            );\n            emit ERC20BridgeFailed(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n        }\n    }\n\n    function completeOutboundTransfer(\n        address _localToken,\n        address _remoteToken,\n        address _to,\n        uint256 _amount\n    ) public onlySelf {\n        // Make sure external function calls can't be used to trigger calls to\n        // completeOutboundTransfer. We only make external (write) calls to _localToken.\n        require(_localToken != address(this), \"Local token cannot be self\");\n\n        if (_isOptimismMintableERC20(_localToken)) {\n            require(\n                _isCorrectTokenPair(_localToken, _remoteToken),\n                \"Wrong remote token for Optimism Mintable ERC20 local token\"\n            );\n\n            OptimismMintableERC20(_localToken).mint(_to, _amount);\n        } else {\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] - _amount;\n            IERC20(_localToken).safeTransfer(_to, _amount);\n        }\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * @notice Initialize the StandardBridge contract with the address of\n     * the messenger on the same domain as well as the address of the bridge\n     * on the remote domain\n     */\n    function _initialize(address payable _messenger, address payable _otherBridge) internal {\n        require(address(messenger) == address(0), \"Contract has already been initialized.\");\n\n        messenger = CrossDomainMessenger(_messenger);\n        otherBridge = StandardBridge(_otherBridge);\n    }\n\n    /**\n     * @notice Bridge ETH to the remote chain through the messenger\n     */\n    function _initiateBridgeETH(\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes memory _extraData\n    ) internal {\n        emit ETHBridgeInitiated(_from, _to, _amount, _extraData);\n\n        messenger.sendMessage{ value: _amount }(\n            address(otherBridge),\n            abi.encodeWithSelector(\n                this.finalizeBridgeETH.selector,\n                _from,\n                _to,\n                _amount,\n                _extraData\n            ),\n            _minGasLimit\n        );\n    }\n\n    /**\n     * @notice Bridge an ERC20 to the remote chain through the messengers\n     */\n    function _initiateBridgeERC20(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal {\n        // Make sure external function calls can't be used to trigger calls to\n        // completeOutboundTransfer. We only make external (write) calls to _localToken.\n        require(_localToken != address(this), \"Local token cannot be self\");\n\n        if (_isOptimismMintableERC20(_localToken)) {\n            require(\n                _isCorrectTokenPair(_localToken, _remoteToken),\n                \"Wrong remote token for Optimism Mintable ERC20 local token\"\n            );\n\n            OptimismMintableERC20(_localToken).burn(_from, _amount);\n        } else {\n            // TODO: Do we need to confirm that the transfer was successful?\n            IERC20(_localToken).safeTransferFrom(_from, address(this), _amount);\n            deposits[_localToken][_remoteToken] = deposits[_localToken][_remoteToken] + _amount;\n        }\n\n        _initiateBridgeERC20Unchecked(\n            _localToken,\n            _remoteToken,\n            _from,\n            _to,\n            _amount,\n            _minGasLimit,\n            _extraData\n        );\n    }\n\n    /**\n     * @notice Bridge an ERC20 to the remote chain through the messengers\n     */\n    function _initiateBridgeERC20Unchecked(\n        address _localToken,\n        address _remoteToken,\n        address _from,\n        address _to,\n        uint256 _amount,\n        uint32 _minGasLimit,\n        bytes calldata _extraData\n    ) internal {\n        messenger.sendMessage(\n            address(otherBridge),\n            abi.encodeWithSelector(\n                this.finalizeBridgeERC20.selector,\n                // Because this call will be executed on the remote chain, we reverse the order of\n                // the remote and local token addresses relative to their order in the\n                // finalizeBridgeERC20 function.\n                _remoteToken,\n                _localToken,\n                _from,\n                _to,\n                _amount,\n                _extraData\n            ),\n            _minGasLimit\n        );\n\n        emit ERC20BridgeInitiated(_localToken, _remoteToken, _from, _to, _amount, _extraData);\n    }\n\n    /**\n     * Checks if a given address is an OptimismMintableERC20. Not perfect, but good enough.\n     * Just the way we like it.\n     *\n     * @param _token Address of the token to check.\n     * @return True if the token is an OptimismMintableERC20.\n     */\n    function _isOptimismMintableERC20(address _token) internal view returns (bool) {\n        return ERC165Checker.supportsInterface(_token, type(IL1Token).interfaceId);\n    }\n\n    /**\n     * Checks if the \"other token\" is the correct pair token for the OptimismMintableERC20.\n     *\n     * @param _mintableToken OptimismMintableERC20 to check against.\n     * @param _otherToken Pair token to check.\n     * @return True if the other token is the correct pair token for the OptimismMintableERC20.\n     */\n    function _isCorrectTokenPair(address _mintableToken, address _otherToken)\n        internal\n        view\n        returns (bool)\n    {\n        return _otherToken == OptimismMintableERC20(_mintableToken).l1Token();\n    }\n}\n"
    },
    "contracts/universal/SupportedInterfaces.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n// Import this here to make it available just by importing this file\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface IRemoteToken {\n    function mint(address _to, uint256 _amount) external virtual;\n\n    function burn(address _from, uint256 _amount) external virtual;\n\n    function remoteToken() external virtual;\n}\n\ninterface IL1Token {\n    function mint(address _to, uint256 _amount) external virtual;\n\n    function burn(address _from, uint256 _amount) external virtual;\n\n    function l1Token() external virtual;\n}\n"
    },
    "node_modules/@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = _setInitializedVersion(1);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        bool isTopLevelCall = _setInitializedVersion(version);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(version);\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        _setInitializedVersion(type(uint8).max);\n    }\n\n    function _setInitializedVersion(uint8 version) private returns (bool) {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n        // of initializers, because in other contexts the contract may have been reentered.\n        if (_initializing) {\n            require(\n                version == 1 && !Address.isContract(address(this)),\n                \"Initializable: contract is already initialized\"\n            );\n            return false;\n        } else {\n            require(_initialized < version, \"Initializable: contract is already initialized\");\n            _initialized = version;\n            return true;\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface,\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in _interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     * Interface identification is specified in ERC-165.\n     */\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\n        if (result.length < 32) return false;\n        return success && abi.decode(result, (bool));\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = _setInitializedVersion(1);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        bool isTopLevelCall = _setInitializedVersion(version);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(version);\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        _setInitializedVersion(type(uint8).max);\n    }\n\n    function _setInitializedVersion(uint8 version) private returns (bool) {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n        // of initializers, because in other contexts the contract may have been reentered.\n        if (_initializing) {\n            require(\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\n                \"Initializable: contract is already initialized\"\n            );\n            return false;\n        } else {\n            require(_initialized < version, \"Initializable: contract is already initialized\");\n            _initialized = version;\n            return true;\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "node_modules/@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "node_modules/@rari-capital/solmate/src/auth/Owned.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnerUpdated(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnerUpdated(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setOwner(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnerUpdated(msg.sender, newOwner);\n    }\n}\n"
    },
    "node_modules/@rari-capital/solmate/src/utils/Bytes32AddressLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Library for converting between addresses and bytes32 values.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/Bytes32AddressLib.sol)\nlibrary Bytes32AddressLib {\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\n        return address(uint160(uint256(bytesValue)));\n    }\n\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\n        return bytes32(bytes20(addressValue));\n    }\n}\n"
    },
    "node_modules/@rari-capital/solmate/src/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\n        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.\n    }\n\n    function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is < 0.5 we return zero. This happens when\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\n            if (x <= -42139678854452767551) return 0;\n\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\n            if (x >= 135305999368893231589) revert(\"EXP_OVERFLOW\");\n\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5**18;\n\n            // Reduce range of x to (- ln 2,  ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // k is in the range [-61, 195].\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // p is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range (0.09, 0.25) * 2**96.\n\n            // We now need to multiply r by:\n            // * the scale factor s = ~6.031367120.\n            // * the 2**k factor from the range reduction.\n            // * the 1e18 / 2**96 factor for base conversion.\n            // We do this all at once, with an intermediate result in 2**213\n            // basis, so the final right shift is always by a positive amount.\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\n        }\n    }\n\n    function lnWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            require(x > 0, \"UNDEFINED\");\n\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\n            // We do this by multiplying by 2**96 / 10**18. But since\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\n            // and add ln(2**96 / 10**18) at the end.\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            int256 k = int256(log2(uint256(x))) - 96;\n            x <<= uint256(159 - k);\n            x = int256(uint256(x) >> 159);\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // p is made monic, we will multiply by a scale factor later.\n            int256 p = x + 3273285459638523848632254066296;\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\n            p = p * x - (795164235651350426258249787498 << 96);\n\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\n            // q is monic by convention.\n            int256 q = x + 5573035233440673466300451813936;\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial is known not to have zeros in the domain.\n                // No scaling required because p is already 2**96 too large.\n                r := sdiv(p, q)\n            }\n\n            // r is in the range (0, 0.125) * 2**96\n\n            // Finalization, we need to:\n            // * multiply by the scale factor s = 5.549\n            // * add ln(2**96 / 10**18)\n            // * add k * ln(2)\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\n\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\n            r *= 1677202110996718588342820967067443963516166;\n            // add ln(2) * k * 5e18 * 2**192\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\n            // base conversion: mul 2**18 / 2**192\n            r >>= 174;\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        require(x > 0, \"UNDEFINED\");\n\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\n            r := or(r, lt(0x1, shr(r, x)))\n        }\n    }\n}\n"
    },
    "node_modules/ds-test/src/test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.5.0;\n\ncontract DSTest {\n    event log                    (string);\n    event logs                   (bytes);\n\n    event log_address            (address);\n    event log_bytes32            (bytes32);\n    event log_int                (int);\n    event log_uint               (uint);\n    event log_bytes              (bytes);\n    event log_string             (string);\n\n    event log_named_address      (string key, address val);\n    event log_named_bytes32      (string key, bytes32 val);\n    event log_named_decimal_int  (string key, int val, uint decimals);\n    event log_named_decimal_uint (string key, uint val, uint decimals);\n    event log_named_int          (string key, int val);\n    event log_named_uint         (string key, uint val);\n    event log_named_bytes        (string key, bytes val);\n    event log_named_string       (string key, string val);\n\n    bool public IS_TEST = true;\n    bool private _failed;\n\n    address constant HEVM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    modifier mayRevert() { _; }\n    modifier testopts(string memory) { _; }\n\n    function failed() public returns (bool) {\n        if (_failed) {\n            return _failed;\n        } else {\n            bool globalFailed = false;\n            if (hasHEVMContext()) {\n                (, bytes memory retdata) = HEVM_ADDRESS.call(\n                    abi.encodePacked(\n                        bytes4(keccak256(\"load(address,bytes32)\")),\n                        abi.encode(HEVM_ADDRESS, bytes32(\"failed\"))\n                    )\n                );\n                globalFailed = abi.decode(retdata, (bool));\n            }\n            return globalFailed;\n        }\n    } \n\n    function fail() internal {\n        if (hasHEVMContext()) {\n            (bool status, ) = HEVM_ADDRESS.call(\n                abi.encodePacked(\n                    bytes4(keccak256(\"store(address,bytes32,bytes32)\")),\n                    abi.encode(HEVM_ADDRESS, bytes32(\"failed\"), bytes32(uint256(0x01)))\n                )\n            );\n            status; // Silence compiler warnings\n        }\n        _failed = true;\n    }\n\n    function hasHEVMContext() internal view returns (bool) {\n        uint256 hevmCodeSize = 0;\n        assembly {\n            hevmCodeSize := extcodesize(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D)\n        }\n        return hevmCodeSize > 0;\n    }\n\n    modifier logs_gas() {\n        uint startGas = gasleft();\n        _;\n        uint endGas = gasleft();\n        emit log_named_uint(\"gas\", startGas - endGas);\n    }\n\n    function assertTrue(bool condition) internal {\n        if (!condition) {\n            emit log(\"Error: Assertion Failed\");\n            fail();\n        }\n    }\n\n    function assertTrue(bool condition, string memory err) internal {\n        if (!condition) {\n            emit log_named_string(\"Error\", err);\n            assertTrue(condition);\n        }\n    }\n\n    function assertEq(address a, address b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [address]\");\n            emit log_named_address(\"  Expected\", b);\n            emit log_named_address(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(address a, address b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes32 a, bytes32 b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [bytes32]\");\n            emit log_named_bytes32(\"  Expected\", b);\n            emit log_named_bytes32(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string (\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq32(bytes32 a, bytes32 b) internal {\n        assertEq(a, b);\n    }\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\n        assertEq(a, b, err);\n    }\n\n    function assertEq(int a, int b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [int]\");\n            emit log_named_int(\"  Expected\", b);\n            emit log_named_int(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(int a, int b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEq(uint a, uint b) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [uint]\");\n            emit log_named_uint(\"  Expected\", b);\n            emit log_named_uint(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(uint a, uint b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\n        if (a != b) {\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\n            fail();\n        }\n    }\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEqDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGt(uint a, uint b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(uint a, uint b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGt(int a, int b) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGt(int a, int b, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGt(a, b);\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\n        if (a <= b) {\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a <= b) {\n            emit log_named_string(\"Error\", err);\n            assertGtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertGe(uint a, uint b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(uint a, uint b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGe(int a, int b) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertGe(int a, int b, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGe(a, b);\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\n        if (a < b) {\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a < b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLt(uint a, uint b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(uint a, uint b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLt(int a, int b) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLt(int a, int b, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLt(a, b);\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\n        if (a >= b) {\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a >= b) {\n            emit log_named_string(\"Error\", err);\n            assertLtDecimal(a, b, decimals);\n        }\n    }\n\n    function assertLe(uint a, uint b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [uint]\");\n            emit log_named_uint(\"  Value a\", a);\n            emit log_named_uint(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(uint a, uint b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLe(int a, int b) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [int]\");\n            emit log_named_int(\"  Value a\", a);\n            emit log_named_int(\"  Value b\", b);\n            fail();\n        }\n    }\n    function assertLe(int a, int b, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLe(a, b);\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertLeDecimal(a, b, decimals);\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\n        if (a > b) {\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\n            fail();\n        }\n    }\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\n        if (a > b) {\n            emit log_named_string(\"Error\", err);\n            assertGeDecimal(a, b, decimals);\n        }\n    }\n\n    function assertEq(string memory a, string memory b) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log(\"Error: a == b not satisfied [string]\");\n            emit log_named_string(\"  Expected\", b);\n            emit log_named_string(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq(string memory a, string memory b, string memory err) internal {\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\n        ok = true;\n        if (a.length == b.length) {\n            for (uint i = 0; i < a.length; i++) {\n                if (a[i] != b[i]) {\n                    ok = false;\n                }\n            }\n        } else {\n            ok = false;\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b) internal {\n        if (!checkEq0(a, b)) {\n            emit log(\"Error: a == b not satisfied [bytes]\");\n            emit log_named_bytes(\"  Expected\", b);\n            emit log_named_bytes(\"    Actual\", a);\n            fail();\n        }\n    }\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\n        if (!checkEq0(a, b)) {\n            emit log_named_string(\"Error\", err);\n            assertEq0(a, b);\n        }\n    }\n}\n"
    },
    "node_modules/excessively-safe-call/src/ExcessivelySafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.7.6;\n\nlibrary ExcessivelySafeCall {\n    uint256 constant LOW_28_MASK =\n        0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _value The value in wei to send to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint256 _gas,\n        uint256 _value,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                _value, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint256 _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint256 _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n                _gas, // gas\n                _target, // recipient\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(bytes4 _newSelector, bytes memory _buf)\n        internal\n        pure\n    {\n        require(_buf.length >= 4);\n        uint256 _mask = LOW_28_MASK;\n        assembly {\n            // load the first word of\n            let _word := mload(add(_buf, 0x20))\n            // mask out the top 4 bytes\n            // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}\n"
    },
    "node_modules/forge-std/src/Script.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"./Vm.sol\";\nimport \"./console.sol\";\nimport \"./console2.sol\";\n\nabstract contract Script {\n    address constant private VM_ADDRESS =\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\n\n    Vm public constant vm = Vm(VM_ADDRESS);\n}\n"
    },
    "node_modules/forge-std/src/Test.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.0 <0.9.0;\n\nimport \"./Script.sol\";\nimport \"ds-test/test.sol\";\n\n// Wrappers around Cheatcodes to avoid footguns\nabstract contract Test is DSTest, Script {\n    using stdStorage for StdStorage;\n\n    uint256 private constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n\n    event WARNING_Deprecated(string msg);\n\n    StdStorage internal stdstore;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-CHEATS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    // Skip forward or rewind time by the specified number of seconds\n    function skip(uint256 time) public {\n        vm.warp(block.timestamp + time);\n    }\n\n    function rewind(uint256 time) public {\n        vm.warp(block.timestamp - time);\n    }\n\n    // Setup a prank from an address that has some ether\n    function hoax(address who) public {\n        vm.deal(who, 1 << 128);\n        vm.prank(who);\n    }\n\n    function hoax(address who, uint256 give) public {\n        vm.deal(who, give);\n        vm.prank(who);\n    }\n\n    function hoax(address who, address origin) public {\n        vm.deal(who, 1 << 128);\n        vm.prank(who, origin);\n    }\n\n    function hoax(address who, address origin, uint256 give) public {\n        vm.deal(who, give);\n        vm.prank(who, origin);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    function startHoax(address who) public {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who);\n    }\n\n    function startHoax(address who, uint256 give) public {\n        vm.deal(who, give);\n        vm.startPrank(who);\n    }\n\n    // Start perpetual prank from an address that has some ether\n    // tx.origin is set to the origin parameter\n    function startHoax(address who, address origin) public {\n        vm.deal(who, 1 << 128);\n        vm.startPrank(who, origin);\n    }\n\n    function startHoax(address who, address origin, uint256 give) public {\n        vm.deal(who, give);\n        vm.startPrank(who, origin);\n    }\n\n    function changePrank(address who) internal {\n        vm.stopPrank();\n        vm.startPrank(who);\n    }\n\n    // DEPRECATED: Use `deal` instead\n    function tip(address token, address to, uint256 give) public {\n        emit WARNING_Deprecated(\"The `tip` stdcheat has been deprecated. Use `deal` instead.\");\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n    }\n\n    // The same as Hevm's `deal`\n    // Use the alternative signature for ERC20 tokens\n    function deal(address to, uint256 give) public {\n        vm.deal(to, give);\n    }\n\n    // Set the balance of an account for any ERC20 token\n    // Use the alternative signature to update `totalSupply`\n    function deal(address token, address to, uint256 give) public {\n        deal(token, to, give, false);\n    }\n\n    function deal(address token, address to, uint256 give, bool adjust) public {\n        // get current balance\n        (, bytes memory balData) = token.call(abi.encodeWithSelector(0x70a08231, to));\n        uint256 prevBal = abi.decode(balData, (uint256));\n\n        // update balance\n        stdstore\n            .target(token)\n            .sig(0x70a08231)\n            .with_key(to)\n            .checked_write(give);\n\n        // update total supply\n        if(adjust){\n            (, bytes memory totSupData) = token.call(abi.encodeWithSelector(0x18160ddd));\n            uint256 totSup = abi.decode(totSupData, (uint256));\n            if(give < prevBal) {\n                totSup -= (prevBal - give);\n            } else {\n                totSup += (give - prevBal);\n            }\n            stdstore\n                .target(token)\n                .sig(0x18160ddd)\n                .checked_write(totSup);\n        }\n    }\n\n    function bound(uint256 x, uint256 min, uint256 max) public returns (uint256 result) {\n        require(min <= max, \"Test bound(uint256,uint256,uint256): Max is less than min.\");\n\n        uint256 size = max - min;\n\n        if (size == 0)\n        {\n            result = min;\n        }\n        else if (size == UINT256_MAX)\n        {\n            result = x;\n        }\n        else\n        {\n            ++size; // make `max` inclusive\n            uint256 mod = x % size;\n            result = min + mod;\n        }\n\n        emit log_named_uint(\"Bound Result\", result);\n    }\n\n    // Deploy a contract by fetching the contract bytecode from\n    // the artifacts directory\n    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`\n    function deployCode(string memory what, bytes memory args)\n        public\n        returns (address addr)\n    {\n        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string,bytes): Deployment failed.\"\n        );\n    }\n\n    function deployCode(string memory what)\n        public\n        returns (address addr)\n    {\n        bytes memory bytecode = vm.getCode(what);\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create(0, add(bytecode, 0x20), mload(bytecode))\n        }\n\n        require(\n            addr != address(0),\n            \"Test deployCode(string): Deployment failed.\"\n        );\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    STD-ASSERTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    function fail(string memory err) internal virtual {\n        emit log_named_string(\"Error\", err);\n        fail();\n    }\n\n    function assertFalse(bool data) internal virtual {\n        assertTrue(!data);\n    }\n\n    function assertFalse(bool data, string memory err) internal virtual {\n        assertTrue(!data, err);\n    }\n\n    function assertEq(bool a, bool b) internal {\n        if (a != b) {\n            emit log                (\"Error: a == b not satisfied [bool]\");\n            emit log_named_string   (\"  Expected\", b ? \"true\" : \"false\");\n            emit log_named_string   (\"    Actual\", a ? \"true\" : \"false\");\n            fail();\n        }\n    }\n\n    function assertEq(bool a, bool b, string memory err) internal {\n        if (a != b) {\n            emit log_named_string(\"Error\", err);\n            assertEq(a, b);\n        }\n    }\n\n    function assertEq(bytes memory a, bytes memory b) internal {\n        assertEq0(a, b);\n    }\n\n    function assertEq(bytes memory a, bytes memory b, string memory err) internal {\n        assertEq0(a, b, err);\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint (\"  Expected\", b);\n            emit log_named_uint (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        uint256 a,\n        uint256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log            (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int  (\"  Expected\", b);\n            emit log_named_int  (\"    Actual\", a);\n            emit log_named_uint (\" Max Delta\", maxDelta);\n            emit log_named_uint (\"     Delta\", delta);\n            fail();\n        }\n    }\n\n    function assertApproxEqAbs(\n        int256 a,\n        int256 b,\n        uint256 maxDelta,\n        string memory err\n    ) internal virtual {\n        uint256 delta = stdMath.delta(a, b);\n\n        if (delta > maxDelta) {\n            emit log_named_string   (\"Error\", err);\n            assertApproxEqAbs(a, b, maxDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                    (\"Error: a ~= b not satisfied [uint]\");\n            emit log_named_uint         (\"    Expected\", b);\n            emit log_named_uint         (\"      Actual\", a);\n            emit log_named_decimal_uint (\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint (\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        uint256 a,\n        uint256 b,\n        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string       (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log                   (\"Error: a ~= b not satisfied [int]\");\n            emit log_named_int         (\"    Expected\", b);\n            emit log_named_int         (\"      Actual\", a);\n            emit log_named_decimal_uint(\" Max % Delta\", maxPercentDelta, 18);\n            emit log_named_decimal_uint(\"     % Delta\", percentDelta, 18);\n            fail();\n        }\n    }\n\n    function assertApproxEqRel(\n        int256 a,\n        int256 b,\n        uint256 maxPercentDelta,\n        string memory err\n    ) internal virtual {\n        if (b == 0) return assertEq(a, b); // If the expected is 0, actual must be too.\n\n        uint256 percentDelta = stdMath.percentDelta(a, b);\n\n        if (percentDelta > maxPercentDelta) {\n            emit log_named_string      (\"Error\", err);\n            assertApproxEqRel(a, b, maxPercentDelta);\n        }\n    }\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdError {\n    bytes public constant assertionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x01);\n    bytes public constant arithmeticError = abi.encodeWithSignature(\"Panic(uint256)\", 0x11);\n    bytes public constant divisionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x12);\n    bytes public constant enumConversionError = abi.encodeWithSignature(\"Panic(uint256)\", 0x21);\n    bytes public constant encodeStorageError = abi.encodeWithSignature(\"Panic(uint256)\", 0x22);\n    bytes public constant popError = abi.encodeWithSignature(\"Panic(uint256)\", 0x31);\n    bytes public constant indexOOBError = abi.encodeWithSignature(\"Panic(uint256)\", 0x32);\n    bytes public constant memOverflowError = abi.encodeWithSignature(\"Panic(uint256)\", 0x41);\n    bytes public constant zeroVarError = abi.encodeWithSignature(\"Panic(uint256)\", 0x51);\n    // DEPRECATED: Use Hevm's `expectRevert` without any arguments instead\n    bytes public constant lowLevelError = bytes(\"\"); // `0x`\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-STORAGE\n//////////////////////////////////////////////////////////////////////////*/\n\nstruct StdStorage {\n    mapping (address => mapping(bytes4 => mapping(bytes32 => uint256))) slots;\n    mapping (address => mapping(bytes4 =>  mapping(bytes32 => bool))) finds;\n\n    bytes32[] _keys;\n    bytes4 _sig;\n    uint256 _depth;\n    address _target;\n    bytes32 _set;\n}\n\nlibrary stdStorage {\n    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint slot);\n    event WARNING_UninitedSlot(address who, uint slot);\n\n    uint256 private constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\n    int256 private constant INT256_MAX = 57896044618658097711785492504343953926634992332820282019728792003956564819967;\n\n    Vm private constant vm_std_store = Vm(address(uint160(uint256(keccak256('hevm cheat code')))));\n\n    function sigs(\n        string memory sigStr\n    )\n        internal\n        pure\n        returns (bytes4)\n    {\n        return bytes4(keccak256(bytes(sigStr)));\n    }\n\n    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against\n    // slot complexity:\n    //  if flat, will be bytes32(uint256(uint));\n    //  if map, will be keccak256(abi.encode(key, uint(slot)));\n    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));\n    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);\n    function find(\n        StdStorage storage self\n    )\n        internal\n        returns (uint256)\n    {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        // calldata to test against\n        if (self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n        }\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        vm_std_store.record();\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n\n        (bytes32[] memory reads, ) = vm_std_store.accesses(address(who));\n        if (reads.length == 1) {\n            bytes32 curr = vm_std_store.load(who, reads[0]);\n            if (curr == bytes32(0)) {\n                emit WARNING_UninitedSlot(who, uint256(reads[0]));\n            }\n            if (fdat != curr) {\n                require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isnt supported\");\n            }\n            emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[0]));\n            self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[0]);\n            self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n        } else if (reads.length > 1) {\n            for (uint256 i = 0; i < reads.length; i++) {\n                bytes32 prev = vm_std_store.load(who, reads[i]);\n                if (prev == bytes32(0)) {\n                    emit WARNING_UninitedSlot(who, uint256(reads[i]));\n                }\n                // store\n                vm_std_store.store(who, reads[i], bytes32(hex\"1337\"));\n                bool success;\n                bytes memory rdat;\n                {\n                    (success, rdat) = who.staticcall(cald);\n                    fdat = bytesToBytes32(rdat, 32*field_depth);\n                }\n\n                if (success && fdat == bytes32(hex\"1337\")) {\n                    // we found which of the slots is the actual one\n                    emit SlotFound(who, fsig, keccak256(abi.encodePacked(ins, field_depth)), uint256(reads[i]));\n                    self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = uint256(reads[i]);\n                    self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))] = true;\n                    vm_std_store.store(who, reads[i], prev);\n                    break;\n                }\n                vm_std_store.store(who, reads[i], prev);\n            }\n        } else {\n            require(false, \"stdStorage find(StdStorage): No storage use detected for target.\");\n        }\n\n        require(self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))], \"stdStorage find(StdStorage): Slot(s) not found.\");\n\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n\n        return self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))];\n    }\n\n    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {\n        self._target = _target;\n        return self;\n    }\n\n    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {\n        self._sig = _sig;\n        return self;\n    }\n\n    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {\n        self._sig = sigs(_sig);\n        return self;\n    }\n\n    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(uint256(uint160(who))));\n        return self;\n    }\n\n    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {\n        self._keys.push(bytes32(amt));\n        return self;\n    }\n    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {\n        self._keys.push(key);\n        return self;\n    }\n\n    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {\n        self._depth = _depth;\n        return self;\n    }\n\n    function checked_write(StdStorage storage self, address who) internal {\n        checked_write(self, bytes32(uint256(uint160(who))));\n    }\n\n    function checked_write(StdStorage storage self, uint256 amt) internal {\n        checked_write(self, bytes32(amt));\n    }\n\n    function checked_write(StdStorage storage self, bool write) internal {\n        bytes32 t;\n        /// @solidity memory-safe-assembly\n        assembly {\n            t := write\n        }\n        checked_write(self, t);\n    }\n\n    function checked_write(\n        StdStorage storage self,\n        bytes32 set\n    ) internal {\n        address who = self._target;\n        bytes4 fsig = self._sig;\n        uint256 field_depth = self._depth;\n        bytes32[] memory ins = self._keys;\n\n        bytes memory cald = abi.encodePacked(fsig, flatten(ins));\n        if (!self.finds[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]) {\n            find(self);\n        }\n        bytes32 slot = bytes32(self.slots[who][fsig][keccak256(abi.encodePacked(ins, field_depth))]);\n\n        bytes32 fdat;\n        {\n            (, bytes memory rdat) = who.staticcall(cald);\n            fdat = bytesToBytes32(rdat, 32*field_depth);\n        }\n        bytes32 curr = vm_std_store.load(who, slot);\n\n        if (fdat != curr) {\n            require(false, \"stdStorage find(StdStorage): Packed slot. This would cause dangerous overwriting and currently isnt supported.\");\n        }\n        vm_std_store.store(who, slot, set);\n        delete self._target;\n        delete self._sig;\n        delete self._keys;\n        delete self._depth;\n    }\n\n    function read(StdStorage storage self) private returns (bytes memory) {\n        address t = self._target;\n        uint256 s = find(self);\n        return abi.encode(vm_std_store.load(t, bytes32(s)));\n    }\n\n    function read_bytes32(StdStorage storage self) internal returns (bytes32) {\n        return abi.decode(read(self), (bytes32));\n    }\n\n\n    function read_bool(StdStorage storage self) internal returns (bool) {\n        return abi.decode(read(self), (bool));\n    }\n\n    function read_address(StdStorage storage self) internal returns (address) {\n        return abi.decode(read(self), (address));\n    }\n\n    function read_uint(StdStorage storage self) internal returns (uint256) {\n        return abi.decode(read(self), (uint256));\n    }\n\n    function read_int(StdStorage storage self) internal returns (int256) {\n        return abi.decode(read(self), (int256));\n    }\n\n    function bytesToBytes32(bytes memory b, uint offset) public pure returns (bytes32) {\n        bytes32 out;\n\n        uint256 max = b.length > 32 ? 32 : b.length;\n        for (uint i = 0; i < max; i++) {\n            out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);\n        }\n        return out;\n    }\n\n    function flatten(bytes32[] memory b) private pure returns (bytes memory)\n    {\n        bytes memory result = new bytes(b.length * 32);\n        for (uint256 i = 0; i < b.length; i++) {\n            bytes32 k = b[i];\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(add(result, add(32, mul(32, i))), k)\n            }\n        }\n\n        return result;\n    }\n}\n\n/*//////////////////////////////////////////////////////////////////////////\n                                STD-MATH\n//////////////////////////////////////////////////////////////////////////*/\n\nlibrary stdMath {\n    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n    function abs(int256 a) internal pure returns (uint256) {\n        // Required or it will fail when `a = type(int256).min`\n        if (a == INT256_MIN)\n            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n        return uint256(a >= 0 ? a : -a);\n    }\n\n    function delta(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b\n            ? a - b\n            : b - a;\n    }\n\n    function delta(int256 a, int256 b) internal pure returns (uint256) {\n        // a and b are of the same sign\n        if (a >= 0 && b >= 0 || a < 0 && b < 0) {\n            return delta(abs(a), abs(b));\n        }\n\n        // a and b are of opposite signs\n        return abs(a) + abs(b);\n    }\n\n    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n\n        return absDelta * 1e18 / b;\n    }\n\n    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {\n        uint256 absDelta = delta(a, b);\n        uint256 absB = abs(b);\n\n        return absDelta * 1e18 / absB;\n    }\n}\n"
    },
    "node_modules/forge-std/src/Vm.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\ninterface Vm {\n    // Set block.timestamp (newTimestamp)\n    function warp(uint256) external;\n    // Set block.height (newHeight)\n    function roll(uint256) external;\n    // Set block.basefee (newBasefee)\n    function fee(uint256) external;\n    // Set block.chainid\n    function chainId(uint256) external;\n    // Loads a storage slot from an address (who, slot)\n    function load(address,bytes32) external returns (bytes32);\n    // Stores a value to an address' storage slot, (who, slot, value)\n    function store(address,bytes32,bytes32) external;\n    // Signs data, (privateKey, digest) => (v, r, s)\n    function sign(uint256,bytes32) external returns (uint8,bytes32,bytes32);\n    // Gets address for a given private key, (privateKey) => (address)\n    function addr(uint256) external returns (address);\n    // Gets the nonce of an account\n    function getNonce(address) external returns (uint64);\n    // Sets the nonce of an account; must be higher than the current nonce of the account\n    function setNonce(address, uint64) external;\n    // Performs a foreign function call via terminal, (stringInputs) => (result)\n    function ffi(string[] calldata) external returns (bytes memory);\n    // Set environment variables, (name, value)\n    function setEnv(string calldata, string calldata) external;\n    // Read environment variables, (name) => (value)\n    function envBool(string calldata) external returns (bool);\n    function envUint(string calldata) external returns (uint256);\n    function envInt(string calldata) external returns (int256);\n    function envAddress(string calldata) external returns (address);\n    function envBytes32(string calldata) external returns (bytes32);\n    function envString(string calldata) external returns (string memory);\n    function envBytes(string calldata) external returns (bytes memory);\n    // Read environment variables as arrays, (name, delim) => (value[])\n    function envBool(string calldata, string calldata) external returns (bool[] memory);\n    function envUint(string calldata, string calldata) external returns (uint256[] memory);\n    function envInt(string calldata, string calldata) external returns (int256[] memory);\n    function envAddress(string calldata, string calldata) external returns (address[] memory);\n    function envBytes32(string calldata, string calldata) external returns (bytes32[] memory);\n    function envString(string calldata, string calldata) external returns (string[] memory);\n    function envBytes(string calldata, string calldata) external returns (bytes[] memory);\n    // Sets the *next* call's msg.sender to be the input address\n    function prank(address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called\n    function startPrank(address) external;\n    // Sets the *next* call's msg.sender to be the input address, and the tx.origin to be the second input\n    function prank(address,address) external;\n    // Sets all subsequent calls' msg.sender to be the input address until `stopPrank` is called, and the tx.origin to be the second input\n    function startPrank(address,address) external;\n    // Resets subsequent calls' msg.sender to be `address(this)`\n    function stopPrank() external;\n    // Sets an address' balance, (who, newBalance)\n    function deal(address, uint256) external;\n    // Sets an address' code, (who, newCode)\n    function etch(address, bytes calldata) external;\n    // Expects an error on next call\n    function expectRevert(bytes calldata) external;\n    function expectRevert(bytes4) external;\n    function expectRevert() external;\n    // Record all storage reads and writes\n    function record() external;\n    // Gets all accessed reads and write slot from a recording session, for a given address\n    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes);\n    // Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData).\n    // Call this function, then emit an event, then call a function. Internally after the call, we check if\n    // logs were emitted in the expected order with the expected topics and data (as specified by the booleans)\n    function expectEmit(bool,bool,bool,bool) external;\n    function expectEmit(bool,bool,bool,bool,address) external;\n    // Mocks a call to an address, returning specified data.\n    // Calldata can either be strict or a partial match, e.g. if you only\n    // pass a Solidity selector to the expected calldata, then the entire Solidity\n    // function will be mocked.\n    function mockCall(address,bytes calldata,bytes calldata) external;\n    // Mocks a call to an address with a specific msg.value, returning specified data.\n    // Calldata match takes precedence over msg.value in case of ambiguity.\n    function mockCall(address,uint256,bytes calldata,bytes calldata) external;\n    // Clears all mocked calls\n    function clearMockedCalls() external;\n    // Expect a call to an address with the specified calldata.\n    // Calldata can either be strict or a partial match\n    function expectCall(address,bytes calldata) external;\n    // Expect a call to an address with the specified msg.value and calldata\n    function expectCall(address,uint256,bytes calldata) external;\n    // Gets the code from an artifact file. Takes in the relative path to the json file\n    function getCode(string calldata) external returns (bytes memory);\n    // Labels an address in call traces\n    function label(address, string calldata) external;\n    // If the condition is false, discard this run's fuzz inputs and generate new ones\n    function assume(bool) external;\n    // Set block.coinbase (who)\n    function coinbase(address) external;\n    // Using the address that calls the test contract, has the next call (at this call depth only) create a transaction that can later be signed and sent onchain\n    function broadcast() external;\n    // Has the next call (at this call depth only) create a transaction with the address provided as the sender that can later be signed and sent onchain\n    function broadcast(address) external;\n    // Using the address that calls the test contract, has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast() external;\n    // Has the all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain\n    function startBroadcast(address) external;\n    // Stops collecting onchain transactions\n    function stopBroadcast() external;\n}\n"
    },
    "node_modules/forge-std/src/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n    }\n\n    function logUint(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n    }\n\n    function log(uint p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n    }\n\n    function log(uint p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n    }\n\n    function log(uint p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    },
    "node_modules/forge-std/src/console2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\n// The orignal console.sol uses `int` and `uint` for computing function selectors, but it should\n// use `int256` and `uint256`. This modified version fixes that. This version is recommended\n// over `console.sol` if you don't need compatibility with Hardhat as the logs will show up in\n// forge stack traces. If you do need compatibility with Hardhat, you must use `console.sol`.\n// Reference: https://github.com/NomicFoundation/hardhat/issues/2178\n\nlibrary console2 {\n    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n    function _sendLogPayload(bytes memory payload) private view {\n        uint256 payloadLength = payload.length;\n        address consoleAddress = CONSOLE_ADDRESS;\n        assembly {\n            let payloadStart := add(payload, 32)\n            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n        }\n    }\n\n    function log() internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal view {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/=node_modules/@openzeppelin/",
      "@openzeppelin/contracts-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/",
      "@openzeppelin/contracts/=node_modules/@openzeppelin/contracts/",
      "@rari-capital/=node_modules/@rari-capital/",
      "@rari-capital/solmate/=node_modules/@rari-capital/solmate/",
      "ds-test/=node_modules/ds-test/src/",
      "excessively-safe-call/=node_modules/excessively-safe-call/",
      "forge-std/=node_modules/forge-std/src/",
      "contracts/=contracts/",
      "test/=test/"
    ],
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "metadata": {
      "bytecodeHash": "none"
    },
    "outputSelection": {
      "*": {
        "": [
          "ast"
        ],
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc"
        ]
      }
    },
    "evmVersion": "london",
    "libraries": {}
  }
}