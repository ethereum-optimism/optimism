{
  "address": "0xE969C2724d2448F1d1A6189d3e2aA1F37d5998c1",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_libAddressManager",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_fraudProofWindow",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_sequencerPublishWindow",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "_batchIndex",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "_batchRoot",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_batchSize",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_prevTotalElements",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "_extraData",
          "type": "bytes"
        }
      ],
      "name": "StateBatchAppended",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "_batchIndex",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "_batchRoot",
          "type": "bytes32"
        }
      ],
      "name": "StateBatchDeleted",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "FRAUD_PROOF_WINDOW",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SEQUENCER_PUBLISH_WINDOW",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32[]",
          "name": "_batch",
          "type": "bytes32[]"
        },
        {
          "internalType": "uint256",
          "name": "_shouldStartAtElement",
          "type": "uint256"
        }
      ],
      "name": "appendStateBatch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "batches",
      "outputs": [
        {
          "internalType": "contract iOVM_ChainStorageContainer",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "batchIndex",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "batchRoot",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "batchSize",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "prevTotalElements",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "extraData",
              "type": "bytes"
            }
          ],
          "internalType": "struct Lib_OVMCodec.ChainBatchHeader",
          "name": "_batchHeader",
          "type": "tuple"
        }
      ],
      "name": "deleteStateBatch",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getLastSequencerTimestamp",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_lastSequencerTimestamp",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getTotalBatches",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_totalBatches",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getTotalElements",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "_totalElements",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "batchIndex",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "batchRoot",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "batchSize",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "prevTotalElements",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "extraData",
              "type": "bytes"
            }
          ],
          "internalType": "struct Lib_OVMCodec.ChainBatchHeader",
          "name": "_batchHeader",
          "type": "tuple"
        }
      ],
      "name": "insideFraudProofWindow",
      "outputs": [
        {
          "internalType": "bool",
          "name": "_inside",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "libAddressManager",
      "outputs": [
        {
          "internalType": "contract Lib_AddressManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "_name",
          "type": "string"
        }
      ],
      "name": "resolve",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_element",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "batchIndex",
              "type": "uint256"
            },
            {
              "internalType": "bytes32",
              "name": "batchRoot",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "batchSize",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "prevTotalElements",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "extraData",
              "type": "bytes"
            }
          ],
          "internalType": "struct Lib_OVMCodec.ChainBatchHeader",
          "name": "_batchHeader",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "index",
              "type": "uint256"
            },
            {
              "internalType": "bytes32[]",
              "name": "siblings",
              "type": "bytes32[]"
            }
          ],
          "internalType": "struct Lib_OVMCodec.ChainInclusionProof",
          "name": "_proof",
          "type": "tuple"
        }
      ],
      "name": "verifyStateCommitment",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x67c2ea9f14079f9b3c2b7b074401856f9837c99d55ec9191cc1eda1fbb2dcb9c",
  "receipt": {
    "to": null,
    "from": "0x9996571372066A1545D3435C6935e3F9593A7eF5",
    "contractAddress": "0xE969C2724d2448F1d1A6189d3e2aA1F37d5998c1",
    "transactionIndex": 177,
    "gasUsed": "1630177",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x9917443bb50022ebdac59d71a12d0d562522c3e8c8ade23d30eb39eeeadb72d2",
    "transactionHash": "0x67c2ea9f14079f9b3c2b7b074401856f9837c99d55ec9191cc1eda1fbb2dcb9c",
    "logs": [],
    "blockNumber": 12686746,
    "cumulativeGasUsed": "14820986",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xdE1FCfB0851916CA5101820A69b13a4E276bd81F",
    604800,
    12592000
  ],
  "solcInputHash": "ef3f334bac4d7e77d91b457a0d89ab0a",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_libAddressManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fraudProofWindow\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sequencerPublishWindow\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_batchIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_batchRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_batchSize\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_prevTotalElements\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"StateBatchAppended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_batchIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_batchRoot\",\"type\":\"bytes32\"}],\"name\":\"StateBatchDeleted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FRAUD_PROOF_WINDOW\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SEQUENCER_PUBLISH_WINDOW\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_batch\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_shouldStartAtElement\",\"type\":\"uint256\"}],\"name\":\"appendStateBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"batches\",\"outputs\":[{\"internalType\":\"contract iOVM_ChainStorageContainer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"batchSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevTotalElements\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct Lib_OVMCodec.ChainBatchHeader\",\"name\":\"_batchHeader\",\"type\":\"tuple\"}],\"name\":\"deleteStateBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastSequencerTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_lastSequencerTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBatches\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalBatches\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalElements\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalElements\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"batchSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevTotalElements\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct Lib_OVMCodec.ChainBatchHeader\",\"name\":\"_batchHeader\",\"type\":\"tuple\"}],\"name\":\"insideFraudProofWindow\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_inside\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"libAddressManager\",\"outputs\":[{\"internalType\":\"contract Lib_AddressManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_element\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"batchIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"batchSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevTotalElements\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct Lib_OVMCodec.ChainBatchHeader\",\"name\":\"_batchHeader\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct Lib_OVMCodec.ChainInclusionProof\",\"name\":\"_proof\",\"type\":\"tuple\"}],\"name\":\"verifyStateCommitment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"The State Commitment Chain (SCC) contract contains a list of proposed state roots which Proposers assert to be a result of each transaction in the Canonical Transaction Chain (CTC). Elements here have a 1:1 correspondence with transactions in the CTC, and should be the unique state root calculated off-chain by applying the canonical transactions one by one. Compiler used: solc Runtime target: EVM\",\"kind\":\"dev\",\"methods\":{\"appendStateBatch(bytes32[],uint256)\":{\"params\":{\"_batch\":\"Batch of state roots.\",\"_shouldStartAtElement\":\"Index of the element at which this batch should start.\"}},\"batches()\":{\"returns\":{\"_0\":\"Reference to the batch storage container.\"}},\"constructor\":{\"params\":{\"_libAddressManager\":\"Address of the Address Manager.\"}},\"deleteStateBatch((uint256,bytes32,uint256,uint256,bytes))\":{\"params\":{\"_batchHeader\":\"Header of the batch to start deleting from.\"}},\"getLastSequencerTimestamp()\":{\"returns\":{\"_lastSequencerTimestamp\":\"Last sequencer batch timestamp.\"}},\"getTotalBatches()\":{\"returns\":{\"_totalBatches\":\"Total submitted batches.\"}},\"getTotalElements()\":{\"returns\":{\"_totalElements\":\"Total submitted elements.\"}},\"insideFraudProofWindow((uint256,bytes32,uint256,uint256,bytes))\":{\"params\":{\"_batchHeader\":\"Header of the batch to check.\"},\"returns\":{\"_inside\":\"Whether or not the batch is inside the fraud proof window.\"}},\"resolve(string)\":{\"params\":{\"_name\":\"Name to resolve an address for.\"},\"returns\":{\"_0\":\"Address associated with the given name.\"}},\"verifyStateCommitment(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]))\":{\"params\":{\"_batchHeader\":\"Header of the batch in which the element was included.\",\"_element\":\"Hash of the element to verify a proof for.\",\"_proof\":\"Merkle inclusion proof for the element.\"}}},\"title\":\"OVM_StateCommitmentChain\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"appendStateBatch(bytes32[],uint256)\":{\"notice\":\"Appends a batch of state roots to the chain.\"},\"batches()\":{\"notice\":\"Accesses the batch storage container.\"},\"deleteStateBatch((uint256,bytes32,uint256,uint256,bytes))\":{\"notice\":\"Deletes all state roots after (and including) a given batch.\"},\"getLastSequencerTimestamp()\":{\"notice\":\"Retrieves the timestamp of the last batch submitted by the sequencer.\"},\"getTotalBatches()\":{\"notice\":\"Retrieves the total number of batches submitted.\"},\"getTotalElements()\":{\"notice\":\"Retrieves the total number of elements submitted.\"},\"insideFraudProofWindow((uint256,bytes32,uint256,uint256,bytes))\":{\"notice\":\"Checks whether a given batch is still inside its fraud proof window.\"},\"resolve(string)\":{\"notice\":\"Resolves the address associated with a given name.\"},\"verifyStateCommitment(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]))\":{\"notice\":\"Verifies a batch inclusion proof.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/optimistic-ethereum/OVM/chain/OVM_StateCommitmentChain.sol\":\"OVM_StateCommitmentChain\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\",\"keccak256\":\"0x15e2d5bd4c28a88548074c54d220e8086f638a71ed07e6b3ba5a70066fcf458d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xcc78a17dd88fa5a2edc60c8489e2f405c0913b377216a5b26b35656b2d0dab52\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x8d3cb350f04ff49cfb10aef08d87f19dcbaecc8027b0bed12f3275cd12f38cf0\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/OVM/chain/OVM_StateCommitmentChain.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\nimport { Lib_AddressResolver } from \\\"../../libraries/resolver/Lib_AddressResolver.sol\\\";\\nimport { Lib_MerkleTree } from \\\"../../libraries/utils/Lib_MerkleTree.sol\\\";\\n\\n/* Interface Imports */\\nimport { iOVM_FraudVerifier } from \\\"../../iOVM/verification/iOVM_FraudVerifier.sol\\\";\\nimport { iOVM_StateCommitmentChain } from \\\"../../iOVM/chain/iOVM_StateCommitmentChain.sol\\\";\\nimport { iOVM_CanonicalTransactionChain } from \\\"../../iOVM/chain/iOVM_CanonicalTransactionChain.sol\\\";\\nimport { iOVM_BondManager } from \\\"../../iOVM/verification/iOVM_BondManager.sol\\\";\\nimport { iOVM_ChainStorageContainer } from \\\"../../iOVM/chain/iOVM_ChainStorageContainer.sol\\\";\\n\\n/* External Imports */\\nimport '@openzeppelin/contracts/math/SafeMath.sol';\\n\\n/**\\n * @title OVM_StateCommitmentChain\\n * @dev The State Commitment Chain (SCC) contract contains a list of proposed state roots which\\n * Proposers assert to be a result of each transaction in the Canonical Transaction Chain (CTC).\\n * Elements here have a 1:1 correspondence with transactions in the CTC, and should be the unique\\n * state root calculated off-chain by applying the canonical transactions one by one.\\n *\\n * Compiler used: solc\\n * Runtime target: EVM\\n */\\ncontract OVM_StateCommitmentChain is iOVM_StateCommitmentChain, Lib_AddressResolver {\\n\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    uint256 public FRAUD_PROOF_WINDOW;\\n    uint256 public SEQUENCER_PUBLISH_WINDOW;\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Address Manager.\\n     */\\n    constructor(\\n        address _libAddressManager,\\n        uint256 _fraudProofWindow,\\n        uint256 _sequencerPublishWindow\\n    )\\n        Lib_AddressResolver(_libAddressManager)\\n    {\\n        FRAUD_PROOF_WINDOW = _fraudProofWindow;\\n        SEQUENCER_PUBLISH_WINDOW = _sequencerPublishWindow;\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Accesses the batch storage container.\\n     * @return Reference to the batch storage container.\\n     */\\n    function batches()\\n        public\\n        view\\n        returns (\\n            iOVM_ChainStorageContainer\\n        )\\n    {\\n        return iOVM_ChainStorageContainer(\\n            resolve(\\\"OVM_ChainStorageContainer-SCC-batches\\\")\\n        );\\n    }\\n\\n    /**\\n     * @inheritdoc iOVM_StateCommitmentChain\\n     */\\n    function getTotalElements()\\n        override\\n        public\\n        view\\n        returns (\\n            uint256 _totalElements\\n        )\\n    {\\n        (uint40 totalElements, ) = _getBatchExtraData();\\n        return uint256(totalElements);\\n    }\\n\\n    /**\\n     * @inheritdoc iOVM_StateCommitmentChain\\n     */\\n    function getTotalBatches()\\n        override\\n        public\\n        view\\n        returns (\\n            uint256 _totalBatches\\n        )\\n    {\\n        return batches().length();\\n    }\\n\\n    /**\\n     * @inheritdoc iOVM_StateCommitmentChain\\n     */\\n    function getLastSequencerTimestamp()\\n        override\\n        public\\n        view\\n        returns (\\n            uint256 _lastSequencerTimestamp\\n        )\\n    {\\n        (, uint40 lastSequencerTimestamp) = _getBatchExtraData();\\n        return uint256(lastSequencerTimestamp);\\n    }\\n\\n    /**\\n     * @inheritdoc iOVM_StateCommitmentChain\\n     */\\n    function appendStateBatch(\\n        bytes32[] memory _batch,\\n        uint256 _shouldStartAtElement\\n    )\\n        override\\n        public\\n    {\\n        // Fail fast in to make sure our batch roots aren't accidentally made fraudulent by the\\n        // publication of batches by some other user.\\n        require(\\n            _shouldStartAtElement == getTotalElements(),\\n            \\\"Actual batch start index does not match expected start index.\\\"\\n        );\\n\\n        // Proposers must have previously staked at the BondManager\\n        require(\\n            iOVM_BondManager(resolve(\\\"OVM_BondManager\\\")).isCollateralized(msg.sender),\\n            \\\"Proposer does not have enough collateral posted\\\"\\n        );\\n\\n        require(\\n            _batch.length > 0,\\n            \\\"Cannot submit an empty state batch.\\\"\\n        );\\n\\n        require(\\n            getTotalElements() + _batch.length <= iOVM_CanonicalTransactionChain(resolve(\\\"OVM_CanonicalTransactionChain\\\")).getTotalElements(),\\n            \\\"Number of state roots cannot exceed the number of canonical transactions.\\\"\\n        );\\n\\n        // Pass the block's timestamp and the publisher of the data\\n        // to be used in the fraud proofs\\n        _appendBatch(\\n            _batch,\\n            abi.encode(block.timestamp, msg.sender)\\n        );\\n    }\\n\\n    /**\\n     * @inheritdoc iOVM_StateCommitmentChain\\n     */\\n    function deleteStateBatch(\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\\n    )\\n        override\\n        public\\n    {\\n        require(\\n            msg.sender == resolve(\\\"OVM_FraudVerifier\\\"),\\n            \\\"State batches can only be deleted by the OVM_FraudVerifier.\\\"\\n        );\\n\\n        require(\\n            _isValidBatchHeader(_batchHeader),\\n            \\\"Invalid batch header.\\\"\\n        );\\n\\n        require(\\n            insideFraudProofWindow(_batchHeader),\\n            \\\"State batches can only be deleted within the fraud proof window.\\\"\\n        );\\n\\n        _deleteBatch(_batchHeader);\\n    }\\n\\n    /**\\n     * @inheritdoc iOVM_StateCommitmentChain\\n     */\\n    function verifyStateCommitment(\\n        bytes32 _element,\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\\n        Lib_OVMCodec.ChainInclusionProof memory _proof\\n    )\\n        override\\n        public\\n        view\\n        returns (\\n            bool\\n        )\\n    {\\n        require(\\n            _isValidBatchHeader(_batchHeader),\\n            \\\"Invalid batch header.\\\"\\n        );\\n\\n        require(\\n            Lib_MerkleTree.verify(\\n                _batchHeader.batchRoot,\\n                _element,\\n                _proof.index,\\n                _proof.siblings,\\n                _batchHeader.batchSize\\n            ),\\n            \\\"Invalid inclusion proof.\\\"\\n        );\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @inheritdoc iOVM_StateCommitmentChain\\n     */\\n    function insideFraudProofWindow(\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\\n    )\\n        override\\n        public\\n        view\\n        returns (\\n            bool _inside\\n        )\\n    {\\n        (uint256 timestamp,) = abi.decode(\\n            _batchHeader.extraData,\\n            (uint256, address)\\n        );\\n\\n        require(\\n            timestamp != 0,\\n            \\\"Batch header timestamp cannot be zero\\\"\\n        );\\n        return SafeMath.add(timestamp, FRAUD_PROOF_WINDOW) > block.timestamp;\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Parses the batch context from the extra data.\\n     * @return Total number of elements submitted.\\n     * @return Timestamp of the last batch submitted by the sequencer.\\n     */\\n    function _getBatchExtraData()\\n        internal\\n        view\\n        returns (\\n            uint40,\\n            uint40\\n        )\\n    {\\n        bytes27 extraData = batches().getGlobalMetadata();\\n\\n        uint40 totalElements;\\n        uint40 lastSequencerTimestamp;\\n        assembly {\\n            extraData              := shr(40, extraData)\\n            totalElements          :=         and(extraData, 0x000000000000000000000000000000000000000000000000000000FFFFFFFFFF)\\n            lastSequencerTimestamp := shr(40, and(extraData, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000))\\n        }\\n\\n        return (\\n            totalElements,\\n            lastSequencerTimestamp\\n        );\\n    }\\n\\n    /**\\n     * Encodes the batch context for the extra data.\\n     * @param _totalElements Total number of elements submitted.\\n     * @param _lastSequencerTimestamp Timestamp of the last batch submitted by the sequencer.\\n     * @return Encoded batch context.\\n     */\\n    function _makeBatchExtraData(\\n        uint40 _totalElements,\\n        uint40 _lastSequencerTimestamp\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes27\\n        )\\n    {\\n        bytes27 extraData;\\n        assembly {\\n            extraData := _totalElements\\n            extraData := or(extraData, shl(40, _lastSequencerTimestamp))\\n            extraData := shl(40, extraData)\\n        }\\n\\n        return extraData;\\n    }\\n\\n    /**\\n     * Appends a batch to the chain.\\n     * @param _batch Elements within the batch.\\n     * @param _extraData Any extra data to append to the batch.\\n     */\\n    function _appendBatch(\\n        bytes32[] memory _batch,\\n        bytes memory _extraData\\n    )\\n        internal\\n    {\\n        address sequencer = resolve(\\\"OVM_Proposer\\\");\\n        (uint40 totalElements, uint40 lastSequencerTimestamp) = _getBatchExtraData();\\n\\n        if (msg.sender == sequencer) {\\n            lastSequencerTimestamp = uint40(block.timestamp);\\n        } else {\\n            // We keep track of the last batch submitted by the sequencer so there's a window in\\n            // which only the sequencer can publish state roots. A window like this just reduces\\n            // the chance of \\\"system breaking\\\" state roots being published while we're still in\\n            // testing mode. This window should be removed or significantly reduced in the future.\\n            require(\\n                lastSequencerTimestamp + SEQUENCER_PUBLISH_WINDOW < block.timestamp,\\n                \\\"Cannot publish state roots within the sequencer publication window.\\\"\\n            );\\n        }\\n\\n        // For efficiency reasons getMerkleRoot modifies the `_batch` argument in place\\n        // while calculating the root hash therefore any arguments passed to it must not\\n        // be used again afterwards\\n        Lib_OVMCodec.ChainBatchHeader memory batchHeader = Lib_OVMCodec.ChainBatchHeader({\\n            batchIndex: getTotalBatches(),\\n            batchRoot: Lib_MerkleTree.getMerkleRoot(_batch),\\n            batchSize: _batch.length,\\n            prevTotalElements: totalElements,\\n            extraData: _extraData\\n        });\\n\\n        emit StateBatchAppended(\\n            batchHeader.batchIndex,\\n            batchHeader.batchRoot,\\n            batchHeader.batchSize,\\n            batchHeader.prevTotalElements,\\n            batchHeader.extraData\\n        );\\n\\n        batches().push(\\n            Lib_OVMCodec.hashBatchHeader(batchHeader),\\n            _makeBatchExtraData(\\n                uint40(batchHeader.prevTotalElements + batchHeader.batchSize),\\n                lastSequencerTimestamp\\n            )\\n        );\\n    }\\n\\n    /**\\n     * Removes a batch and all subsequent batches from the chain.\\n     * @param _batchHeader Header of the batch to remove.\\n     */\\n    function _deleteBatch(\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\\n    )\\n        internal\\n    {\\n        require(\\n            _batchHeader.batchIndex < batches().length(),\\n            \\\"Invalid batch index.\\\"\\n        );\\n\\n        require(\\n            _isValidBatchHeader(_batchHeader),\\n            \\\"Invalid batch header.\\\"\\n        );\\n\\n        batches().deleteElementsAfterInclusive(\\n            _batchHeader.batchIndex,\\n            _makeBatchExtraData(\\n                uint40(_batchHeader.prevTotalElements),\\n                0\\n            )\\n        );\\n\\n        emit StateBatchDeleted(\\n            _batchHeader.batchIndex,\\n            _batchHeader.batchRoot\\n        );\\n    }\\n\\n    /**\\n     * Checks that a batch header matches the stored hash for the given index.\\n     * @param _batchHeader Batch header to validate.\\n     * @return Whether or not the header matches the stored one.\\n     */\\n    function _isValidBatchHeader(\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\\n    )\\n        internal\\n        view\\n        returns (\\n            bool\\n        )\\n    {\\n        return Lib_OVMCodec.hashBatchHeader(_batchHeader) == batches().get(_batchHeader.batchIndex);\\n    }\\n}\\n\",\"keccak256\":\"0x12cc020811ca6a41cbad48c2e6b812c1eeaca1dde65e09b4b51a1891e0872d92\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/chain/iOVM_CanonicalTransactionChain.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/* Interface Imports */\\nimport { iOVM_ChainStorageContainer } from \\\"./iOVM_ChainStorageContainer.sol\\\";\\n\\n/**\\n * @title iOVM_CanonicalTransactionChain\\n */\\ninterface iOVM_CanonicalTransactionChain {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event TransactionEnqueued(\\n        address _l1TxOrigin,\\n        address _target,\\n        uint256 _gasLimit,\\n        bytes _data,\\n        uint256 _queueIndex,\\n        uint256 _timestamp\\n    );\\n\\n    event QueueBatchAppended(\\n        uint256 _startingQueueIndex,\\n        uint256 _numQueueElements,\\n        uint256 _totalElements\\n    );\\n\\n    event SequencerBatchAppended(\\n        uint256 _startingQueueIndex,\\n        uint256 _numQueueElements,\\n        uint256 _totalElements\\n    );\\n\\n    event TransactionBatchAppended(\\n        uint256 indexed _batchIndex,\\n        bytes32 _batchRoot,\\n        uint256 _batchSize,\\n        uint256 _prevTotalElements,\\n        bytes _extraData\\n    );\\n\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct BatchContext {\\n        uint256 numSequencedTransactions;\\n        uint256 numSubsequentQueueTransactions;\\n        uint256 timestamp;\\n        uint256 blockNumber;\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n\\n    /**\\n     * Accesses the batch storage container.\\n     * @return Reference to the batch storage container.\\n     */\\n    function batches()\\n        external\\n        view\\n        returns (\\n            iOVM_ChainStorageContainer\\n        );\\n\\n    /**\\n     * Accesses the queue storage container.\\n     * @return Reference to the queue storage container.\\n     */\\n    function queue()\\n        external\\n        view\\n        returns (\\n            iOVM_ChainStorageContainer\\n        );\\n\\n    /**\\n     * Retrieves the total number of elements submitted.\\n     * @return _totalElements Total submitted elements.\\n     */\\n    function getTotalElements()\\n        external\\n        view\\n        returns (\\n            uint256 _totalElements\\n        );\\n\\n    /**\\n     * Retrieves the total number of batches submitted.\\n     * @return _totalBatches Total submitted batches.\\n     */\\n    function getTotalBatches()\\n        external\\n        view\\n        returns (\\n            uint256 _totalBatches\\n        );\\n\\n    /**\\n     * Returns the index of the next element to be enqueued.\\n     * @return Index for the next queue element.\\n     */\\n    function getNextQueueIndex()\\n        external\\n        view\\n        returns (\\n            uint40\\n        );\\n\\n    /**\\n     * Gets the queue element at a particular index.\\n     * @param _index Index of the queue element to access.\\n     * @return _element Queue element at the given index.\\n     */\\n    function getQueueElement(\\n        uint256 _index\\n    )\\n        external\\n        view\\n        returns (\\n            Lib_OVMCodec.QueueElement memory _element\\n        );\\n\\n    /**\\n     * Returns the timestamp of the last transaction.\\n     * @return Timestamp for the last transaction.\\n     */\\n    function getLastTimestamp()\\n        external\\n        view\\n        returns (\\n            uint40\\n        );\\n\\n    /**\\n     * Returns the blocknumber of the last transaction.\\n     * @return Blocknumber for the last transaction.\\n     */\\n    function getLastBlockNumber()\\n        external\\n        view\\n        returns (\\n            uint40\\n        );\\n\\n    /**\\n     * Get the number of queue elements which have not yet been included.\\n     * @return Number of pending queue elements.\\n     */\\n    function getNumPendingQueueElements()\\n        external\\n        view\\n        returns (\\n            uint40\\n        );\\n\\n    /**\\n     * Retrieves the length of the queue, including\\n     * both pending and canonical transactions.\\n     * @return Length of the queue.\\n     */\\n    function getQueueLength()\\n        external\\n        view\\n        returns (\\n            uint40\\n        );\\n\\n\\n    /**\\n     * Adds a transaction to the queue.\\n     * @param _target Target contract to send the transaction to.\\n     * @param _gasLimit Gas limit for the given transaction.\\n     * @param _data Transaction data.\\n     */\\n    function enqueue(\\n        address _target,\\n        uint256 _gasLimit,\\n        bytes memory _data\\n    )\\n        external;\\n\\n    /**\\n     * Appends a given number of queued transactions as a single batch.\\n     * @param _numQueuedTransactions Number of transactions to append.\\n     */\\n    function appendQueueBatch(\\n        uint256 _numQueuedTransactions\\n    )\\n        external;\\n\\n    /**\\n     * Allows the sequencer to append a batch of transactions.\\n     * @dev This function uses a custom encoding scheme for efficiency reasons.\\n     * .param _shouldStartAtElement Specific batch we expect to start appending to.\\n     * .param _totalElementsToAppend Total number of batch elements we expect to append.\\n     * .param _contexts Array of batch contexts.\\n     * .param _transactionDataFields Array of raw transaction data.\\n     */\\n    function appendSequencerBatch(\\n        // uint40 _shouldStartAtElement,\\n        // uint24 _totalElementsToAppend,\\n        // BatchContext[] _contexts,\\n        // bytes[] _transactionDataFields\\n    )\\n        external;\\n\\n    /**\\n     * Verifies whether a transaction is included in the chain.\\n     * @param _transaction Transaction to verify.\\n     * @param _txChainElement Transaction chain element corresponding to the transaction.\\n     * @param _batchHeader Header of the batch the transaction was included in.\\n     * @param _inclusionProof Inclusion proof for the provided transaction chain element.\\n     * @return True if the transaction exists in the CTC, false if not.\\n     */\\n    function verifyTransaction(\\n        Lib_OVMCodec.Transaction memory _transaction,\\n        Lib_OVMCodec.TransactionChainElement memory _txChainElement,\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\\n        Lib_OVMCodec.ChainInclusionProof memory _inclusionProof\\n    )\\n        external\\n        view\\n        returns (\\n            bool\\n        );\\n}\\n\",\"keccak256\":\"0xb5e55488a1982841c07cdf5ff475da4789596f111dd48f01b1918ee4c775cf3a\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/chain/iOVM_ChainStorageContainer.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title iOVM_ChainStorageContainer\\n */\\ninterface iOVM_ChainStorageContainer {\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Sets the container's global metadata field. We're using `bytes27` here because we use five\\n     * bytes to maintain the length of the underlying data structure, meaning we have an extra\\n     * 27 bytes to store arbitrary data.\\n     * @param _globalMetadata New global metadata to set.\\n     */\\n    function setGlobalMetadata(\\n        bytes27 _globalMetadata\\n    )\\n        external;\\n\\n    /**\\n     * Retrieves the container's global metadata field.\\n     * @return Container global metadata field.\\n     */\\n    function getGlobalMetadata()\\n        external\\n        view\\n        returns (\\n            bytes27\\n        );\\n\\n    /**\\n     * Retrieves the number of objects stored in the container.\\n     * @return Number of objects in the container.\\n     */\\n    function length()\\n        external\\n        view\\n        returns (\\n            uint256\\n        );\\n\\n    /**\\n     * Pushes an object into the container.\\n     * @param _object A 32 byte value to insert into the container.\\n     */\\n    function push(\\n        bytes32 _object\\n    )\\n        external;\\n\\n    /**\\n     * Pushes an object into the container. Function allows setting the global metadata since\\n     * we'll need to touch the \\\"length\\\" storage slot anyway, which also contains the global\\n     * metadata (it's an optimization).\\n     * @param _object A 32 byte value to insert into the container.\\n     * @param _globalMetadata New global metadata for the container.\\n     */\\n    function push(\\n        bytes32 _object,\\n        bytes27 _globalMetadata\\n    )\\n        external;\\n\\n    /**\\n     * Retrieves an object from the container.\\n     * @param _index Index of the particular object to access.\\n     * @return 32 byte object value.\\n     */\\n    function get(\\n        uint256 _index\\n    )\\n        external\\n        view\\n        returns (\\n            bytes32\\n        );\\n\\n    /**\\n     * Removes all objects after and including a given index.\\n     * @param _index Object index to delete from.\\n     */\\n    function deleteElementsAfterInclusive(\\n        uint256 _index\\n    )\\n        external;\\n\\n    /**\\n     * Removes all objects after and including a given index. Also allows setting the global\\n     * metadata field.\\n     * @param _index Object index to delete from.\\n     * @param _globalMetadata New global metadata for the container.\\n     */\\n    function deleteElementsAfterInclusive(\\n        uint256 _index,\\n        bytes27 _globalMetadata\\n    )\\n        external;\\n}\\n\",\"keccak256\":\"0x180b9c347e20f1a6efa553b0f2b9a59aebceda92a7484ae6fca4da2bf1d960c3\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/chain/iOVM_StateCommitmentChain.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/**\\n * @title iOVM_StateCommitmentChain\\n */\\ninterface iOVM_StateCommitmentChain {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event StateBatchAppended(\\n        uint256 indexed _batchIndex,\\n        bytes32 _batchRoot,\\n        uint256 _batchSize,\\n        uint256 _prevTotalElements,\\n        bytes _extraData\\n    );\\n\\n    event StateBatchDeleted(\\n        uint256 indexed _batchIndex,\\n        bytes32 _batchRoot\\n    );\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Retrieves the total number of elements submitted.\\n     * @return _totalElements Total submitted elements.\\n     */\\n    function getTotalElements()\\n        external\\n        view\\n        returns (\\n            uint256 _totalElements\\n        );\\n\\n    /**\\n     * Retrieves the total number of batches submitted.\\n     * @return _totalBatches Total submitted batches.\\n     */\\n    function getTotalBatches()\\n        external\\n        view\\n        returns (\\n            uint256 _totalBatches\\n        );\\n\\n    /**\\n     * Retrieves the timestamp of the last batch submitted by the sequencer.\\n     * @return _lastSequencerTimestamp Last sequencer batch timestamp.\\n     */\\n    function getLastSequencerTimestamp()\\n        external\\n        view\\n        returns (\\n            uint256 _lastSequencerTimestamp\\n        );\\n\\n    /**\\n     * Appends a batch of state roots to the chain.\\n     * @param _batch Batch of state roots.\\n     * @param _shouldStartAtElement Index of the element at which this batch should start.\\n     */\\n    function appendStateBatch(\\n        bytes32[] calldata _batch,\\n        uint256 _shouldStartAtElement\\n    )\\n        external;\\n\\n    /**\\n     * Deletes all state roots after (and including) a given batch.\\n     * @param _batchHeader Header of the batch to start deleting from.\\n     */\\n    function deleteStateBatch(\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\\n    )\\n        external;\\n\\n    /**\\n     * Verifies a batch inclusion proof.\\n     * @param _element Hash of the element to verify a proof for.\\n     * @param _batchHeader Header of the batch in which the element was included.\\n     * @param _proof Merkle inclusion proof for the element.\\n     */\\n    function verifyStateCommitment(\\n        bytes32 _element,\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\\n        Lib_OVMCodec.ChainInclusionProof memory _proof\\n    )\\n        external\\n        view\\n        returns (\\n            bool _verified\\n        );\\n\\n    /**\\n     * Checks whether a given batch is still inside its fraud proof window.\\n     * @param _batchHeader Header of the batch to check.\\n     * @return _inside Whether or not the batch is inside the fraud proof window.\\n     */\\n    function insideFraudProofWindow(\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\\n    )\\n        external\\n        view\\n        returns (\\n            bool _inside\\n        );\\n}\\n\",\"keccak256\":\"0x6646d6ff392b81aab52a7a277e91540819464751de0af5afd1962094b2e92448\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/verification/iOVM_BondManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\ninterface ERC20 {\\n    function transfer(address, uint256) external returns (bool);\\n    function transferFrom(address, address, uint256) external returns (bool);\\n}\\n\\n/// All the errors which may be encountered on the bond manager\\nlibrary Errors {\\n    string constant ERC20_ERR = \\\"BondManager: Could not post bond\\\";\\n    string constant ALREADY_FINALIZED = \\\"BondManager: Fraud proof for this pre-state root has already been finalized\\\";\\n    string constant SLASHED = \\\"BondManager: Cannot finalize withdrawal, you probably got slashed\\\";\\n    string constant WRONG_STATE = \\\"BondManager: Wrong bond state for proposer\\\";\\n    string constant CANNOT_CLAIM = \\\"BondManager: Cannot claim yet. Dispute must be finalized first\\\";\\n\\n    string constant WITHDRAWAL_PENDING = \\\"BondManager: Withdrawal already pending\\\";\\n    string constant TOO_EARLY = \\\"BondManager: Too early to finalize your withdrawal\\\";\\n\\n    string constant ONLY_TRANSITIONER = \\\"BondManager: Only the transitioner for this pre-state root may call this function\\\";\\n    string constant ONLY_FRAUD_VERIFIER = \\\"BondManager: Only the fraud verifier may call this function\\\";\\n    string constant ONLY_STATE_COMMITMENT_CHAIN = \\\"BondManager: Only the state commitment chain may call this function\\\";\\n    string constant WAIT_FOR_DISPUTES = \\\"BondManager: Wait for other potential disputes\\\";\\n}\\n\\n/**\\n * @title iOVM_BondManager\\n */\\ninterface iOVM_BondManager {\\n\\n    /*******************\\n     * Data Structures *\\n     *******************/\\n\\n    /// The lifecycle of a proposer's bond\\n    enum State {\\n        // Before depositing or after getting slashed, a user is uncollateralized\\n        NOT_COLLATERALIZED,\\n        // After depositing, a user is collateralized\\n        COLLATERALIZED,\\n        // After a user has initiated a withdrawal\\n        WITHDRAWING\\n    }\\n\\n    /// A bond posted by a proposer\\n    struct Bond {\\n        // The user's state\\n        State state;\\n        // The timestamp at which a proposer issued their withdrawal request\\n        uint32 withdrawalTimestamp;\\n        // The time when the first disputed was initiated for this bond\\n        uint256 firstDisputeAt;\\n        // The earliest observed state root for this bond which has had fraud\\n        bytes32 earliestDisputedStateRoot;\\n        // The state root's timestamp\\n        uint256 earliestTimestamp;\\n    }\\n\\n    // Per pre-state root, store the number of state provisions that were made\\n    // and how many of these calls were made by each user. Payouts will then be\\n    // claimed by users proportionally for that dispute.\\n    struct Rewards {\\n        // Flag to check if rewards for a fraud proof are claimable\\n        bool canClaim;\\n        // Total number of `recordGasSpent` calls made\\n        uint256 total;\\n        // The gas spent by each user to provide witness data. The sum of all\\n        // values inside this map MUST be equal to the value of `total`\\n        mapping(address => uint256) gasSpent;\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    function recordGasSpent(\\n        bytes32 _preStateRoot,\\n        bytes32 _txHash,\\n        address _who,\\n        uint256 _gasSpent\\n    ) external;\\n\\n    function finalize(\\n        bytes32 _preStateRoot,\\n        address _publisher,\\n        uint256 _timestamp\\n    ) external;\\n\\n    function deposit() external;\\n\\n    function startWithdrawal() external;\\n\\n    function finalizeWithdrawal() external;\\n\\n    function claim(\\n        address _who\\n    ) external;\\n\\n    function isCollateralized(\\n        address _who\\n    ) external view returns (bool);\\n\\n    function getGasSpent(\\n        bytes32 _preStateRoot,\\n        address _who\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x3c2a8a399487857158649db1896749d86e39cba545a8aeb2e2bb0f3bdfa7a5b1\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/verification/iOVM_FraudVerifier.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/* Interface Imports */\\nimport { iOVM_StateTransitioner } from \\\"./iOVM_StateTransitioner.sol\\\";\\n\\n/**\\n * @title iOVM_FraudVerifier\\n */\\ninterface iOVM_FraudVerifier {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event FraudProofInitialized(\\n        bytes32 _preStateRoot,\\n        uint256 _preStateRootIndex,\\n        bytes32 _transactionHash,\\n        address _who\\n    );\\n\\n    event FraudProofFinalized(\\n        bytes32 _preStateRoot,\\n        uint256 _preStateRootIndex,\\n        bytes32 _transactionHash,\\n        address _who\\n    );\\n\\n\\n    /***************************************\\n     * Public Functions: Transition Status *\\n     ***************************************/\\n\\n    function getStateTransitioner(bytes32 _preStateRoot, bytes32 _txHash) external view returns (iOVM_StateTransitioner _transitioner);\\n\\n\\n    /****************************************\\n     * Public Functions: Fraud Verification *\\n     ****************************************/\\n\\n    function initializeFraudVerification(\\n        bytes32 _preStateRoot,\\n        Lib_OVMCodec.ChainBatchHeader calldata _preStateRootBatchHeader,\\n        Lib_OVMCodec.ChainInclusionProof calldata _preStateRootProof,\\n        Lib_OVMCodec.Transaction calldata _transaction,\\n        Lib_OVMCodec.TransactionChainElement calldata _txChainElement,\\n        Lib_OVMCodec.ChainBatchHeader calldata _transactionBatchHeader,\\n        Lib_OVMCodec.ChainInclusionProof calldata _transactionProof\\n    ) external;\\n\\n    function finalizeFraudVerification(\\n        bytes32 _preStateRoot,\\n        Lib_OVMCodec.ChainBatchHeader calldata _preStateRootBatchHeader,\\n        Lib_OVMCodec.ChainInclusionProof calldata _preStateRootProof,\\n        bytes32 _txHash,\\n        bytes32 _postStateRoot,\\n        Lib_OVMCodec.ChainBatchHeader calldata _postStateRootBatchHeader,\\n        Lib_OVMCodec.ChainInclusionProof calldata _postStateRootProof\\n    ) external;\\n}\\n\",\"keccak256\":\"0x5efd7bb18164bbd3e9d58379e8203fbf2a7ee802b1a48dff3ceaaec1523b1751\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/iOVM/verification/iOVM_StateTransitioner.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_OVMCodec } from \\\"../../libraries/codec/Lib_OVMCodec.sol\\\";\\n\\n/**\\n * @title iOVM_StateTransitioner\\n */\\ninterface iOVM_StateTransitioner {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event AccountCommitted(\\n        address _address\\n    );\\n\\n    event ContractStorageCommitted(\\n        address _address,\\n        bytes32 _key\\n    );\\n\\n\\n    /**********************************\\n     * Public Functions: State Access *\\n     **********************************/\\n\\n    function getPreStateRoot() external view returns (bytes32 _preStateRoot);\\n    function getPostStateRoot() external view returns (bytes32 _postStateRoot);\\n    function isComplete() external view returns (bool _complete);\\n\\n\\n    /***********************************\\n     * Public Functions: Pre-Execution *\\n     ***********************************/\\n\\n    function proveContractState(\\n        address _ovmContractAddress,\\n        address _ethContractAddress,\\n        bytes calldata _stateTrieWitness\\n    ) external;\\n\\n    function proveStorageSlot(\\n        address _ovmContractAddress,\\n        bytes32 _key,\\n        bytes calldata _storageTrieWitness\\n    ) external;\\n\\n\\n    /*******************************\\n     * Public Functions: Execution *\\n     *******************************/\\n\\n    function applyTransaction(\\n        Lib_OVMCodec.Transaction calldata _transaction\\n    ) external;\\n\\n\\n    /************************************\\n     * Public Functions: Post-Execution *\\n     ************************************/\\n\\n    function commitContractState(\\n        address _ovmContractAddress,\\n        bytes calldata _stateTrieWitness\\n    ) external;\\n\\n    function commitStorageSlot(\\n        address _ovmContractAddress,\\n        bytes32 _key,\\n        bytes calldata _storageTrieWitness\\n    ) external;\\n\\n\\n    /**********************************\\n     * Public Functions: Finalization *\\n     **********************************/\\n\\n    function completeTransition() external;\\n}\\n\",\"keccak256\":\"0x3d044ac0a3bb6ad3d529f904b3191117511f9c379678ca03010e1ebdfcb5c34b\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/codec/Lib_OVMCodec.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_RLPReader } from \\\"../rlp/Lib_RLPReader.sol\\\";\\nimport { Lib_RLPWriter } from \\\"../rlp/Lib_RLPWriter.sol\\\";\\nimport { Lib_BytesUtils } from \\\"../utils/Lib_BytesUtils.sol\\\";\\nimport { Lib_Bytes32Utils } from \\\"../utils/Lib_Bytes32Utils.sol\\\";\\n\\n/**\\n * @title Lib_OVMCodec\\n */\\nlibrary Lib_OVMCodec {\\n\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum QueueOrigin {\\n        SEQUENCER_QUEUE,\\n        L1TOL2_QUEUE\\n    }\\n\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct Account {\\n        uint256 nonce;\\n        uint256 balance;\\n        bytes32 storageRoot;\\n        bytes32 codeHash;\\n        address ethAddress;\\n        bool isFresh;\\n    }\\n\\n    struct EVMAccount {\\n        uint256 nonce;\\n        uint256 balance;\\n        bytes32 storageRoot;\\n        bytes32 codeHash;\\n    }\\n\\n    struct ChainBatchHeader {\\n        uint256 batchIndex;\\n        bytes32 batchRoot;\\n        uint256 batchSize;\\n        uint256 prevTotalElements;\\n        bytes extraData;\\n    }\\n\\n    struct ChainInclusionProof {\\n        uint256 index;\\n        bytes32[] siblings;\\n    }\\n\\n    struct Transaction {\\n        uint256 timestamp;\\n        uint256 blockNumber;\\n        QueueOrigin l1QueueOrigin;\\n        address l1TxOrigin;\\n        address entrypoint;\\n        uint256 gasLimit;\\n        bytes data;\\n    }\\n\\n    struct TransactionChainElement {\\n        bool isSequenced;\\n        uint256 queueIndex;  // QUEUED TX ONLY\\n        uint256 timestamp;   // SEQUENCER TX ONLY\\n        uint256 blockNumber; // SEQUENCER TX ONLY\\n        bytes txData;        // SEQUENCER TX ONLY\\n    }\\n\\n    struct QueueElement {\\n        bytes32 transactionHash;\\n        uint40 timestamp;\\n        uint40 blockNumber;\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Encodes a standard OVM transaction.\\n     * @param _transaction OVM transaction to encode.\\n     * @return Encoded transaction bytes.\\n     */\\n    function encodeTransaction(\\n        Transaction memory _transaction\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return abi.encodePacked(\\n            _transaction.timestamp,\\n            _transaction.blockNumber,\\n            _transaction.l1QueueOrigin,\\n            _transaction.l1TxOrigin,\\n            _transaction.entrypoint,\\n            _transaction.gasLimit,\\n            _transaction.data\\n        );\\n    }\\n\\n    /**\\n     * Hashes a standard OVM transaction.\\n     * @param _transaction OVM transaction to encode.\\n     * @return Hashed transaction\\n     */\\n    function hashTransaction(\\n        Transaction memory _transaction\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return keccak256(encodeTransaction(_transaction));\\n    }\\n\\n    /**\\n     * Converts an OVM account to an EVM account.\\n     * @param _in OVM account to convert.\\n     * @return Converted EVM account.\\n     */\\n    function toEVMAccount(\\n        Account memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            EVMAccount memory\\n        )\\n    {\\n        return EVMAccount({\\n            nonce: _in.nonce,\\n            balance: _in.balance,\\n            storageRoot: _in.storageRoot,\\n            codeHash: _in.codeHash\\n        });\\n    }\\n\\n    /**\\n     * @notice RLP-encodes an account state struct.\\n     * @param _account Account state struct.\\n     * @return RLP-encoded account state.\\n     */\\n    function encodeEVMAccount(\\n        EVMAccount memory _account\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes[] memory raw = new bytes[](4);\\n\\n        // Unfortunately we can't create this array outright because\\n        // Lib_RLPWriter.writeList will reject fixed-size arrays. Assigning\\n        // index-by-index circumvents this issue.\\n        raw[0] = Lib_RLPWriter.writeBytes(\\n            Lib_Bytes32Utils.removeLeadingZeros(\\n                bytes32(_account.nonce)\\n            )\\n        );\\n        raw[1] = Lib_RLPWriter.writeBytes(\\n            Lib_Bytes32Utils.removeLeadingZeros(\\n                bytes32(_account.balance)\\n            )\\n        );\\n        raw[2] = Lib_RLPWriter.writeBytes(abi.encodePacked(_account.storageRoot));\\n        raw[3] = Lib_RLPWriter.writeBytes(abi.encodePacked(_account.codeHash));\\n\\n        return Lib_RLPWriter.writeList(raw);\\n    }\\n\\n    /**\\n     * @notice Decodes an RLP-encoded account state into a useful struct.\\n     * @param _encoded RLP-encoded account state.\\n     * @return Account state struct.\\n     */\\n    function decodeEVMAccount(\\n        bytes memory _encoded\\n    )\\n        internal\\n        pure\\n        returns (\\n            EVMAccount memory\\n        )\\n    {\\n        Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);\\n\\n        return EVMAccount({\\n            nonce: Lib_RLPReader.readUint256(accountState[0]),\\n            balance: Lib_RLPReader.readUint256(accountState[1]),\\n            storageRoot: Lib_RLPReader.readBytes32(accountState[2]),\\n            codeHash: Lib_RLPReader.readBytes32(accountState[3])\\n        });\\n    }\\n\\n    /**\\n     * Calculates a hash for a given batch header.\\n     * @param _batchHeader Header to hash.\\n     * @return Hash of the header.\\n     */\\n    function hashBatchHeader(\\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return keccak256(\\n            abi.encode(\\n                _batchHeader.batchRoot,\\n                _batchHeader.batchSize,\\n                _batchHeader.prevTotalElements,\\n                _batchHeader.extraData\\n            )\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xd85ba2066057a2677926f484b938c7c2ef33ff3853f3b71cda252f4a54f30e05\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/resolver/Lib_AddressManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* External Imports */\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Lib_AddressManager\\n */\\ncontract Lib_AddressManager is Ownable {\\n\\n    /**********\\n     * Events *\\n     **********/\\n\\n    event AddressSet(\\n        string indexed _name,\\n        address _newAddress,\\n        address _oldAddress\\n    );\\n\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    mapping (bytes32 => address) private addresses;\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Changes the address associated with a particular name.\\n     * @param _name String name to associate an address with.\\n     * @param _address Address to associate with the name.\\n     */\\n    function setAddress(\\n        string memory _name,\\n        address _address\\n    )\\n        external\\n        onlyOwner\\n    {\\n        bytes32 nameHash = _getNameHash(_name);\\n        address oldAddress = addresses[nameHash];\\n        addresses[nameHash] = _address;\\n\\n        emit AddressSet(\\n            _name,\\n            _address,\\n            oldAddress\\n        );\\n    }\\n\\n    /**\\n     * Retrieves the address associated with a given name.\\n     * @param _name Name to retrieve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function getAddress(\\n        string memory _name\\n    )\\n        external\\n        view\\n        returns (\\n            address\\n        )\\n    {\\n        return addresses[_getNameHash(_name)];\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Computes the hash of a name.\\n     * @param _name Name to compute a hash for.\\n     * @return Hash of the given name.\\n     */\\n    function _getNameHash(\\n        string memory _name\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return keccak256(abi.encodePacked(_name));\\n    }\\n}\\n\",\"keccak256\":\"0x636defb785a5c6650d101def6790d9104724cc7570e0d875138624d069eed257\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/resolver/Lib_AddressResolver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Library Imports */\\nimport { Lib_AddressManager } from \\\"./Lib_AddressManager.sol\\\";\\n\\n/**\\n * @title Lib_AddressResolver\\n */\\nabstract contract Lib_AddressResolver {\\n\\n    /*************\\n     * Variables *\\n     *************/\\n\\n    Lib_AddressManager public libAddressManager;\\n\\n\\n    /***************\\n     * Constructor *\\n     ***************/\\n\\n    /**\\n     * @param _libAddressManager Address of the Lib_AddressManager.\\n     */\\n    constructor(\\n        address _libAddressManager\\n    ) {\\n        libAddressManager = Lib_AddressManager(_libAddressManager);\\n    }\\n\\n\\n    /********************\\n     * Public Functions *\\n     ********************/\\n\\n    /**\\n     * Resolves the address associated with a given name.\\n     * @param _name Name to resolve an address for.\\n     * @return Address associated with the given name.\\n     */\\n    function resolve(\\n        string memory _name\\n    )\\n        public\\n        view\\n        returns (\\n            address\\n        )\\n    {\\n        return libAddressManager.getAddress(_name);\\n    }\\n}\\n\",\"keccak256\":\"0x65981feeabff6a81783ea97d44baf988a18a86c8cb374c46fdb71819cbacc7c0\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/rlp/Lib_RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Lib_RLPReader\\n * @dev Adapted from \\\"RLPReader\\\" by Hamdi Allam (hamdi.allam97@gmail.com).\\n */\\nlibrary Lib_RLPReader {\\n\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    uint256 constant internal MAX_LIST_LENGTH = 32;\\n\\n\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum RLPItemType {\\n        DATA_ITEM,\\n        LIST_ITEM\\n    }\\n\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct RLPItem {\\n        uint256 length;\\n        uint256 ptr;\\n    }\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Converts bytes to a reference to memory position and length.\\n     * @param _in Input bytes to convert.\\n     * @return Output memory reference.\\n     */\\n    function toRLPItem(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem memory\\n        )\\n    {\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(_in, 32)\\n        }\\n\\n        return RLPItem({\\n            length: _in.length,\\n            ptr: ptr\\n        });\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem[] memory\\n        )\\n    {\\n        (\\n            uint256 listOffset,\\n            ,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.LIST_ITEM,\\n            \\\"Invalid RLP list value.\\\"\\n        );\\n\\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\\n        // writing to the length. Since we can't know the number of RLP items without looping over\\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\\n        // simply set a reasonable maximum list length and decrease the size before we finish.\\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\\n\\n        uint256 itemCount = 0;\\n        uint256 offset = listOffset;\\n        while (offset < _in.length) {\\n            require(\\n                itemCount < MAX_LIST_LENGTH,\\n                \\\"Provided RLP list exceeds max list length.\\\"\\n            );\\n\\n            (\\n                uint256 itemOffset,\\n                uint256 itemLength,\\n            ) = _decodeLength(RLPItem({\\n                length: _in.length - offset,\\n                ptr: _in.ptr + offset\\n            }));\\n\\n            out[itemCount] = RLPItem({\\n                length: itemLength + itemOffset,\\n                ptr: _in.ptr + offset\\n            });\\n\\n            itemCount += 1;\\n            offset += itemOffset + itemLength;\\n        }\\n\\n        // Decrease the array size to match the actual item count.\\n        assembly {\\n            mstore(out, itemCount)\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem[] memory\\n        )\\n    {\\n        return readList(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        (\\n            uint256 itemOffset,\\n            uint256 itemLength,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.DATA_ITEM,\\n            \\\"Invalid RLP bytes value.\\\"\\n        );\\n\\n        return _copy(_in.ptr, itemOffset, itemLength);\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return readBytes(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            string memory\\n        )\\n    {\\n        return string(readBytes(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            string memory\\n        )\\n    {\\n        return readString(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        require(\\n            _in.length <= 33,\\n            \\\"Invalid RLP bytes32 value.\\\"\\n        );\\n\\n        (\\n            uint256 itemOffset,\\n            uint256 itemLength,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.DATA_ITEM,\\n            \\\"Invalid RLP bytes32 value.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr + itemOffset;\\n        bytes32 out;\\n        assembly {\\n            out := mload(ptr)\\n\\n            // Shift the bytes over to match the item size.\\n            if lt(itemLength, 32) {\\n                out := div(out, exp(256, sub(32, itemLength)))\\n            }\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return readBytes32(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256\\n        )\\n    {\\n        return uint256(readBytes32(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256\\n        )\\n    {\\n        return readUint256(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        require(\\n            _in.length == 1,\\n            \\\"Invalid RLP boolean value.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 out;\\n        assembly {\\n            out := byte(0, mload(ptr))\\n        }\\n\\n        require(\\n            out == 0 || out == 1,\\n            \\\"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\\\"\\n        );\\n\\n        return out != 0;\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        return readBool(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        if (_in.length == 1) {\\n            return address(0);\\n        }\\n\\n        require(\\n            _in.length == 21,\\n            \\\"Invalid RLP address value.\\\"\\n        );\\n\\n        return address(readUint256(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        return readAddress(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads the raw bytes of an RLP item.\\n     * @param _in RLP item to read.\\n     * @return Raw RLP bytes.\\n     */\\n    function readRawBytes(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return _copy(_in);\\n    }\\n\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Decodes the length of an RLP item.\\n     * @param _in RLP item to decode.\\n     * @return Offset of the encoded data.\\n     * @return Length of the encoded data.\\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\\n     */\\n    function _decodeLength(\\n        RLPItem memory _in\\n    )\\n        private\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            RLPItemType\\n        )\\n    {\\n        require(\\n            _in.length > 0,\\n            \\\"RLP item cannot be null.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 prefix;\\n        assembly {\\n            prefix := byte(0, mload(ptr))\\n        }\\n\\n        if (prefix <= 0x7f) {\\n            // Single byte.\\n\\n            return (0, 1, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xb7) {\\n            // Short string.\\n\\n            uint256 strLen = prefix - 0x80;\\n\\n            require(\\n                _in.length > strLen,\\n                \\\"Invalid RLP short string.\\\"\\n            );\\n\\n            return (1, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xbf) {\\n            // Long string.\\n            uint256 lenOfStrLen = prefix - 0xb7;\\n\\n            require(\\n                _in.length > lenOfStrLen,\\n                \\\"Invalid RLP long string length.\\\"\\n            );\\n\\n            uint256 strLen;\\n            assembly {\\n                // Pick out the string length.\\n                strLen := div(\\n                    mload(add(ptr, 1)),\\n                    exp(256, sub(32, lenOfStrLen))\\n                )\\n            }\\n\\n            require(\\n                _in.length > lenOfStrLen + strLen,\\n                \\\"Invalid RLP long string.\\\"\\n            );\\n\\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xf7) {\\n            // Short list.\\n            uint256 listLen = prefix - 0xc0;\\n\\n            require(\\n                _in.length > listLen,\\n                \\\"Invalid RLP short list.\\\"\\n            );\\n\\n            return (1, listLen, RLPItemType.LIST_ITEM);\\n        } else {\\n            // Long list.\\n            uint256 lenOfListLen = prefix - 0xf7;\\n\\n            require(\\n                _in.length > lenOfListLen,\\n                \\\"Invalid RLP long list length.\\\"\\n            );\\n\\n            uint256 listLen;\\n            assembly {\\n                // Pick out the list length.\\n                listLen := div(\\n                    mload(add(ptr, 1)),\\n                    exp(256, sub(32, lenOfListLen))\\n                )\\n            }\\n\\n            require(\\n                _in.length > lenOfListLen + listLen,\\n                \\\"Invalid RLP long list.\\\"\\n            );\\n\\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\\n        }\\n    }\\n\\n    /**\\n     * Copies the bytes from a memory location.\\n     * @param _src Pointer to the location to read from.\\n     * @param _offset Offset to start reading from.\\n     * @param _length Number of bytes to read.\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        uint256 _src,\\n        uint256 _offset,\\n        uint256 _length\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory out = new bytes(_length);\\n        if (out.length == 0) {\\n            return out;\\n        }\\n\\n        uint256 src = _src + _offset;\\n        uint256 dest;\\n        assembly {\\n            dest := add(out, 32)\\n        }\\n\\n        // Copy over as many complete words as we can.\\n        for (uint256 i = 0; i < _length / 32; i++) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += 32;\\n            dest += 32;\\n        }\\n\\n        // Pick out the remaining bytes.\\n        uint256 mask = 256 ** (32 - (_length % 32)) - 1;\\n        assembly {\\n            mstore(\\n                dest,\\n                or(\\n                    and(mload(src), not(mask)),\\n                    and(mload(dest), mask)\\n                )\\n            )\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Copies an RLP item into bytes.\\n     * @param _in RLP item to copy.\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        RLPItem memory _in\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return _copy(_in.ptr, 0, _in.length);\\n    }\\n}\\n\",\"keccak256\":\"0x829174c61216dce35fdb888383b6022e0365eb7fbdc71ad79d98b108091969fe\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/rlp/Lib_RLPWriter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title Lib_RLPWriter\\n * @author Bakaoh (with modifications)\\n */\\nlibrary Lib_RLPWriter {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * RLP encodes a byte string.\\n     * @param _in The byte string to encode.\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeBytes(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory encoded;\\n\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            encoded = _in;\\n        } else {\\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * RLP encodes a list of RLP encoded byte byte strings.\\n     * @param _in The list of RLP encoded byte strings.\\n     * @return The RLP encoded list of items in bytes.\\n     */\\n    function writeList(\\n        bytes[] memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory list = _flatten(_in);\\n        return abi.encodePacked(_writeLength(list.length, 192), list);\\n    }\\n\\n    /**\\n     * RLP encodes a string.\\n     * @param _in The string to encode.\\n     * @return The RLP encoded string in bytes.\\n     */\\n    function writeString(\\n        string memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return writeBytes(bytes(_in));\\n    }\\n\\n    /**\\n     * RLP encodes an address.\\n     * @param _in The address to encode.\\n     * @return The RLP encoded address in bytes.\\n     */\\n    function writeAddress(\\n        address _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a bytes32 value.\\n     * @param _in The bytes32 to encode.\\n     * @return _out The RLP encoded bytes32 in bytes.\\n     */\\n    function writeBytes32(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a uint.\\n     * @param _in The uint256 to encode.\\n     * @return The RLP encoded uint256 in bytes.\\n     */\\n    function writeUint(\\n        uint256 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return writeBytes(_toBinary(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a bool.\\n     * @param _in The bool to encode.\\n     * @return The RLP encoded bool in bytes.\\n     */\\n    function writeBool(\\n        bool _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory encoded = new bytes(1);\\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n        return encoded;\\n    }\\n\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\\n     * @param _len The length of the string or the payload.\\n     * @param _offset 128 if item is string, 192 if item is list.\\n     * @return RLP encoded bytes.\\n     */\\n    function _writeLength(\\n        uint256 _len,\\n        uint256 _offset\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory encoded;\\n\\n        if (_len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = byte(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = byte(uint8(lenLen) + uint8(_offset) + 55);\\n            for(i = 1; i <= lenLen; i++) {\\n                encoded[i] = byte(uint8((_len / (256**(lenLen-i))) % 256));\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * Encode integer in big endian binary form with no leading zeroes.\\n     * @notice TODO: This should be optimized with assembly to save gas costs.\\n     * @param _x The integer to encode.\\n     * @return RLP encoded bytes.\\n     */\\n    function _toBinary(\\n        uint256 _x\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        bytes memory res = new bytes(32 - i);\\n        for (uint256 j = 0; j < res.length; j++) {\\n            res[j] = b[i++];\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * Copies a piece of memory to another location.\\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\\n     * @param _dest Destination location.\\n     * @param _src Source location.\\n     * @param _len Length of memory to copy.\\n     */\\n    function _memcpy(\\n        uint256 _dest,\\n        uint256 _src,\\n        uint256 _len\\n    )\\n        private\\n        pure\\n    {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for(; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask = 256 ** (32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * Flattens a list of byte strings into one byte string.\\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\\n     * @param _list List of byte strings to flatten.\\n     * @return The flattened byte string.\\n     */\\n    function _flatten(\\n        bytes[] memory _list\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly { flattenedPtr := add(flattened, 0x20) }\\n\\n        for(i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly { listPtr := add(item, 0x20)}\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n\\n        return flattened;\\n    }\\n}\\n\",\"keccak256\":\"0xb60ee4b03ad372c3deff21d454ab714dd0c18ee3e6f9d45532e209fc59d5a54d\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/utils/Lib_Bytes32Utils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Lib_Byte32Utils\\n */\\nlibrary Lib_Bytes32Utils {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Converts a bytes32 value to a boolean. Anything non-zero will be converted to \\\"true.\\\"\\n     * @param _in Input bytes32 value.\\n     * @return Bytes32 as a boolean.\\n     */\\n    function toBool(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        return _in != 0;\\n    }\\n\\n    /**\\n     * Converts a boolean to a bytes32 value.\\n     * @param _in Input boolean value.\\n     * @return Boolean as a bytes32.\\n     */\\n    function fromBool(\\n        bool _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return bytes32(uint256(_in ? 1 : 0));\\n    }\\n\\n    /**\\n     * Converts a bytes32 value to an address. Takes the *last* 20 bytes.\\n     * @param _in Input bytes32 value.\\n     * @return Bytes32 as an address.\\n     */\\n    function toAddress(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        return address(uint160(uint256(_in)));\\n    }\\n\\n    /**\\n     * Converts an address to a bytes32.\\n     * @param _in Input address value.\\n     * @return Address as a bytes32.\\n     */\\n    function fromAddress(\\n        address _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return bytes32(uint256(_in));\\n    }\\n\\n    /**\\n     * Removes the leading zeros from a bytes32 value and returns a new (smaller) bytes value.\\n     * @param _in Input bytes32 value.\\n     * @return Bytes32 without any leading zeros.\\n     */\\n    function removeLeadingZeros(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory out;\\n\\n        assembly {\\n            // Figure out how many leading zero bytes to remove.\\n            let shift := 0\\n            for { let i := 0 } and(lt(i, 32), eq(byte(i, _in), 0)) { i := add(i, 1) } {\\n                shift := add(shift, 1)\\n            }\\n\\n            // Reserve some space for our output and fix the free memory pointer.\\n            out := mload(0x40)\\n            mstore(0x40, add(out, 0x40))\\n\\n            // Shift the value and store it into the output bytes.\\n            mstore(add(out, 0x20), shl(mul(shift, 8), _in))\\n\\n            // Store the new size (with leading zero bytes removed) in the output byte size.\\n            mstore(out, sub(32, shift))\\n        }\\n\\n        return out;\\n    }\\n}\\n\",\"keccak256\":\"0xfa2def593e3fc56a31852c3744aefdaa93cec74e721bfcfeb1e5d166c7c60b64\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/utils/Lib_BytesUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Lib_BytesUtils\\n */\\nlibrary Lib_BytesUtils {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_start + _length >= _start, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        if (_start >= _bytes.length) {\\n            return bytes('');\\n        }\\n\\n        return slice(_bytes, _start, _bytes.length - _start);\\n    }\\n\\n    function toBytes32PadLeft(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        bytes32 ret;\\n        uint256 len = _bytes.length <= 32 ? _bytes.length : 32;\\n        assembly {\\n            ret := shr(mul(sub(32, len), 8), mload(add(_bytes, 32)))\\n        }\\n        return ret;\\n    }\\n\\n    function toBytes32(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        if (_bytes.length < 32) {\\n            bytes32 ret;\\n            assembly {\\n                ret := mload(add(_bytes, 32))\\n            }\\n            return ret;\\n        }\\n\\n        return abi.decode(_bytes,(bytes32)); // will truncate if input length > 32 bytes\\n    }\\n\\n    function toUint256(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256\\n        )\\n    {\\n        return uint256(toBytes32(_bytes));\\n    }\\n\\n    function toUint24(\\n        bytes memory _bytes,\\n        uint256 _start\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint24\\n        )\\n    {\\n        require(_start + 3 >= _start, \\\"toUint24_overflow\\\");\\n        require(_bytes.length >= _start + 3 , \\\"toUint24_outOfBounds\\\");\\n        uint24 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint8(\\n        bytes memory _bytes,\\n        uint256 _start\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint8\\n        )\\n    {\\n        require(_start + 1 >= _start, \\\"toUint8_overflow\\\");\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toAddress(\\n        bytes memory _bytes,\\n        uint256 _start\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        require(_start + 20 >= _start, \\\"toAddress_overflow\\\");\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toNibbles(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory nibbles = new bytes(_bytes.length * 2);\\n\\n        for (uint256 i = 0; i < _bytes.length; i++) {\\n            nibbles[i * 2] = _bytes[i] >> 4;\\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\\n        }\\n\\n        return nibbles;\\n    }\\n\\n    function fromNibbles(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory ret = new bytes(_bytes.length / 2);\\n\\n        for (uint256 i = 0; i < ret.length; i++) {\\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\\n        }\\n\\n        return ret;\\n    }\\n\\n    function equal(\\n        bytes memory _bytes,\\n        bytes memory _other\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        return keccak256(_bytes) == keccak256(_other);\\n    }\\n}\\n\",\"keccak256\":\"0xd27e37973f1e0f64798725b7a0de12989dac992fba0d72970249d7e1f70e17c5\",\"license\":\"MIT\"},\"contracts/optimistic-ethereum/libraries/utils/Lib_MerkleTree.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Lib_MerkleTree\\n * @author River Keefer\\n */\\nlibrary Lib_MerkleTree {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Calculates a merkle root for a list of 32-byte leaf hashes.  WARNING: If the number\\n     * of leaves passed in is not a power of two, it pads out the tree with zero hashes.\\n     * If you do not know the original length of elements for the tree you are verifying,\\n     * then this may allow empty leaves past _elements.length to pass a verification check down the line.\\n     * Note that the _elements argument is modified, therefore it must not be used again afterwards\\n     * @param _elements Array of hashes from which to generate a merkle root.\\n     * @return Merkle root of the leaves, with zero hashes for non-powers-of-two (see above).\\n     */\\n    function getMerkleRoot(\\n        bytes32[] memory _elements\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        require(\\n            _elements.length > 0,\\n            \\\"Lib_MerkleTree: Must provide at least one leaf hash.\\\"\\n        );\\n\\n        if (_elements.length == 1) {\\n            return _elements[0];\\n        }\\n\\n        uint256[16] memory defaults = [\\n            0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563,\\n            0x633dc4d7da7256660a892f8f1604a44b5432649cc8ec5cb3ced4c4e6ac94dd1d,\\n            0x890740a8eb06ce9be422cb8da5cdafc2b58c0a5e24036c578de2a433c828ff7d,\\n            0x3b8ec09e026fdc305365dfc94e189a81b38c7597b3d941c279f042e8206e0bd8,\\n            0xecd50eee38e386bd62be9bedb990706951b65fe053bd9d8a521af753d139e2da,\\n            0xdefff6d330bb5403f63b14f33b578274160de3a50df4efecf0e0db73bcdd3da5,\\n            0x617bdd11f7c0a11f49db22f629387a12da7596f9d1704d7465177c63d88ec7d7,\\n            0x292c23a9aa1d8bea7e2435e555a4a60e379a5a35f3f452bae60121073fb6eead,\\n            0xe1cea92ed99acdcb045a6726b2f87107e8a61620a232cf4d7d5b5766b3952e10,\\n            0x7ad66c0a68c72cb89e4fb4303841966e4062a76ab97451e3b9fb526a5ceb7f82,\\n            0xe026cc5a4aed3c22a58cbd3d2ac754c9352c5436f638042dca99034e83636516,\\n            0x3d04cffd8b46a874edf5cfae63077de85f849a660426697b06a829c70dd1409c,\\n            0xad676aa337a485e4728a0b240d92b3ef7b3c372d06d189322bfd5f61f1e7203e,\\n            0xa2fca4a49658f9fab7aa63289c91b7c7b6c832a6d0e69334ff5b0a3483d09dab,\\n            0x4ebfd9cd7bca2505f7bef59cc1c12ecc708fff26ae4af19abe852afe9e20c862,\\n            0x2def10d13dd169f550f578bda343d9717a138562e0093b380a1120789d53cf10\\n        ];\\n\\n        // Reserve memory space for our hashes.\\n        bytes memory buf = new bytes(64);\\n\\n        // We'll need to keep track of left and right siblings.\\n        bytes32 leftSibling;\\n        bytes32 rightSibling;\\n\\n        // Number of non-empty nodes at the current depth.\\n        uint256 rowSize = _elements.length;\\n\\n        // Current depth, counting from 0 at the leaves\\n        uint256 depth = 0;\\n\\n        // Common sub-expressions\\n        uint256 halfRowSize;         // rowSize / 2\\n        bool rowSizeIsOdd;           // rowSize % 2 == 1\\n\\n        while (rowSize > 1) {\\n            halfRowSize = rowSize / 2;\\n            rowSizeIsOdd = rowSize % 2 == 1;\\n\\n            for (uint256 i = 0; i < halfRowSize; i++) {\\n                leftSibling  = _elements[(2 * i)    ];\\n                rightSibling = _elements[(2 * i) + 1];\\n                assembly {\\n                    mstore(add(buf, 32), leftSibling )\\n                    mstore(add(buf, 64), rightSibling)\\n                }\\n\\n                _elements[i] = keccak256(buf);\\n            }\\n\\n            if (rowSizeIsOdd) {\\n                leftSibling  = _elements[rowSize - 1];\\n                rightSibling = bytes32(defaults[depth]);\\n                assembly {\\n                    mstore(add(buf, 32), leftSibling)\\n                    mstore(add(buf, 64), rightSibling)\\n                }\\n\\n                _elements[halfRowSize] = keccak256(buf);\\n            }\\n\\n            rowSize = halfRowSize + (rowSizeIsOdd ? 1 : 0);\\n            depth++;\\n        }\\n\\n        return _elements[0];\\n    }\\n\\n    /**\\n     * Verifies a merkle branch for the given leaf hash.  Assumes the original length\\n     * of leaves generated is a known, correct input, and does not return true for indices\\n     * extending past that index (even if _siblings would be otherwise valid.)\\n     * @param _root The Merkle root to verify against.\\n     * @param _leaf The leaf hash to verify inclusion of.\\n     * @param _index The index in the tree of this leaf.\\n     * @param _siblings Array of sibline nodes in the inclusion proof, starting from depth 0 (bottom of the tree).\\n     * @param _totalLeaves The total number of leaves originally passed into.\\n     * @return Whether or not the merkle branch and leaf passes verification.\\n     */\\n    function verify(\\n        bytes32 _root,\\n        bytes32 _leaf,\\n        uint256 _index,\\n        bytes32[] memory _siblings,\\n        uint256 _totalLeaves\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        require(\\n            _totalLeaves > 0,\\n            \\\"Lib_MerkleTree: Total leaves must be greater than zero.\\\"\\n        );\\n\\n        require(\\n            _index < _totalLeaves,\\n            \\\"Lib_MerkleTree: Index out of bounds.\\\"\\n        );\\n\\n        require(\\n            _siblings.length == _ceilLog2(_totalLeaves),\\n            \\\"Lib_MerkleTree: Total siblings does not correctly correspond to total leaves.\\\"\\n        );\\n\\n        bytes32 computedRoot = _leaf;\\n\\n        for (uint256 i = 0; i < _siblings.length; i++) {\\n            if ((_index & 1) == 1) {\\n                computedRoot = keccak256(\\n                    abi.encodePacked(\\n                        _siblings[i],\\n                        computedRoot\\n                    )\\n                );\\n            } else {\\n                computedRoot = keccak256(\\n                    abi.encodePacked(\\n                        computedRoot,\\n                        _siblings[i]\\n                    )\\n                );\\n            }\\n\\n            _index >>= 1;\\n        }\\n\\n        return _root == computedRoot;\\n    }\\n\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Calculates the integer ceiling of the log base 2 of an input.\\n     * @param _in Unsigned input to calculate the log.\\n     * @return ceil(log_base_2(_in))\\n     */\\n    function _ceilLog2(\\n        uint256 _in\\n    )\\n        private\\n        pure\\n        returns (\\n            uint256\\n        )\\n    {\\n        require(\\n            _in > 0,\\n            \\\"Lib_MerkleTree: Cannot compute ceil(log_2) of 0.\\\"\\n        );\\n\\n        if (_in == 1) {\\n            return 0;\\n        }\\n\\n        // Find the highest set bit (will be floor(log_2)).\\n        // Borrowed with <3 from https://github.com/ethereum/solidity-examples\\n        uint256 val = _in;\\n        uint256 highest = 0;\\n        for (uint256 i = 128; i >= 1; i >>= 1) {\\n            if (val & (uint(1) << i) - 1 << i != 0) {\\n                highest += i;\\n                val >>= i;\\n            }\\n        }\\n\\n        // Increment by one if this is not a perfect logarithm.\\n        if ((uint(1) << highest) != _in) {\\n            highest += 1;\\n        }\\n\\n        return highest;\\n    }\\n}\\n\",\"keccak256\":\"0xa78edb9fbd34712771a1ebff05bc5e1abec7fc1e9a1bfb709d183099b44fa62a\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50604051611bee380380611bee83398101604081905261002f9161005b565b600080546001600160a01b0319166001600160a01b03949094169390931790925560015560025561009c565b60008060006060848603121561006f578283fd5b83516001600160a01b0381168114610085578384fd5b602085015160409095015190969495509392505050565b611b43806100ab6000396000f3fe608060405234801561001057600080fd5b50600436106100b45760003560e01c80638ca5cbb9116100715780638ca5cbb91461012f5780639418bddd14610144578063b8e189ac14610157578063c17b291b1461016a578063cfdf677e14610172578063e561dddc1461017a576100b4565b8063299ca478146100b9578063461a4478146100d75780634d69ee57146100ea5780637aa63a861461010a5780637ad168a01461011f57806381eb62ef14610127575b600080fd5b6100c1610182565b6040516100ce919061159f565b60405180910390f35b6100c16100e53660046114e3565b610191565b6100fd6100f8366004611431565b61026f565b6040516100ce91906115b3565b6101126102e2565b6040516100ce91906115be565b6101126102fb565b610112610314565b61014261013d366004611390565b61031a565b005b6100fd610152366004611531565b61052e565b610142610165366004611531565b61057e565b610112610636565b6100c161063c565b610112610664565b6000546001600160a01b031681565b6000805460405163bf40fac160e01b81526020600482018181528551602484015285516001600160a01b039094169363bf40fac19387938392604490920191908501908083838b5b838110156101f15781810151838201526020016101d9565b50505050905090810190601f16801561021e5780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b15801561023b57600080fd5b505afa15801561024f573d6000803e3d6000fd5b505050506040513d602081101561026557600080fd5b505190505b919050565b600061027a836106de565b61029f5760405162461bcd60e51b815260040161029690611749565b60405180910390fd5b6102bc836020015185846000015185602001518760400151610776565b6102d85760405162461bcd60e51b8152600401610296906116b5565b5060019392505050565b6000806102ed6108fb565b5064ffffffffff1691505090565b6000806103066108fb565b64ffffffffff169250505090565b60025481565b6103226102e2565b81146103405760405162461bcd60e51b8152600401610296906116ec565b6103706040518060400160405280600f81526020016e27ab26afa137b73226b0b730b3b2b960891b815250610191565b6001600160a01b03166302ad4d2a336040518263ffffffff1660e01b815260040161039b919061159f565b60206040518083038186803b1580156103b357600080fd5b505afa1580156103c7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103eb91906113d3565b6104075760405162461bcd60e51b8152600401610296906118bb565b60008251116104285760405162461bcd60e51b815260040161029690611878565b6104666040518060400160405280601d81526020017f4f564d5f43616e6f6e6963616c5472616e73616374696f6e436861696e000000815250610191565b6001600160a01b0316637aa63a866040518163ffffffff1660e01b815260040160206040518083038186803b15801561049e57600080fd5b505afa1580156104b2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104d69190611419565b82516104e06102e2565b0111156104ff5760405162461bcd60e51b815260040161029690611646565b61052a8242336040516020016105169291906119a1565b604051602081830303815290604052610990565b5050565b60008082608001518060200190518101906105499190611564565b509050806105695760405162461bcd60e51b815260040161029690611833565b4261057682600154610b31565b119392505050565b6105b06040518060400160405280601181526020017027ab26afa33930bab22b32b934b334b2b960791b815250610191565b6001600160a01b0316336001600160a01b0316146105e05760405162461bcd60e51b8152600401610296906117d6565b6105e9816106de565b6106055760405162461bcd60e51b815260040161029690611749565b61060e8161052e565b61062a5760405162461bcd60e51b815260040161029690611778565b61063381610b92565b50565b60015481565b600061065f604051806060016040528060258152602001611a6860259139610191565b905090565b600061066e61063c565b6001600160a01b0316631f7b6d326040518163ffffffff1660e01b815260040160206040518083038186803b1580156106a657600080fd5b505afa1580156106ba573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061065f9190611419565b60006106e861063c565b8251604051634a83e9cd60e11b81526001600160a01b039290921691639507d39a91610716916004016115be565b60206040518083038186803b15801561072e57600080fd5b505afa158015610742573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107669190611419565b61076f83610d0a565b1492915050565b60008082116107b65760405162461bcd60e51b8152600401808060200182810382526037815260200180611a316037913960400191505060405180910390fd5b8184106107f45760405162461bcd60e51b81526004018080602001828103825260248152602001806119dd6024913960400191505060405180910390fd5b6107fd82610d50565b83511461083b5760405162461bcd60e51b815260040180806020018281038252604d815260200180611a8d604d913960600191505060405180910390fd5b8460005b84518110156108ee57856001166001141561089d5784818151811061086057fe5b60200260200101518260405160200180838152602001828152602001925050506040516020818303038152906040528051906020012091506108e2565b818582815181106108aa57fe5b602002602001015160405160200180838152602001828152602001925050506040516020818303038152906040528051906020012091505b600195861c950161083f565b5090951495945050505050565b600080600061090861063c565b6001600160a01b031663ccf8f9696040518163ffffffff1660e01b815260040160206040518083038186803b15801561094057600080fd5b505afa158015610954573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061097891906113f3565b64ffffffffff602882901c16935060501c9150509091565b60006109bf6040518060400160405280600c81526020016b27ab26afa83937b837b9b2b960a11b815250610191565b90506000806109cc6108fb565b9092509050336001600160a01b03841614156109e9575042610a13565b426002548264ffffffffff160110610a135760405162461bcd60e51b81526004016102969061190a565b60006040518060a00160405280610a28610664565b8152602001610a3688610de6565b8152602001875181526020018464ffffffffff16815260200186815250905080600001517f16be4c5129a4e03cf3350262e181dc02ddfb4a6008d925368c0899fcd97ca9c58260200151836040015184606001518560800151604051610a9f94939291906115dd565b60405180910390a2610aaf61063c565b6001600160a01b0316632015276c610ac683610d0a565b610ada84604001518560600151018661121a565b6040518363ffffffff1660e01b8152600401610af79291906115c7565b600060405180830381600087803b158015610b1157600080fd5b505af1158015610b25573d6000803e3d6000fd5b50505050505050505050565b600082820183811015610b8b576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b9392505050565b610b9a61063c565b6001600160a01b0316631f7b6d326040518163ffffffff1660e01b815260040160206040518083038186803b158015610bd257600080fd5b505afa158015610be6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c0a9190611419565b815110610c295760405162461bcd60e51b815260040161029690611973565b610c32816106de565b610c4e5760405162461bcd60e51b815260040161029690611749565b610c5661063c565b6001600160a01b031663167fd6818260000151610c788460600151600061121a565b6040518363ffffffff1660e01b8152600401610c959291906115c7565b600060405180830381600087803b158015610caf57600080fd5b505af1158015610cc3573d6000803e3d6000fd5b5050505080600001517f8747b69ce8fdb31c3b9b0a67bd8049ad8c1a69ea417b69b12174068abd9cbd648260200151604051610cff91906115be565b60405180910390a250565b60008160200151826040015183606001518460800151604051602001610d3394939291906115dd565b604051602081830303815290604052805190602001209050919050565b6000808211610d905760405162461bcd60e51b8152600401808060200182810382526030815260200180611a016030913960400191505060405180910390fd5b8160011415610da15750600061026a565b81600060805b60018110610dd1576000196001821b01811b831615610dc95791821c91908101905b60011c610da7565b506001811b8414610b8b576001019392505050565b600080825111610e275760405162461bcd60e51b8152600401808060200182810382526034815260200180611ada6034913960400191505060405180910390fd5b815160011415610e4d5781600081518110610e3e57fe5b6020026020010151905061026a565b60408051610200810182527f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e56381527f633dc4d7da7256660a892f8f1604a44b5432649cc8ec5cb3ced4c4e6ac94dd1d60208201527f890740a8eb06ce9be422cb8da5cdafc2b58c0a5e24036c578de2a433c828ff7d818301527f3b8ec09e026fdc305365dfc94e189a81b38c7597b3d941c279f042e8206e0bd86060808301919091527fecd50eee38e386bd62be9bedb990706951b65fe053bd9d8a521af753d139e2da60808301527fdefff6d330bb5403f63b14f33b578274160de3a50df4efecf0e0db73bcdd3da560a08301527f617bdd11f7c0a11f49db22f629387a12da7596f9d1704d7465177c63d88ec7d760c08301527f292c23a9aa1d8bea7e2435e555a4a60e379a5a35f3f452bae60121073fb6eead60e08301527fe1cea92ed99acdcb045a6726b2f87107e8a61620a232cf4d7d5b5766b3952e106101008301527f7ad66c0a68c72cb89e4fb4303841966e4062a76ab97451e3b9fb526a5ceb7f826101208301527fe026cc5a4aed3c22a58cbd3d2ac754c9352c5436f638042dca99034e836365166101408301527f3d04cffd8b46a874edf5cfae63077de85f849a660426697b06a829c70dd1409c6101608301527fad676aa337a485e4728a0b240d92b3ef7b3c372d06d189322bfd5f61f1e7203e6101808301527fa2fca4a49658f9fab7aa63289c91b7c7b6c832a6d0e69334ff5b0a3483d09dab6101a08301527f4ebfd9cd7bca2505f7bef59cc1c12ecc708fff26ae4af19abe852afe9e20c8626101c08301527f2def10d13dd169f550f578bda343d9717a138562e0093b380a1120789d53cf106101e083015282518381529081018352909160009190602082018180368337505085519192506000918291508180805b60018411156111f65750506002820460018084161460005b82811015611172578a816002028151811061111957fe5b602002602001015196508a816002026001018151811061113557fe5b6020026020010151955086602089015285604089015287805190602001208b828151811061115f57fe5b6020908102919091010152600101611102565b5080156111d55789600185038151811061118857fe5b6020026020010151955087836010811061119e57fe5b602002015160001b945085602088015284604088015286805190602001208a83815181106111c857fe5b6020026020010181815250505b806111e15760006111e4565b60015b60ff16820193506001909201916110ea565b8960008151811061120357fe5b602002602001015198505050505050505050919050565b602890811b91909117901b90565b600067ffffffffffffffff83111561123c57fe5b61124f601f8401601f19166020016119b8565b905082815283838301111561126357600080fd5b828260208301376000602084830101529392505050565b600082601f83011261128a578081fd5b8135602067ffffffffffffffff8211156112a057fe5b8082026112ae8282016119b8565b8381528281019086840183880185018910156112c8578687fd5b8693505b858410156112ea5780358352600193909301929184019184016112cc565b50979650505050505050565b600060a08284031215611307578081fd5b60405160a0810167ffffffffffffffff828210818311171561132557fe5b8160405282935084358352602085013560208401526040850135604084015260608501356060840152608085013591508082111561136257600080fd5b508301601f8101851361137457600080fd5b61138385823560208401611228565b6080830152505092915050565b600080604083850312156113a2578182fd5b823567ffffffffffffffff8111156113b8578283fd5b6113c48582860161127a565b95602094909401359450505050565b6000602082840312156113e4578081fd5b81518015158114610b8b578182fd5b600060208284031215611404578081fd5b815164ffffffffff1981168114610b8b578182fd5b60006020828403121561142a578081fd5b5051919050565b600080600060608486031215611445578081fd5b83359250602084013567ffffffffffffffff80821115611463578283fd5b61146f878388016112f6565b93506040860135915080821115611484578283fd5b9085019060408288031215611497578283fd5b6040516040810181811083821117156114ac57fe5b604052823581526020830135828111156114c4578485fd5b6114d08982860161127a565b6020830152508093505050509250925092565b6000602082840312156114f4578081fd5b813567ffffffffffffffff81111561150a578182fd5b8201601f8101841361151a578182fd5b61152984823560208401611228565b949350505050565b600060208284031215611542578081fd5b813567ffffffffffffffff811115611558578182fd5b611529848285016112f6565b60008060408385031215611576578182fd5b825160208401519092506001600160a01b0381168114611594578182fd5b809150509250929050565b6001600160a01b0391909116815260200190565b901515815260200190565b90815260200190565b91825264ffffffffff1916602082015260400190565b600085825260208581840152846040840152608060608401528351806080850152825b8181101561161c5785810183015185820160a001528201611600565b8181111561162d578360a083870101525b50601f01601f19169290920160a0019695505050505050565b60208082526049908201527f4e756d626572206f6620737461746520726f6f74732063616e6e6f742065786360408201527f65656420746865206e756d626572206f662063616e6f6e6963616c207472616e60608201526839b0b1ba34b7b7399760b91b608082015260a00190565b60208082526018908201527f496e76616c696420696e636c7573696f6e2070726f6f662e0000000000000000604082015260600190565b6020808252603d908201527f41637475616c20626174636820737461727420696e64657820646f6573206e6f60408201527f74206d6174636820657870656374656420737461727420696e6465782e000000606082015260800190565b60208082526015908201527424b73b30b634b2103130ba31b4103432b0b232b91760591b604082015260600190565b602080825260409082018190527f537461746520626174636865732063616e206f6e6c792062652064656c657465908201527f642077697468696e207468652066726175642070726f6f662077696e646f772e606082015260800190565b6020808252603b908201527f537461746520626174636865732063616e206f6e6c792062652064656c65746560408201527f6420627920746865204f564d5f467261756456657269666965722e0000000000606082015260800190565b60208082526025908201527f4261746368206865616465722074696d657374616d702063616e6e6f74206265604082015264207a65726f60d81b606082015260800190565b60208082526023908201527f43616e6e6f74207375626d697420616e20656d7074792073746174652062617460408201526231b41760e91b606082015260800190565b6020808252602f908201527f50726f706f73657220646f6573206e6f74206861766520656e6f75676820636f60408201526e1b1b185d195c985b081c1bdcdd1959608a1b606082015260800190565b60208082526043908201527f43616e6e6f74207075626c69736820737461746520726f6f747320776974686960408201527f6e207468652073657175656e636572207075626c69636174696f6e2077696e6460608201526237bb9760e91b608082015260a00190565b60208082526014908201527324b73b30b634b2103130ba31b41034b73232bc1760611b604082015260600190565b9182526001600160a01b0316602082015260400190565b60405181810167ffffffffffffffff811182821017156119d457fe5b60405291905056fe4c69625f4d65726b6c65547265653a20496e646578206f7574206f6620626f756e64732e4c69625f4d65726b6c65547265653a2043616e6e6f7420636f6d70757465206365696c286c6f675f3229206f6620302e4c69625f4d65726b6c65547265653a20546f74616c206c6561766573206d7573742062652067726561746572207468616e207a65726f2e4f564d5f436861696e53746f72616765436f6e7461696e65722d5343432d626174636865734c69625f4d65726b6c65547265653a20546f74616c207369626c696e677320646f6573206e6f7420636f72726563746c7920636f72726573706f6e6420746f20746f74616c206c65617665732e4c69625f4d65726b6c65547265653a204d7573742070726f76696465206174206c65617374206f6e65206c65616620686173682ea2646970667358221220fe58eec60e1130e9f94565e6ea97ae3f590e96eeda1a972687d27ab93f7f7df464736f6c63430007060033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100b45760003560e01c80638ca5cbb9116100715780638ca5cbb91461012f5780639418bddd14610144578063b8e189ac14610157578063c17b291b1461016a578063cfdf677e14610172578063e561dddc1461017a576100b4565b8063299ca478146100b9578063461a4478146100d75780634d69ee57146100ea5780637aa63a861461010a5780637ad168a01461011f57806381eb62ef14610127575b600080fd5b6100c1610182565b6040516100ce919061159f565b60405180910390f35b6100c16100e53660046114e3565b610191565b6100fd6100f8366004611431565b61026f565b6040516100ce91906115b3565b6101126102e2565b6040516100ce91906115be565b6101126102fb565b610112610314565b61014261013d366004611390565b61031a565b005b6100fd610152366004611531565b61052e565b610142610165366004611531565b61057e565b610112610636565b6100c161063c565b610112610664565b6000546001600160a01b031681565b6000805460405163bf40fac160e01b81526020600482018181528551602484015285516001600160a01b039094169363bf40fac19387938392604490920191908501908083838b5b838110156101f15781810151838201526020016101d9565b50505050905090810190601f16801561021e5780820380516001836020036101000a031916815260200191505b509250505060206040518083038186803b15801561023b57600080fd5b505afa15801561024f573d6000803e3d6000fd5b505050506040513d602081101561026557600080fd5b505190505b919050565b600061027a836106de565b61029f5760405162461bcd60e51b815260040161029690611749565b60405180910390fd5b6102bc836020015185846000015185602001518760400151610776565b6102d85760405162461bcd60e51b8152600401610296906116b5565b5060019392505050565b6000806102ed6108fb565b5064ffffffffff1691505090565b6000806103066108fb565b64ffffffffff169250505090565b60025481565b6103226102e2565b81146103405760405162461bcd60e51b8152600401610296906116ec565b6103706040518060400160405280600f81526020016e27ab26afa137b73226b0b730b3b2b960891b815250610191565b6001600160a01b03166302ad4d2a336040518263ffffffff1660e01b815260040161039b919061159f565b60206040518083038186803b1580156103b357600080fd5b505afa1580156103c7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103eb91906113d3565b6104075760405162461bcd60e51b8152600401610296906118bb565b60008251116104285760405162461bcd60e51b815260040161029690611878565b6104666040518060400160405280601d81526020017f4f564d5f43616e6f6e6963616c5472616e73616374696f6e436861696e000000815250610191565b6001600160a01b0316637aa63a866040518163ffffffff1660e01b815260040160206040518083038186803b15801561049e57600080fd5b505afa1580156104b2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104d69190611419565b82516104e06102e2565b0111156104ff5760405162461bcd60e51b815260040161029690611646565b61052a8242336040516020016105169291906119a1565b604051602081830303815290604052610990565b5050565b60008082608001518060200190518101906105499190611564565b509050806105695760405162461bcd60e51b815260040161029690611833565b4261057682600154610b31565b119392505050565b6105b06040518060400160405280601181526020017027ab26afa33930bab22b32b934b334b2b960791b815250610191565b6001600160a01b0316336001600160a01b0316146105e05760405162461bcd60e51b8152600401610296906117d6565b6105e9816106de565b6106055760405162461bcd60e51b815260040161029690611749565b61060e8161052e565b61062a5760405162461bcd60e51b815260040161029690611778565b61063381610b92565b50565b60015481565b600061065f604051806060016040528060258152602001611a6860259139610191565b905090565b600061066e61063c565b6001600160a01b0316631f7b6d326040518163ffffffff1660e01b815260040160206040518083038186803b1580156106a657600080fd5b505afa1580156106ba573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061065f9190611419565b60006106e861063c565b8251604051634a83e9cd60e11b81526001600160a01b039290921691639507d39a91610716916004016115be565b60206040518083038186803b15801561072e57600080fd5b505afa158015610742573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107669190611419565b61076f83610d0a565b1492915050565b60008082116107b65760405162461bcd60e51b8152600401808060200182810382526037815260200180611a316037913960400191505060405180910390fd5b8184106107f45760405162461bcd60e51b81526004018080602001828103825260248152602001806119dd6024913960400191505060405180910390fd5b6107fd82610d50565b83511461083b5760405162461bcd60e51b815260040180806020018281038252604d815260200180611a8d604d913960600191505060405180910390fd5b8460005b84518110156108ee57856001166001141561089d5784818151811061086057fe5b60200260200101518260405160200180838152602001828152602001925050506040516020818303038152906040528051906020012091506108e2565b818582815181106108aa57fe5b602002602001015160405160200180838152602001828152602001925050506040516020818303038152906040528051906020012091505b600195861c950161083f565b5090951495945050505050565b600080600061090861063c565b6001600160a01b031663ccf8f9696040518163ffffffff1660e01b815260040160206040518083038186803b15801561094057600080fd5b505afa158015610954573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061097891906113f3565b64ffffffffff602882901c16935060501c9150509091565b60006109bf6040518060400160405280600c81526020016b27ab26afa83937b837b9b2b960a11b815250610191565b90506000806109cc6108fb565b9092509050336001600160a01b03841614156109e9575042610a13565b426002548264ffffffffff160110610a135760405162461bcd60e51b81526004016102969061190a565b60006040518060a00160405280610a28610664565b8152602001610a3688610de6565b8152602001875181526020018464ffffffffff16815260200186815250905080600001517f16be4c5129a4e03cf3350262e181dc02ddfb4a6008d925368c0899fcd97ca9c58260200151836040015184606001518560800151604051610a9f94939291906115dd565b60405180910390a2610aaf61063c565b6001600160a01b0316632015276c610ac683610d0a565b610ada84604001518560600151018661121a565b6040518363ffffffff1660e01b8152600401610af79291906115c7565b600060405180830381600087803b158015610b1157600080fd5b505af1158015610b25573d6000803e3d6000fd5b50505050505050505050565b600082820183811015610b8b576040805162461bcd60e51b815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b9392505050565b610b9a61063c565b6001600160a01b0316631f7b6d326040518163ffffffff1660e01b815260040160206040518083038186803b158015610bd257600080fd5b505afa158015610be6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c0a9190611419565b815110610c295760405162461bcd60e51b815260040161029690611973565b610c32816106de565b610c4e5760405162461bcd60e51b815260040161029690611749565b610c5661063c565b6001600160a01b031663167fd6818260000151610c788460600151600061121a565b6040518363ffffffff1660e01b8152600401610c959291906115c7565b600060405180830381600087803b158015610caf57600080fd5b505af1158015610cc3573d6000803e3d6000fd5b5050505080600001517f8747b69ce8fdb31c3b9b0a67bd8049ad8c1a69ea417b69b12174068abd9cbd648260200151604051610cff91906115be565b60405180910390a250565b60008160200151826040015183606001518460800151604051602001610d3394939291906115dd565b604051602081830303815290604052805190602001209050919050565b6000808211610d905760405162461bcd60e51b8152600401808060200182810382526030815260200180611a016030913960400191505060405180910390fd5b8160011415610da15750600061026a565b81600060805b60018110610dd1576000196001821b01811b831615610dc95791821c91908101905b60011c610da7565b506001811b8414610b8b576001019392505050565b600080825111610e275760405162461bcd60e51b8152600401808060200182810382526034815260200180611ada6034913960400191505060405180910390fd5b815160011415610e4d5781600081518110610e3e57fe5b6020026020010151905061026a565b60408051610200810182527f290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e56381527f633dc4d7da7256660a892f8f1604a44b5432649cc8ec5cb3ced4c4e6ac94dd1d60208201527f890740a8eb06ce9be422cb8da5cdafc2b58c0a5e24036c578de2a433c828ff7d818301527f3b8ec09e026fdc305365dfc94e189a81b38c7597b3d941c279f042e8206e0bd86060808301919091527fecd50eee38e386bd62be9bedb990706951b65fe053bd9d8a521af753d139e2da60808301527fdefff6d330bb5403f63b14f33b578274160de3a50df4efecf0e0db73bcdd3da560a08301527f617bdd11f7c0a11f49db22f629387a12da7596f9d1704d7465177c63d88ec7d760c08301527f292c23a9aa1d8bea7e2435e555a4a60e379a5a35f3f452bae60121073fb6eead60e08301527fe1cea92ed99acdcb045a6726b2f87107e8a61620a232cf4d7d5b5766b3952e106101008301527f7ad66c0a68c72cb89e4fb4303841966e4062a76ab97451e3b9fb526a5ceb7f826101208301527fe026cc5a4aed3c22a58cbd3d2ac754c9352c5436f638042dca99034e836365166101408301527f3d04cffd8b46a874edf5cfae63077de85f849a660426697b06a829c70dd1409c6101608301527fad676aa337a485e4728a0b240d92b3ef7b3c372d06d189322bfd5f61f1e7203e6101808301527fa2fca4a49658f9fab7aa63289c91b7c7b6c832a6d0e69334ff5b0a3483d09dab6101a08301527f4ebfd9cd7bca2505f7bef59cc1c12ecc708fff26ae4af19abe852afe9e20c8626101c08301527f2def10d13dd169f550f578bda343d9717a138562e0093b380a1120789d53cf106101e083015282518381529081018352909160009190602082018180368337505085519192506000918291508180805b60018411156111f65750506002820460018084161460005b82811015611172578a816002028151811061111957fe5b602002602001015196508a816002026001018151811061113557fe5b6020026020010151955086602089015285604089015287805190602001208b828151811061115f57fe5b6020908102919091010152600101611102565b5080156111d55789600185038151811061118857fe5b6020026020010151955087836010811061119e57fe5b602002015160001b945085602088015284604088015286805190602001208a83815181106111c857fe5b6020026020010181815250505b806111e15760006111e4565b60015b60ff16820193506001909201916110ea565b8960008151811061120357fe5b602002602001015198505050505050505050919050565b602890811b91909117901b90565b600067ffffffffffffffff83111561123c57fe5b61124f601f8401601f19166020016119b8565b905082815283838301111561126357600080fd5b828260208301376000602084830101529392505050565b600082601f83011261128a578081fd5b8135602067ffffffffffffffff8211156112a057fe5b8082026112ae8282016119b8565b8381528281019086840183880185018910156112c8578687fd5b8693505b858410156112ea5780358352600193909301929184019184016112cc565b50979650505050505050565b600060a08284031215611307578081fd5b60405160a0810167ffffffffffffffff828210818311171561132557fe5b8160405282935084358352602085013560208401526040850135604084015260608501356060840152608085013591508082111561136257600080fd5b508301601f8101851361137457600080fd5b61138385823560208401611228565b6080830152505092915050565b600080604083850312156113a2578182fd5b823567ffffffffffffffff8111156113b8578283fd5b6113c48582860161127a565b95602094909401359450505050565b6000602082840312156113e4578081fd5b81518015158114610b8b578182fd5b600060208284031215611404578081fd5b815164ffffffffff1981168114610b8b578182fd5b60006020828403121561142a578081fd5b5051919050565b600080600060608486031215611445578081fd5b83359250602084013567ffffffffffffffff80821115611463578283fd5b61146f878388016112f6565b93506040860135915080821115611484578283fd5b9085019060408288031215611497578283fd5b6040516040810181811083821117156114ac57fe5b604052823581526020830135828111156114c4578485fd5b6114d08982860161127a565b6020830152508093505050509250925092565b6000602082840312156114f4578081fd5b813567ffffffffffffffff81111561150a578182fd5b8201601f8101841361151a578182fd5b61152984823560208401611228565b949350505050565b600060208284031215611542578081fd5b813567ffffffffffffffff811115611558578182fd5b611529848285016112f6565b60008060408385031215611576578182fd5b825160208401519092506001600160a01b0381168114611594578182fd5b809150509250929050565b6001600160a01b0391909116815260200190565b901515815260200190565b90815260200190565b91825264ffffffffff1916602082015260400190565b600085825260208581840152846040840152608060608401528351806080850152825b8181101561161c5785810183015185820160a001528201611600565b8181111561162d578360a083870101525b50601f01601f19169290920160a0019695505050505050565b60208082526049908201527f4e756d626572206f6620737461746520726f6f74732063616e6e6f742065786360408201527f65656420746865206e756d626572206f662063616e6f6e6963616c207472616e60608201526839b0b1ba34b7b7399760b91b608082015260a00190565b60208082526018908201527f496e76616c696420696e636c7573696f6e2070726f6f662e0000000000000000604082015260600190565b6020808252603d908201527f41637475616c20626174636820737461727420696e64657820646f6573206e6f60408201527f74206d6174636820657870656374656420737461727420696e6465782e000000606082015260800190565b60208082526015908201527424b73b30b634b2103130ba31b4103432b0b232b91760591b604082015260600190565b602080825260409082018190527f537461746520626174636865732063616e206f6e6c792062652064656c657465908201527f642077697468696e207468652066726175642070726f6f662077696e646f772e606082015260800190565b6020808252603b908201527f537461746520626174636865732063616e206f6e6c792062652064656c65746560408201527f6420627920746865204f564d5f467261756456657269666965722e0000000000606082015260800190565b60208082526025908201527f4261746368206865616465722074696d657374616d702063616e6e6f74206265604082015264207a65726f60d81b606082015260800190565b60208082526023908201527f43616e6e6f74207375626d697420616e20656d7074792073746174652062617460408201526231b41760e91b606082015260800190565b6020808252602f908201527f50726f706f73657220646f6573206e6f74206861766520656e6f75676820636f60408201526e1b1b185d195c985b081c1bdcdd1959608a1b606082015260800190565b60208082526043908201527f43616e6e6f74207075626c69736820737461746520726f6f747320776974686960408201527f6e207468652073657175656e636572207075626c69636174696f6e2077696e6460608201526237bb9760e91b608082015260a00190565b60208082526014908201527324b73b30b634b2103130ba31b41034b73232bc1760611b604082015260600190565b9182526001600160a01b0316602082015260400190565b60405181810167ffffffffffffffff811182821017156119d457fe5b60405291905056fe4c69625f4d65726b6c65547265653a20496e646578206f7574206f6620626f756e64732e4c69625f4d65726b6c65547265653a2043616e6e6f7420636f6d70757465206365696c286c6f675f3229206f6620302e4c69625f4d65726b6c65547265653a20546f74616c206c6561766573206d7573742062652067726561746572207468616e207a65726f2e4f564d5f436861696e53746f72616765436f6e7461696e65722d5343432d626174636865734c69625f4d65726b6c65547265653a20546f74616c207369626c696e677320646f6573206e6f7420636f72726563746c7920636f72726573706f6e6420746f20746f74616c206c65617665732e4c69625f4d65726b6c65547265653a204d7573742070726f76696465206174206c65617374206f6e65206c65616620686173682ea2646970667358221220fe58eec60e1130e9f94565e6ea97ae3f590e96eeda1a972687d27ab93f7f7df464736f6c63430007060033",
  "devdoc": {
    "details": "The State Commitment Chain (SCC) contract contains a list of proposed state roots which Proposers assert to be a result of each transaction in the Canonical Transaction Chain (CTC). Elements here have a 1:1 correspondence with transactions in the CTC, and should be the unique state root calculated off-chain by applying the canonical transactions one by one. Compiler used: solc Runtime target: EVM",
    "kind": "dev",
    "methods": {
      "appendStateBatch(bytes32[],uint256)": {
        "params": {
          "_batch": "Batch of state roots.",
          "_shouldStartAtElement": "Index of the element at which this batch should start."
        }
      },
      "batches()": {
        "returns": {
          "_0": "Reference to the batch storage container."
        }
      },
      "constructor": {
        "params": {
          "_libAddressManager": "Address of the Address Manager."
        }
      },
      "deleteStateBatch((uint256,bytes32,uint256,uint256,bytes))": {
        "params": {
          "_batchHeader": "Header of the batch to start deleting from."
        }
      },
      "getLastSequencerTimestamp()": {
        "returns": {
          "_lastSequencerTimestamp": "Last sequencer batch timestamp."
        }
      },
      "getTotalBatches()": {
        "returns": {
          "_totalBatches": "Total submitted batches."
        }
      },
      "getTotalElements()": {
        "returns": {
          "_totalElements": "Total submitted elements."
        }
      },
      "insideFraudProofWindow((uint256,bytes32,uint256,uint256,bytes))": {
        "params": {
          "_batchHeader": "Header of the batch to check."
        },
        "returns": {
          "_inside": "Whether or not the batch is inside the fraud proof window."
        }
      },
      "resolve(string)": {
        "params": {
          "_name": "Name to resolve an address for."
        },
        "returns": {
          "_0": "Address associated with the given name."
        }
      },
      "verifyStateCommitment(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]))": {
        "params": {
          "_batchHeader": "Header of the batch in which the element was included.",
          "_element": "Hash of the element to verify a proof for.",
          "_proof": "Merkle inclusion proof for the element."
        }
      }
    },
    "title": "OVM_StateCommitmentChain",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "appendStateBatch(bytes32[],uint256)": {
        "notice": "Appends a batch of state roots to the chain."
      },
      "batches()": {
        "notice": "Accesses the batch storage container."
      },
      "deleteStateBatch((uint256,bytes32,uint256,uint256,bytes))": {
        "notice": "Deletes all state roots after (and including) a given batch."
      },
      "getLastSequencerTimestamp()": {
        "notice": "Retrieves the timestamp of the last batch submitted by the sequencer."
      },
      "getTotalBatches()": {
        "notice": "Retrieves the total number of batches submitted."
      },
      "getTotalElements()": {
        "notice": "Retrieves the total number of elements submitted."
      },
      "insideFraudProofWindow((uint256,bytes32,uint256,uint256,bytes))": {
        "notice": "Checks whether a given batch is still inside its fraud proof window."
      },
      "resolve(string)": {
        "notice": "Resolves the address associated with a given name."
      },
      "verifyStateCommitment(bytes32,(uint256,bytes32,uint256,uint256,bytes),(uint256,bytes32[]))": {
        "notice": "Verifies a batch inclusion proof."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 15303,
        "contract": "contracts/optimistic-ethereum/OVM/chain/OVM_StateCommitmentChain.sol:OVM_StateCommitmentChain",
        "label": "libAddressManager",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(Lib_AddressManager)15296"
      },
      {
        "astId": 6159,
        "contract": "contracts/optimistic-ethereum/OVM/chain/OVM_StateCommitmentChain.sol:OVM_StateCommitmentChain",
        "label": "FRAUD_PROOF_WINDOW",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 6161,
        "contract": "contracts/optimistic-ethereum/OVM/chain/OVM_StateCommitmentChain.sol:OVM_StateCommitmentChain",
        "label": "SEQUENCER_PUBLISH_WINDOW",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_contract(Lib_AddressManager)15296": {
        "encoding": "inplace",
        "label": "contract Lib_AddressManager",
        "numberOfBytes": "20"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}